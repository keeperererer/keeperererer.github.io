<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js-questions]]></title>
    <url>%2F2019%2F07%2F30%2Fjs-questions%2F</url>
    <content type="text"><![CDATA[1.哪一个是无效的？ 12345678910111213const bird = &#123; size: &apos;small&apos;&#125;const mouse = &#123; name: &apos;Mickey&apos;, small: true&#125;A: mouse.bird.sizeB: mouse[bird.size]C: mouse[bird[&quot;size&quot;]]D: All of them are valid 答案: A在 JavaScript 中，所有对象的 keys 都是字符串（除非对象是 Symbol）。尽管我们可能不会定义它们为字符串，但它们在底层总会被转换为字符串。 当我们使用括号语法时（[]），JavaScript 会解释（或者 unboxes）语句。它首先看到第一个开始括号 [ 并继续前进直到找到结束括号 ]。只有这样，它才会计算语句的值。 mouse[bird.size]：首先计算 bird.size，这会得到 small。mouse[“small”] 返回 true。 然后使用点语法的话，上面这一切都不会发生。mouse 没有 bird 这个 key，这也就意味着 mouse.bird 是 undefined。然后当我们使用点语法 mouse.bird.size 时，因为 mouse.bird 是 undefined，这也就变成了 undefined.size。这个行为是无效的，并且会抛出一个错误类似 Cannot read property “size” of undefined。 2.输出是什么？1234567891011121314151617class Chameleon &#123; static colorChange(newColor) &#123; this.newColor = newColor return this.newColor &#125; constructor(&#123; newColor = &apos;green&apos; &#125; = &#123;&#125;) &#123; this.newColor = newColor &#125;&#125;const freddie = new Chameleon(&#123; newColor: &apos;purple&apos; &#125;)freddie.colorChange(&apos;orange&apos;)A: orangeB: purpleC: greenD: TypeError 答案: DcolorChange 是一个静态方法。静态方法被设计为只能被创建它们的构造器使用（也就是 Chameleon），并且不能传递给实例。因为 freddie 是一个实例，静态方法不能被实例使用，因此抛出了 TypeError 错误。 3.当我门这么做时，会发生什么？123456789function bark() &#123; console.log(&apos;Woof!&apos;)&#125;bark.animal = &apos;dog&apos;A: 正常运行!B: SyntaxError. 你不能通过这种方式给函数增加属性。C: undefinedD: ReferenceError 答案: A这在 JavaScript 中是可以的，因为函数是对象！（除了基本类型之外其他都是对象） 函数是一个特殊的对象。你写的这个代码其实不是一个实际的函数。函数是一个拥有属性的对象，并且属性也可被调用。 4.输出是什么？123456789101112131415function Person(firstName, lastName) &#123; this.firstName = firstName; this.lastName = lastName;&#125;const member = new Person(&quot;Lydia&quot;, &quot;Hallie&quot;);Person.getFullName = function () &#123; return `$&#123;this.firstName&#125; $&#123;this.lastName&#125;`;&#125;console.log(member.getFullName());A: TypeErrorB: SyntaxErrorC: Lydia HallieD: undefined undefined 答案: ASyntaxError 对象代表尝试解析语法上不合法的代码的错误.TypeError(类型错误) 对象用来表示值的类型非预期类型时发生的错误.你不能像常规对象那样，给构造函数添加属性。如果你想一次性给所有实例添加特性，你应该使用原型。因此本例中，使用如下方式： Person.prototype.getFullName = function () { return ${this.firstName} ${this.lastName};}这才会使 member.getFullName() 起作用。为什么这样做有什么优点？假设我们将这个方法添加到构造函数本身里。也许不是每个 Person 实例都需要这个方法。这将浪费大量内存空间，因为它们仍然具有该属性，这将占用每个实例的内存空间。相反，如果我们只将它添加到原型中，那么它只存在于内存中的一个位置，但是所有实例都可以访问它！]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FastClick原理浅析]]></title>
    <url>%2F2019%2F07%2F29%2FFastClick%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[为什么使用FastClick 在移动端H5开发过程中，关于点触可能回遇到如下两个问题： 手动点击与真正触发click事件会存在300ms的延迟 点击穿透问题(点击行为会穿透元素触发非父子关系元素的事件) 延迟的存在时因为浏览器想知道你是否在进行双击操作，而点击穿透是因为300ms延迟触发时的副作用。而使用fastclick能很好的解决这个问题，增加使用者的体验。 原理过程这里描述一个按钮点击过程的处理。12345678910111213141516171819202122//业务代码var $test = document.getElementById(&apos;test&apos;)$test.addEventListener(&apos;click&apos;,function()&#123; console.log(&apos;1 click&apos;)&#125;)//FastClick简单实现var targetElemet = nulldocument.body.addEventListener(&apos;touchstart&apos;,function()&#123; //记录点击的元素 targetElement = event.target&#125;)document.body.addEventListener(&apos;touchend&apos;,functoin(event)&#123; //阻止默认事件(屏蔽之后的click事件) event.preventDefault() var touch = event.changedTouched[0] //合成click事件，并添加可跟踪属性forwardedTouchEvent var clickEvent = document.createEvent(&apos;MouseEvents&apos;) clickEvent.initMouseEvent(&apos;click&apos;, true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null) clickEvent.forwardedTouchEvent = true //自定义的 targetElement.dispatchEvent(clickEvent)&#125;) 这里进行过程说明 业务正常使用click绑定事件 在document.body绑定touchstart和touchend stouchstart 用于记录当前点击的元素targetElement; touchend 阻止默认事件(屏蔽之后的click事件) 合成click事件，并添加可跟踪属性forwardedTouchEvent 在targetElement上触发click事件 targetElement上绑定的事件立即执行，完成FastCLick 执行业务自己的click事件 总结touch事件先于mouse事件先于click执行，因此可以在document.body上绑定事件用于监听点触行为，根据需要模拟click触发真正需要响应的元素 转载于]]></content>
  </entry>
  <entry>
    <title><![CDATA[css实现多重边框的5种方式]]></title>
    <url>%2F2019%2F07%2F25%2Fcss%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%87%8D%E8%BE%B9%E6%A1%86%E7%9A%845%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[利用描边(outline)属性 代码12345678910111213141516&lt;style&gt; .borders &#123; border: solid 6px #dd7b40; //here outline: solid 6px #888; //here &#125; .base &#123; background: #222; padding: 4rem 2rem; color:#fff; font-weight: bold; text-align: center; margin: 1rem; &#125;&lt;/style&gt;&lt;div class=&quot;base borders&quot;&gt;利用outline实现双重边框&lt;/div&gt; 利用描边(outline)属性结合border属性实现双重边框。此方案实现简单，兼容性好，能兼容除IE6,7以外的浏览器。 说明 只能实现双重边框 边框样式灵活，可以实现虚线等样式的边框 描边在盒模型之外，会与外部元素发生重叠 利用额外的div https://juejin.im/entry/5b7665a6518825332e322d89]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue生命周期函数]]></title>
    <url>%2F2019%2F07%2F25%2Fvue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[上图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;script src=&quot;./lib/vue.js&quot;&gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;Button&quot; @click=&quot;msg=&apos;No&apos;&quot;&gt; &lt;h3 id=&apos;h3&apos;&gt;&#123;&#123;msg&#125;&#125;&lt;/h3&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue( &#123; el: &apos;#app&apos;, data:&#123; msg:&apos;ok&apos; &#125;, methods: &#123; show()&#123; console.log(&apos;执行了&apos;) &#125; &#125;, beforeCreate() &#123; //这是遇到的第一个生命周期函数表示实例完全会被创建出来，会执行 console.log(this.msg) //这时候console会显示undefined this.show() //this.show is not a method //注意在beforeCreate生命周期函数执行的时候，data和methods中的数据都还没有被初始化 &#125;, created() &#123; //这是遇到的第二个生命周期函数 console.log(this.msg) this.show() //在created中，data和methods都已经初始化好了 //如果要调用methods中的方法，最早只能在created中操作 &#125;, beforeMount() &#123; //这是遇到的第3个生命周期函数，表示模板已经编译完成，但是尚未把模板渲染到页面中去 console.log(document.getElementById(&apos;h3&apos;).innerText)//&#123;&#123;msg&#125;&#125; //在beforeMount执行的时候，页面中的元素没有被真正替换过来，只是之前的一些模板字符串 &#125;, mounted() &#123; //这是遇到的第四个生命周期函数，表示内存中的模板，已经真实的挂载到了浏览器的页面中，用户已经看到了渲染好的页面 console.log(document.getElementById(&apos;h3&apos;).innerText)//ok //注意：mounted是实例创建中的最后一个生命周期函数，当执行完mounted，实例就完全被创建好了 &#125;, beforeUpdate() &#123; console.log(&apos;界面上元素的内容&apos;+document.getElementById(&apos;h3&apos;).innerText) console.log(&apos;data中的msg数据是&apos;+this.msg) //界面上元素的内容ok //data中的msg数据是No &#125;, updated() &#123; console.log(&apos;界面上元素的内容&apos; + document.getElementById(&apos;h3&apos;).innerText) console.log(&apos;data中的msg数据是&apos; + this.msg) //界面上元素的内容No //data中的msg数据是No //页面和data数据已经保持一致了 &#125;, &#125; ) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 原文链接]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[requestAnimationFrame]]></title>
    <url>%2F2019%2F07%2F10%2FrequestAnimationFrame%2F</url>
    <content type="text"><![CDATA[引入与setTimeout和setInterval不同，requestAnimationFrame不需要设置时间间隔。大多数电脑显示器的刷新频率是60Hz，大概相当于每秒钟重绘60次。大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升。因此，最平滑动画的最佳循环间隔是l000ms/60，约等于16.6ms 而setTimeout和setInterval的问题是，它们都不精确。它们的内在运行机制决定了时间间隔参数实际上只是指定了把动画代码添加到浏览器UI线程队列中以等待执行的时间。如果队列前面已经加入了其他任务，那动画代码就要等前面的任务完成后再执行 requestAnimationFrame采用系统时间间隔，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间太长，使用动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果 特点 requestAnimationFrame会把每一帧中的所有DOM操作集中起来，在一起重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率 在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就以为着更少的cpu，gpu和内存使用量 requestAnimationFrame是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销 使用requestAnimationFrame的用法与setTimeout很相似，只是不需要设置时间间隔而已。requestAnimationFrame使用一个回调函数作为参数，这个回调函数会在浏览器重绘回流之前调用。它返回一个整数，表示定时器的编号，这个值可以传递cancelAnimationFrame用于取消这个函数的执行 1requestID = requestAnimationFrame(callback)； 12345//控制台输出1和0var timer = requestAnimationFrame(function()&#123; console.log(0);&#125;);console.log(timer);//1 cancelAnimationFrame方法用于取消定时器12345//控制台什么都不输出var timer = requestAnimationFrame(function()&#123; console.log(0);&#125;);cancelAnimationFrame(timer); 也可以直接使用返回值进行取消1234var timer = requestAnimationFrame(function()&#123; console.log(0);&#125;);cancelAnimationFrame(1);]]></content>
      <tags>
        <tag>h5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是防抖和节流？有什么区别？如何实现？]]></title>
    <url>%2F2019%2F07%2F04%2F%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[防抖 触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间 思路 每次触发事件时都取消之前的延时调用方法 12345678910111213141516function debounce(fn)&#123; let timeout = null;//创建一个标记用来存放定时器的返回值 return function()&#123; clearTimeout(timeout);//每当用户输入的时候把前一个setTimeout clear掉 timeout = setTimeout(()=&gt;&#123;//然后又创建一个新的setTimeout，这样就能保证输入字符后的interval间隔内如果还有字符输入的话，就不会执行fn函数 fn.apply(this,arguments); &#125;,500); &#125;;&#125;function sayHi()&#123; console.log(&apos;防抖成功&apos;)&#125;var inp = document.getElementById(&apos;inp&apos;);inp.addEventListener(&apos;input&apos;,debounce(sayHi));//防抖 节流 高频事件触发，但在n秒内指挥执行一次，所以节流会稀释函数的执行频率 思路 每次触发事件时都判断当前是否有等待执行的延时函数,如果没有，就直接执行这个函数，如果有等待执行的延时函数，就在设置的这段时间内不去执行。 12345678910111213141516function throttle(fn)&#123; let canRun = true;//通过闭包保存一个标记 return function()&#123; if(!canRun) return;//在函数开头判断标记是否为true,不为true则return canRun = false;//立即设置为false setTimeout(()=&gt;&#123;//将外部传入的函数的执行放在setTimeout中 fn.apply(this,arguments); //最后在setTimeout执行完毕后再把标记设置为true（关键）表示可以执行下一次循环了。当定时器没有执行的时候标记永远时false，再开头被return掉 canRun = true; &#125;,500) &#125;&#125;function sayHi(e)&#123; console.log(e.target.innerWidth,e.target.innerHeight);&#125;window.addEventListener(&apos;resize&apos;,throttle(sayHi));]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析比较opacity:0、visibility:hidden、display:none优劣和适用场景]]></title>
    <url>%2F2019%2F07%2F03%2F%E5%88%86%E6%9E%90%E6%AF%94%E8%BE%83opacity-0%E3%80%81visibility-hidden%E3%80%81display-none%E4%BC%98%E5%8A%A3%E5%92%8C%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[结构： display:none; 会让元素完全从渲染树中消失，渲染的时候不占据任何空间，不能点击。visibility:hidden;不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，不能点击。opacity:0;不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击 继承：display: none和opacity: 0：是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示。visibility: hidden：是继承属性，子孙节点会由于继承了hidden而消失，通过设置visibility: visible;可以让子孙节点显示。 性能：display：none; 修改元素会造成文档回流,读屏器不会读取display: none元素内容，性能消耗较大visibility:hidden;修改元素只会造成本元素的重绘,性能消耗较少读屏器读取visibility: hidden元素内容opacity: 0 ;修改元素会造成重绘，性能消耗较少]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[介绍下Promise.all使用、原理实现及错误处理]]></title>
    <url>%2F2019%2F07%2F03%2F%E4%BB%8B%E7%BB%8D%E4%B8%8BPromise-all%E4%BD%BF%E7%94%A8%E3%80%81%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8F%8A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[Promise概念 Promise是JS异步编程中的重要概念，异步抽象处理对象，是目前比较流行Javascript异步编程解决方案之一。Promise.all()接受一个由promise任务组成的数组，可以同时处理多个promise任务，当所有的任务都执行完成时，Promise.all()返回resolve，但当有一个失败(reject)，则返回失败的信息，即使其他promise执行成功，也会返回失败。 Promise.all如何使用对于Promise.all(arr)来说，在参数数组中所有元素都变为决定态后，然后才返回新的promise。12345678910//以下demo，请求两个url,当两个异步请求返回结果后，再请求第三个urlconst p1 = request(`http://some.url.1`)const p2 = request(`http://some.url.2`)Promise.all([p1, p2]) .then((datas) =&gt; &#123; // 此处 datas 为调用 p1, p2 后的结果的数组 return request(`http://some.url.3?a=$&#123;datas[0]&#125;&amp;b=$&#123;datas[1]&#125;`) &#125;) .then((data) =&gt; &#123; console.log(msg)&#125;) Promise.all原理实现1234567function promiseAll(promise)&#123; return new Promise(function(resolve,reject)&#123; if(!Array.isArray(promises))&#123; &#125; &#125;)&#125;]]></content>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3之BFC,IFC,GFC和FFC]]></title>
    <url>%2F2019%2F07%2F03%2Fcss3%E4%B9%8BBFC-IFC-GFC%E5%92%8CFFC%2F</url>
    <content type="text"><![CDATA[css2.1中只有BFC和IFC，css3中才有GFC和FFC 什么是FCFC的全称是：Formatting Contexts,是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且又一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。 BFCBFC(Block Formatting Contexts)直译为”块级格式化上下文”。Block Formatting Contexts就是页面上的一个隔离的渲染区域，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此。如何产生BFC？float的值不为none。overflow的值不为visible。position的值不为relative和static。display的值为table-cell, table-caption, inline-block中的任何一个。那BFC一般有什么用呢？比如常见的多栏布局，结合块级别元素浮动，里面的元素则是在一个相对隔离的环境里运行。 IFCIFC(Inline Formatting Contexts)直译为”内联格式化上下文”，IFC的line box(线框)高度由其包含行内元素中最高的实际高度计算而来(不受到竖直方向的padding/margin影响)IFC中的line box一般左右都贴紧整个IFC，但是会因为float元素而绕乱。float元素会位于IFC与line box之间，使得line box宽度缩短。同个IFC下的多个line box高度不同。IFC中是不可能又块级元素的，当插入块级元素时(如p中插入div)会产生两个匿名块与div分隔开，即产生两个IFC，每个IFC对外表现为块级元素，与div垂直排列。 那么IFC一般有什么用呢？ 水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC,通过text-align则可以使其水平居中。 垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。 GFCGFC(GridLayout Formatting Contexts)直译为”网格布局格式化上下文”，当为一个元素设置display值为grid的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性各在网格项目（grid item）上定义网格行（grid row）和网格列（grid columns）为每一个网格项目（grid item）定义位置和空间。那么GFC有什么用呢，和table又有什么区别呢？首先同样是一个二维的表格，但GridLayout会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染语义和控制。 FFCFFC(Flex Formatting Contexts)直译为”自适应格式化上下文”，display值为flex或者inline-flex的元素将会生成自适应容器（flex container），可惜这个牛逼的属性只有谷歌和火狐支持，不过在移动端也足够了，至少safari和chrome还是OK的，毕竟这俩在移动端才是王道。Flex Box 由伸缩容器和伸缩项目组成。通过设置元素的 display 属性为 flex 或 inline-flex 可以得到一个伸缩容器。设置为 flex 的容器被渲染为一个块级元素，而设置为 inline-flex 的容器则渲染为一个行内元素。伸缩容器中的每一个子元素都是一个伸缩项目。伸缩项目可以是任意数量的。伸缩容器外和伸缩项目内的一切元素都不受影响。简单地说，Flexbox 定义了伸缩容器内伸缩项目该如何布局。]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输出以下代码运行结果]]></title>
    <url>%2F2019%2F07%2F02%2F%E8%BE%93%E5%87%BA%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[//example11234var a = &#123;&#125;,b = &apos;123&apos;,c = 123;a[b] = &apos;b&apos;;a[c] = &apos;c&apos;;console.log(a[b]); //example21234var a = &#123;&#125;,b = Symbol(&apos;123&apos;),c = Symbol(&apos;123&apos;);a[b] = &apos;b&apos;;a[c] = &apos;c&apos;;console.log(a[b]); //example31234var a = &#123;&#125;,b = &#123;key : &apos;123&apos;&#125;,c = &#123;key : &apos;456&apos;&#125;;a[b] = &apos;b&apos;;a[c] = &apos;c&apos;;console.log(a[b]); 解析：考察的是对象的键名的转换 对象的键名只能是字符串和Symbol类型 其他类型的键名会被转换成字符串类型 对象转字符串默认会调用toString方法 //example112345678var a = &#123;&#125;, b = &apos;123&apos;, c = 123;a[b] = &apos;b&apos;;//c的键名会被转换为字符串&apos;123&apos;,这里会把上面的 b 覆盖掉a[c] = &apos;c&apos;;//输出cconsole.log(a[b]); //example212345678910var a = &#123;&#125;,b = Symbol(&apos;123&apos;), c = Symbol(&apos;123&apos;);//b是Symbol类型不需要转换a[b] = &apos;b&apos;;//c是Symbol类型不需要转换，而且每个Symbol类型的值都是不相等的，所以不会覆盖掉ba[c] = &apos;c&apos;;//输出bconsole.log(a[b]); //example3123456789101112var a = &#123;&#125;,b = &#123;key:&apos;123&apos;&#125;, c = &#123;key:&apos;456&apos;&#125;;//b不是字符串也不是Symbol类型，需要转换成字符串//对象类型会调用toString方法转化成字符串[object Object]a[b] = &apos;b&apos;;// c 不是字符串也不是 Symbol 类型，需要转换成字符串。// 对象类型会调用 toString 方法转换成字符串 [object Object]。这里会把 b 覆盖掉。a[c]=&apos;c&apos;; // 输出 cconsole.log(a[b]); 123456var a = &#123;n : 1&#125;;var b = a;a.x = a = &#123;n : 2&#125;;console.log(a.x); // --&gt; undefinedconsole.log(b.x); // --&gt; &#123;n: 2&#125; 解析 优先级。 . 的优先级高于 = ，所以先执行a.x，堆内存中的{n: 1}就会变成{n: 1, x: undefined}，改变之后相应的b.x也变化了，因为指向的是同一个对象。 赋值操作是从右到左，所以执行a = {n: 2}，a的引用就被改变了，然后这个返回值又赋值给了a.x，需要注意的是这时候a.x是第一步中的{n: 1, x: undefined}那个对象，其实就是b.x，相当于b.x = {n: 2}]]></content>
      <tags>
        <tag>题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[介绍下HTTPS中间人攻击]]></title>
    <url>%2F2019%2F07%2F02%2F%E4%BB%8B%E7%BB%8D%E4%B8%8BHTTPS%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[中间人攻击过程如下： 服务器向客户端发送公钥 攻击者截获公钥，保留在自己手上 然后攻击者自己生成一个伪造的公钥，发送给客户端 客户端收到伪造的公钥后，生成加密的hash值发给服务器 攻击者获得加密hash值，用自己的私钥解密获得真密钥 同时生成假的加密hash值，发给服务器 服务器用私钥解密获得假私钥 服务器用假私钥加密传输信息 防范方法： 服务端在发送浏览器的公钥中加入CA证书，浏览器可以验证CA证书的有效性]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue知识点or面试题]]></title>
    <url>%2F2019%2F07%2F02%2Fvue%E7%9F%A5%E8%AF%86%E7%82%B9or%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[vue.js的特点 简洁：页面由HTML模板+Json数据+Vue实例自称数据驱动:自动计算属性和追踪依赖的模板表达式组件化：用可复用，解耦的组件来构造页面轻量：代码量小，不依赖其他库快速：精确有效批量DOM更新模板友好：可通过npm,bower等多种方式安装，很容易融入 active-class是哪个组件的属性 vue-router模板的router-link组件 vue-router有哪几种导航钩子 三种。一种是全局导航钩子:router.beforeEach(to,from,next),作用：跳转前进行判断拦截第二种：组件内的钩子第三种：单独路由独享组件（需要补充完整） 请说出vue-cli项目中src目录每个文件夹和文件的用法 assets:静态资源componenets:放组件router：定义路由相关的配置view：视图app.vue:一个应用主组件main.js:入口文件 vue路由传参数 使用query方法传入的参数使用this.$route.query接受使用params方式传入的参数使用this.$route.params接受 delete和Vue.delete删除数组的区别 delete只是被删除的元素变成了empty/undefined其他的元素的键值还是不变。Vue.delete直接删除了数组，改变了数组的键值123456var a = [1,2,3,4]var b = [1,2,3,4]delete a[0]console.log(a) //[empty,2,3,4]this.$delete(b,0)console.log(b) //[2,3,4] vue中的ref是什么 ref被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的$refs对象上。如果在普通的DOM元素上使用，引用指向的就是DOM元素；如果用在子组件上，引用就指向组件实例。 $route和$router的区别 $route是‘路由信息对象’，包括path,params,hash,query,fullPath,mached,name等路由信息参数$router是‘路由实例’对象包括了路由的跳转方法，钩子函数等 vue在v-for时给每项元素绑定事件需要事件代理吗 不需要 但是可以使用 源码没有做事件代理参考 Vue的父组件和子组件生命周期执行顺序是什么 加载渲染过程：父beforeCreate-&gt; 父created -&gt; 父beforeMount -&gt; 子beforeCreate -&gt; 子created -&gt; 子beforeMount -&gt; 子mounted -&gt; 父mounted 子组件更新过程：父beforeUpdate -&gt; 子beforeUpdate -&gt; 子Updated -&gt; 父Updated 父组件更新过程： 父beforeUpdate -&gt; 父Updated 销毁过程： 父beforeDestroy -&gt; 子beforeDestroy -&gt; 子destroyed -&gt;父destroyed]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js添加事件和移除事件:addEventListener与removeEventListener]]></title>
    <url>%2F2019%2F06%2F05%2Fjs%E6%B7%BB%E5%8A%A0%E4%BA%8B%E4%BB%B6%E5%92%8C%E7%A7%BB%E9%99%A4%E4%BA%8B%E4%BB%B6-addEventListener%E4%B8%8EremoveEventListener%2F</url>
    <content type="text"><![CDATA[addEventListener()和removeEventListener()讲解 addEventListener()与removeEventListener()用于处理指定和删除事件处理程序操作 它们都接受3个参数：如addEventListener(“事件名”,”事件处理函数”,”布尔值（可选，默认为false)”); (注：事件名不含”on”,如”click”) 示例：要在body上添加事件处理程序，可以使用下列代码：123document.body.addEventLisener(&apos;touchmove&apos;,function(event)&#123; event.preventDefault();&#125;,false); 通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除;移除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过addEventListener()添加的匿名函数无法移除 错误用法示例1234567document.body.addEventListener(&apos;touchmove&apos;,function(event)&#123; event.preventDefault();&#125;,false);document.body.removeEventListener(&apos;touchmove&apos;,function(event)&#123; event.preventDefault();&#125;,false); 这个例子中，使用addEventListener()添加一个事件处理程序。虽然调用removeEventListener()时看似使用了相同的参数，但实际上，第二个参数与传入addEventListener()中的那一个完全不同的函数。而传入removeEventListener()中的事件处理程序函数必须与传入addEventListener()中的相同 正确用法示例12345function bodyScroll(event)&#123; event.preventDefault();&#125;document.body.addEventListener(&apos;touchmove&apos;,bodyScroll,false);document.body.removeEventListener(&apos;touchmove&apos;,bodyScroll,false); 重写后的这个例子在addEventListener()和removeEventListener()中用的是相同的函数。 共用函数不能带参数，错误用法示例：12345function bodyScroll(event)&#123; event.preventDefault();&#125;document.body.addEventListener(&apos;touchmove&apos;,bodyScroll(),false);document.body.removeEventListener(&apos;touchmove&apos;,bodyScroll(),false); 总结：1：相同事件绑定和解除，需要使用共用函数；绑定和解除事件时 事件没有”on” 即onclick写成click 2：共用函数不能带参数; addEventListener()与removeEventListener()的第三个参数详解布尔值参数是true，表示在捕获阶段调用事件处理程序；就是最不具体的节点先接收事件，最具体的节点最后接收事件 如果是false，在冒泡阶段调用事件处理程序;则是先寻找指定的位置，由最具体的元素接收，然后逐级向上传播至最不具体的元素的节点（文档） 示例：123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;添加事件&amp;&amp;解绑事件&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;out&quot;&gt; &lt;p&gt;最外面&lt;/p&gt; &lt;div id=&quot;middle&quot;&gt; &lt;div id=&quot;inner&quot;&gt;最里面&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 12345678910&lt;script&gt; var out = document.getElementById(&apos;out&apos;); var middle = document.getElementById(&apos;middle&apos;); var inner = document.getElementById(&apos;inner&apos;); //点击inner时，触发顺序为：out------inner-------middle out.addEventListener(&apos;click&apos;,function()&#123;alert(&quot;我是最外面的&quot;);&#125;,true); middle.addEventListener(&apos;click&apos;,function()&#123;alert(&quot;我是中间的&quot;);&#125;,false); inner.addEventListener(&apos;click&apos;,function()&#123;alert(&quot;我是最里面的&quot;);&#125;,false);&lt;/script&gt; 12345678910&lt;script&gt; var out = document.getElementById(&apos;out&apos;); var middle = document.getElementById(&apos;middle&apos;); var inner = document.getElementById(&apos;inner&apos;); //点击inner时，触发顺序为：out-------middle------inner out.addEventListener(&apos;click&apos;,function()&#123;alert(&quot;我是最外面的&quot;);&#125;,true); middle.addEventListener(&apos;click&apos;,function()&#123;alert(&quot;我是中间的&quot;);&#125;,true); inner.addEventListener(&apos;click&apos;,function()&#123;alert(&quot;我是最里面的&quot;);&#125;,false);&lt;/script&gt; 结论：1.true的触发顺序总是在false前面2.如果多个均为true 则外层触发先于内层3.如果多个均为false 则内层触发先于外层 转载于：js添加事件和移除事件:addEventListener()与removeEventListener()]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CORS 简单请求+预检请求]]></title>
    <url>%2F2019%2F06%2F04%2FCORS%2F</url>
    <content type="text"><![CDATA[概述 当一个资源从与该资源本身所在的服务器不同的域，协议，端口请求一个资源时，资源会发起一个跨域HTTP请求。 出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求，XMLHttpRequest和Fetch API，只能从加载应用程序的同一个域请求HTTP资源，除非使用CORS头文件 对于浏览器限制这个词，要着重解释一下：不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了 CORS概述跨域资源共享标准新增了一组HTTP首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。 另外，规范要求，对那些可能对服务器数据产生副作用的HTTP请求方法（特别是GET以外的HTTP请求，或者搭配某些MIME类型的POST请求），浏览器必须首先使用OPTIONS方法发起一个预检请求(preflight request),从而获知服务端是否允许该跨域请求 服务器确认允许之后，才发起实际的HTTP请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括Cookies和HTTP认证相关数据）。 简单请求不会触发CORS预检的请求成为简单请求，满足以下所有条件的才会被视为简单请求，基本上我们日常开发只会关注前面两点 使用GET,POST,HEAD其中一种方法 只使用了如下的安全首部字段，不得人为设置其他首部字段 Accept Accept-Language Content-Type仅限以下三种 text/plain multipart/form-data application/x-www-form-urlencoded HTML头部header field字段：DPR,Download,Save-Data,Viewport-Width,Width 请求中的任意XMLHttpRequestUpload对象均没有注册任何事件监听器；XMLHttpRequestUpload对象可以使用XMLHttpRequest.upload属性访问 请求中没有使用ReadableStream对象 预检请求需预检的请求要求必须首先使用OPTIONS方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。“预检请求”的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响 下面的请求会触发预检请求，其实非简单请求之外的就会触发预检，就不用记那么多了 使用了PUT、DELETE、CONNECT、OPTIONS、TRACE、PATCH方法 人为设置了非规定内的其他首部字段，参考上面简单请求的安全字段集合，还要特别注意Content-Type的类型 XMLHttpRequestUpload 对象注册了任何事件监听器 请求中使用了ReadableStream对象 一下是一个发起预检请求的例子发起请求的origin与请求的服务器的host不同，而且根据上面的条件判断，触发了预检 请求附带身份凭证 -&gt; cookie如果发起请求时设置withCredentials标志设置为true,从而向服务器发送cookie,但是如果服务器端的响应中未携带Access-Control-Allow-Credentials:true,浏览器将不会把响应内容返回给请求的发送者 对于附带身份凭证的请求，服务器不能设置Access-Control-Allow-Origin的值为*,必须是某个具体的域名 注意，简单GET请求不会被预检，如果对此类带有身份凭证请求的响应中不包含该字段，这个响应将被忽略掉，并且浏览器也不会将相应内容返回给网页 完整请求流程 转载于：CORS 简单请求+预检请求（彻底理解跨域）]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie,Session,Token]]></title>
    <url>%2F2019%2F06%2F03%2FCookie-Session-Token%2F</url>
    <content type="text"><![CDATA[发展史 1、很久很久以前，Web 基本上就是文档的浏览而已， 既然是浏览，作为服务器， 不需要记录谁在某一段时间里都浏览了什么文档，每次请求都是一个新的HTTP协议， 就是请求加响应， 尤其是我不用记住是谁刚刚发了HTTP请求， 每个请求对我来说都是全新的。这段时间很嗨皮 2、但是随着交互式Web应用的兴起，像在线购物网站，需要登录的网站等等，马上就面临一个问题，那就是要管理会话，必须记住哪些人登录系统， 哪些人往自己的购物车中放商品， 也就是说我必须把每个人区分开，这就是一个不小的挑战，因为HTTP请求是无状态的，所以想出的办法就是给大家发一个会话标识(session id), 说白了就是一个随机的字串，每个人收到的都不一样， 每次大家向我发起HTTP请求的时候，把这个字符串给一并捎过来， 这样我就能区分开谁是谁了 3、这样大家很嗨皮了，可是服务器就不嗨皮了，每个人只需要保存自己的session id，而服务器要保存所有人的session id ！ 如果访问服务器多了， 就得由成千上万，甚至几十万个。 这对服务器说是一个巨大的开销 ， 严重的限制了服务器扩展能力， 比如说我用两个机器组成了一个集群， 小F通过机器A登录了系统， 那session id会保存在机器A上， 假设小F的下一次请求被转发到机器B怎么办？ 机器B可没有小F的 session id啊。 有时候会采用一点小伎俩： session sticky ， 就是让小F的请求一直粘连在机器A上， 但是这也不管用， 要是机器A挂掉了， 还得转到机器B去。 那只好做session 的复制了， 把session id 在两个机器之间搬来搬去， 快累死了。 后来有个叫Memcached的支了招： 把session id 集中存储到一个地方， 所有的机器都来访问这个地方的数据， 这样一来，就不用复制了， 但是增加了单点失败的可能性， 要是那个负责session 的机器挂了， 所有人都得重新登录一遍， 估计得被人骂死。 4 于是有人就一直在思考， 我为什么要保存这可恶的session呢， 只让每个客户端去保存该多好？ 可是如果不保存这些session id , 怎么验证客户端发给我的session id 的确是我生成的呢？ 如果不去验证，我们都不知道他们是不是合法登录的用户， 那些不怀好意的家伙们就可以伪造session id , 为所欲为了。 嗯，对了，关键点就是验证 ！ 比如说， 小F已经登录了系统， 我给他发一个令牌(token)， 里边包含了小F的 user id， 下一次小F 再次通过Http 请求访问我的时候， 把这个token 通过Http header 带过来不就可以了。 不过这和session id没有本质区别啊， 任何人都可以可以伪造， 所以我得想点儿办法， 让别人伪造不了。 那就对数据做一个签名吧， 比如说我用HMAC-SHA256 算法，加上一个只有我才知道的密钥， 对数据做一个签名， 把这个签名和数据一起作为token ， 由于密钥别人不知道， 就无法伪造token了。 这个token 我不保存， 当小F把这个token 给我发过来的时候，我再用同样的HMAC-SHA256 算法和同样的密钥，对数据再计算一次签名， 和token 中的签名做个比较， 如果相同， 我就知道小F已经登录过了，并且可以直接取到小F的user id , 如果不相同， 数据部分肯定被人篡改过， 我就告诉发送者： 对不起，没有认证。 Token 中的数据是明文保存的（虽然我会用Base64做下编码， 但那不是加密）， 还是可以被别人看到的， 所以我不能在其中保存像密码这样的敏感信息。 当然， 如果一个人的token 被别人偷走了， 那我也没办法， 我也会认为小偷就是合法用户， 这其实和一个人的session id 被别人偷走是一样的。 这样一来， 我就不保存session id 了， 我只是生成token , 然后验证token ， 我用我的CPU计算时间获取了我的session 存储空间 ！ 解除了session id这个负担， 可以说是无事一身轻， 我的机器集群现在可以轻松地做水平扩展， 用户访问量增大， 直接加机器就行。 这种无状态的感觉实在是太好了！ 什么是CookieHTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它还会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie使基于无状态的HTTP状态记录稳定的状态信息成为了可能。 Cookie主要用于一下三个方面： 会话状态管理（如用户登录状态，购物车，游戏分数或其他需要记录的信息） 个性化设置（如用户自定义设置，主题等） 浏览器行为跟踪（如跟踪分析用户行为等） 什么是SessionSession代表着服务器和客户端一次会话的过程。Session对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者Session超时失效会话结束。 Cookie和Session有什么不同？ 作用范围不同，Cookie保存在客户端（浏览器），Session保存在服务器端 存取方式的不同，Cookie只能保存ASCII，Session可以存任意数据类型，一般情况下我们可以在Session中保持一些常用变量信息，比如说UserId等。 有效期不同，Cookie可设置为长时间保持，比如我们经常使用的默认登录功能，Session一般失效时间较短，客户端关闭或者Session超时都会失效 隐私策略不同，Cookie存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在Cookie中导致信息被窃取；Session存储在服务端，安全性相对Cookie要好一些。 存储大小不同，单个Cookie保存的数据不能超过4K，Session可存储数据远高于Cookie 为什么需要Cookie和Session，他们有什么关联？说起来为什么需要Cookie，这就需要从浏览器开始说起，我们都知道浏览器是没有状态的（HTTP协议无协议），这意味着浏览器并不知道是张三还是李四在和服务器打交道。这个时候就需要有一个机制来告诉服务器，本次操作用户是否登录，是哪个用户在执行的操作，那这套机制的实现就需要Cookie和Session的配合 那么Cookie和Session是如何配合的呢？用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的Session，请求返回时将此Session的唯一标识信息SessionID返回给浏览器，浏览器接收到服务器返回的SessionID信息后，会将此信息存入到Cookie中，同时Cookie记录此SessionID属于哪个域名。 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在Cookie信息，如果存在自动将Cookie信息也发送给服务端，服务端会从Cookie中获取SessionID，再根据SessionID查找对应的Session信息，如果没有找到说明用户没有登录或者登录失效，如果找到Session证明用户已经登录可执行后面操作。 根据以上流程可知，SessionID是连接Cookie和Session的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。 既然服务端是根据Cookie中的信息判断用户是否登录，那么如果浏览器中禁止了Cookie，如何保障整个机制的正常运转 第一种方案，每次请求中都携带一个SessionID的参数，也可以Post的方式提交，也可以在请求的地址后面拼接xxx?SessionID=12345… 第二种方案，Token机制。Token机制多用于App客户端和服务器交互的模式，也可以用于Web端做用户状态管理。 Token的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token机制和Cookie和Session的使用机制比较类似。 当用户第一次登录后，服务器根据提交的用户信息生成一个Token，响应式将Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次登录验证。 如何考虑分布式Session问题？在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在A服务器登录了，第二次请求跑到服务B就会出现登录失效问题。 分布式Session一般会有以下几种解决方案： Nginx ip_hash策略，服务端使用Nginx代理，每个请求按访问IP的hash分配，这样来自同一IP固定访问一个后台服务器，避免了在服务器A创建Session，第二次分发到服务器B的现象。 Session复制，任何一个服务器上的Session发生改变（增删改），该节点会把这个Session的所有内容序列化，然后广播给所有其他节点。 共享Session，服务端无状态话，将用户的Session等信息使用缓存中间件来统一管理，保障分发到每一个服务器的响应结果都一致。 Token在Web领域基于Token的身份验证随处可见。在大多数使用Web API的互联网公司中，token是多用户下处理认证的最佳方式。以下几点特性会让你在程序中使用基于Token的身份验证 1.无状态、可扩展 2.支持移动设备 3.跨程序调用 4.安全(请求中发送token而不再是发送cookie能够防止CSRF(跨站请求伪造)。即使在客户端使用cookie存储token，cookie也仅仅是一个存储机制而不是用于认证。不将信息存储在Session中，让我们少了对session操作。token是有时效的，一段时间之后用户需要重新验证。我们也不一定需要等到token自动失效，token有撤回的操作，通过token revocataion可以使一个特定的token或是一组有相同认证的token无效。) 基于服务器验证方式暴露的一些问题1.Seesion：每次认证用户发起请求时，服务器需要去创建一个记录来存储信息。当越来越多的用户发请求时，内存的开销也会不断增加。 2.可扩展性：在服务端的内存中使用Seesion存储登录信息，伴随而来的是可扩展性问题。 3.CORS(跨域资源共享)：当我们需要让数据跨多台移动设备上使用时，跨域资源的共享会是一个让人头疼的问题。在使用Ajax抓取另一个域的资源，就可以会出现禁止请求的情况。 4.CSRF(跨站请求伪造)：用户在访问银行网站时，他们很容易受到跨站请求伪造的攻击，并且能够被利用其访问其他的网站。 使用基于 Token 的身份验证方法，（基于Token的身份验证是无状态的，我们不将用户信息存在服务器或Session中。这种概念解决了在服务端存储信息时的许多问题，NoSession意味着你的程序可以根据需要去增减机器，而不用去担心用户是否登录。）在服务端不需要存储用户的登录记录。大概的流程是这样的： 客户端使用用户名跟密码请求登录 服务端收到请求，去验证用户名与密码 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据 基于Token的身份验证：JSON Web Token实施 Token 验证的方法挺多的，还有一些标准方法，比如 JWT，读作：jot ，表示：JSON Web Tokens 。JWT 标准的 Token 有三个部分： header（头部）payload（数据）signature（签名）中间用点分隔开，并且都会使用 Base64 编码，所以真正的 Token 看起来像这样： 12eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ.SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc//header.payload.signature Header每个 JWT token 里面都有一个 header，也就是头部数据。里面包含了使用的算法，这个 JWT 是不是带签名的或者加密的。主要就是说明一下怎么处理这个 JWT token 。 头部里包含的东西可能会根据 JWT 的类型有所变化，比如一个加密的 JWT 里面要包含使用的加密的算法。唯一在头部里面要包含的是 alg 这个属性，如果是加密的 JWT，这个属性的值就是使用的签名或者解密用的算法。如果是未加密的 JWT，这个属性的值要设置成 none。123&#123; &quot;alg&quot;: &quot;HS256&quot;&#125; 意思是这个 JWT 用的算法是 HS256。上面的内容得用 base64url 的形式编码一下，所以就变成这样：1eyJhbGciOiJIUzI1NiJ9 PayloadPayload 里面是 Token 的具体内容，这些内容里面有一些是标准字段，你也可以添加其它需要的内容。下面是标准字段： iss：Issuer，发行者 sub：Subject，主题 aud：Audience，观众 exp：Expiration time，过期时间 nbf：Not before iat：Issued at，发行时间 jti：JWT ID比如下面这个 Payload ，用到了 iss 发行人，还有 exp 过期时间这两个标准字段。另外还有两个自定义的字段，一个是 name ，还有一个是 admin 。 123456&#123; &quot;iss&quot;: &quot;ninghao.net&quot;, &quot;exp&quot;: &quot;1438955445&quot;, &quot;name&quot;: &quot;wanghao&quot;, &quot;admin&quot;: true&#125; 使用 base64url 编码以后就变成了这个样子：1eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ SignatureJWT 的最后一部分是 Signature ，这部分内容有三个部分，先是用 Base64 编码的header.payload，再用加密算法加密一下，加密的时候要放进去一个 Secret，这个相当于是一个密码，这个密码秘密地存储在服务端。不能泄露给用户。然后，使用 Header里面指定的签名算法（默认是 HMACSHA256），按照下面的公式产生签名。1234HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) 算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户 JWT的使用方式客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。 此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。1Authorization: Bearer &lt;token&gt; 另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里 JWT 的几个特点（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。 （2）JWT 不加密的情况下，不能将秘密数据写入 JWT。 （3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。 （4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。 （5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。 （6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。 参考:1234]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端数据操作总结]]></title>
    <url>%2F2019%2F05%2F29%2F%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[src转img 123456789101112function srctoimg(src)&#123; return new Promise((reslove,reject) =&gt; &#123; let img = new Image() img.onload = function()&#123; resolve(img) &#125; img.onerror = function(err)&#123; reject(err) &#125; img.src = src &#125;)&#125; img转canvas12345678function imgtocanvas(img)&#123; let canvas = document.createElement(&quot;canvas&quot;) let ctx = canvas.getContext(&apos;2d&apos;) canvas.width = img.width canvas.height = img.height ctx.drawImage(img,0,0,canvas.width,canvas.height) return canvas&#125; ImageData转canvas12345678function ImageDatetocanvas(imgData)&#123; let canvas = document.createElement(&quot;canvas&quot;) let ctx = canvas.getContext(&apos;2d&apos;) canvas.width = imgData.width canvas.height = imgData.height ctx.putImageData(imgData,canvas.width,canvas.height) return canvas&#125; canvas转ImageData1234function canvastoImageDate(canvas)&#123; let ctx = canvas.getContext(&apos;2d&apos;) return ctx.createImageData(canvas.width,canvas.height)&#125; canvas像素操作123456789function canvaspixel(canvas,deal)&#123; let ctx = canvas.getContext(&apos;2d&apos;) var imgData = ctx.createImageData(canvas.width,canvas.height) for(var i = 0; i &lt; imgData.data.length; i += 4)&#123; deal(r,g,b,a) &#125; ctx.putImageData(imgData,canvas.width,canvas.height) return canvas&#125; canvas转DataURL(base64)1canvas.toDataURL() DataURL(base64)转blob(，二进制大对象，是一个可以存储二进制文件的“容器”。 在计算机中，BLOB常常是数据库中用来存储二进制文件的字段类型。) file转arrayBuffer123456789function filetoblob(file)&#123; return new Promise((resolve,reject) =&gt; &#123; var reader = new FileReader(); reader.readAsArrayBuffer(file); reader.onload = function(e)&#123; resolve(reader.result) &#125; &#125;)&#125; file转blob(二进制大对象，是一个可以存储二进制文件的“容器”。 在计算机中，BLOB常常是数据库中用来存储二进制文件的字段类型。) 转载于]]></content>
  </entry>
  <entry>
    <title><![CDATA[一些常用流程]]></title>
    <url>%2F2019%2F05%2F28%2F%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[创建vue-cli项目 npm install vue-cli -g vue init webpack projectName 把本地项目与github相连 在github新建一个仓库,复制git链接 在本地 git clone 链接 cd 到项目位置 git init git commit -m ‘…’ git remote add origin git@github(git地址) git pull origin master git push origin master]]></content>
  </entry>
  <entry>
    <title><![CDATA[译axios文档]]></title>
    <url>%2F2019%2F05%2F24%2F%E8%AF%91axios%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[axios简介axios是一个基于Promise用于浏览器和nodejs的HTTP客户端，它本身具有以下特征： 从浏览器中创建XMLHttpRequest 从nodejs发出http请求 支持Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转化JSON数据 客户端支持防止CSRF/XSRF 浏览器兼容性 安装使用 npm:1$ npm install axios 使用 bower:1$ bower install axios 使用 yarn:1$ yarn add axios 使用 cdn:1&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; axios例子执行GET请求1234567891011121314151617181920//向具有指定ID的用户发出请求axios.get(&apos;/user?ID=12345&apos;) .then(function(response)&#123; console.log(response);&#125;).catch(function(error)&#123; console.log(error);&#125;);//也可以通过params对象传递参数axios.get(&apos;/user&apos;,&#123; params:&#123; ID:12345 &#125;&#125;).then(function(response)&#123; console.log(reponse);&#125;).catch(function(error)&#123; console.log(error)&#125;) 执行POST请求12345678910axios.post(&apos;/user&apos;,&#123; firstName:&apos;Fred&apos;, lastName:&apos;Flintstone&apos;&#125;).then(function(response)&#123; console.log(response)&#125;).catch(function(error)&#123; console.log(error)&#125;) 执行多个并发请求12345678910function getUserAccount()&#123; return axios.get(&apos;/user/12345&apos;);&#125;function getUserPermissions()&#123; return axios.get(&apos;/user/12345/permissions&apos;);&#125;axios.all([getUserAccount(),getUserPermissions()]).then(axios.spread(function(acct,perms)&#123;//两个请求现已完成&#125;)) axios API可以通过将相关配置传递给axios来进行请求。 axios(config)123456789//发送一个POST请求axios(&#123; method:&apos;post&apos;, url:&apos;/user/12345&apos;, data:&#123; firstName:&apos;Fred&apos;, lastName:&apos;Flintstone&apos; &#125;&#125;); axios(url[,config])12//发送一个GEt请求（GET请求时默认请求模式）axios(&apos;/user/12345&apos;) 请求方法别名为了方便起见，已经为所有支持的请求方法提供了别名 axios.request(config) axios.get(url[,config]) axios.delete(url[,config]) axios.head(url[,/config]) axios.options(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]])注意当使用方法别名时，url,method和data属性不需要在config中被指定。 并发性帮助函数处理并发请求 axios.all(iterable) axios.spread(callback) 创建axios实例您可以通过使用自定义配置创建一个新的axios实例 axios.create([config])12345const instance = axios.create(&#123; baseURL:&apos;https://some-domain.com/api/&apos;, timeout:1000, header:&#123;&apos;X-Custom-Header&apos;:&apos;foobar&apos;&#125;&#125;) 实例方法可用的实例方法如下所示。指定的配置将与实例配置合并。 axios#request(config) axios#get(url[, config]) axios#delete(url[, config]) axios#head(url[, config]) axios#options(url[, config]) axios#post(url[, data[, config]]) axios#put(url[, data[, config]]) axios#patch(url[, data[, config]]) axios#getUri([config]) 请求配置这些是用于发出请求的可用配置选项。只有url是必需的，如果请求方法没有特定，默认为GET方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136&#123; //`url` 是将用于请求的服务器URL url:&apos;/user&apos;, //`method` 是当发送请求时的请求方式 method:&apos;get&apos;, //默认 //`baseURL` 将被添加到&apos;url&apos;前面，除非&apos;url&apos;是绝对的 //可以方便地为axios的实例设置&apos;baseURL&apos;，以便将相对URL传递给该实例的方法 baseURL:&apos;https://some-domain.com/api&apos;, //`transformRequest`允许在请求数据发送到服务器之前对其进行更改 //这只适用于PUT POST和PATCH请求方法 //数组中的最后一个函数必须返回一个字符串或一个Buffer实例,ArrayBuffer,FormData,Stream //您可能修改对象头部 transformRequest:[function(data,headers)&#123; //做任何你想要的数据转换 return data; &#125;], //`transformResponse` 允许在 then/catch 之前对响应数据进行更改 transformResponse: [function(data)&#123; //做任何你想要的数据转换 return data; &#125;], //`headers` 是要发送的自定义headers headers:&#123;&apos;X-Requested-With&apos;: &apos;XMLHttpRequest&apos;&#125;, //`params`是要与请求一起发送的url参数 //必须是纯对象或URLSearchParams对象 params:&#123; ID:12345 &#125;, //`paramsSerialize`是一个可选函数，负责序列化`params` // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: &apos;brackets&apos;&#125;) &#125;, //`data` 是作为请求体发送的数据 //只适用于 PUT POST PATCH请求方法 //当`transformRequest`没有设置时，必须是以下类型之一： //- string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - Browser only: FormData, File, Blob // - Node only: Stream, Buffer data:&#123; firstName:&apos;Fred&apos; &#125;, //`timeout` 指定请求超时之前的毫秒数 //如果请求的时间超过`timeout`,请求将被中断 timeout:1000,//默认为 0（没有timeout) //`withCredentials` 指示是否是跨站点访问控制请求 //要使用证书吗 withCredentials:false //默认 //`adapter` 允许自定义处理请求，这使得测试更容易 //返回一个promise并提供一个有效的响应 （见lib/adapters/README.md） adapter:function(config)&#123; /*...*/ &#125;, //`auth`表示应该使用HTTP基本认证，并提供证书。 //这将设置一个`Authorization&apos;头，覆盖任何现有的`Authorization&apos;自定义头，使用`headers`设置。 auth: &#123; username:&apos;janedoe&apos;, password: &apos;s00pers3cret&apos; &#125;, //`responseType`表示服务器将响应的数据类型 //类型包括：&apos;arraybuffer&apos;, &apos;blob&apos;, &apos;document&apos;, &apos;json&apos;, &apos;text&apos;, &apos;stream&apos; responseType: &apos;json&apos;,//默认 //`responseEncoding`表示用于解码响应的编码 //注意：忽略“stream”或客户端请求的responseType responseEncoding: &apos;utf8&apos;, //默认 //`xsrfCookieName` 是要用作 xsrf 令牌的值的cookie的名称 xsrfCookieName: &apos;XSRF-TOKEN&apos;, // default // `xsrfHeaderName`是携带xsrf令牌值的http头的名称 xsrfHeaderName: &apos;X-XSRF-TOKEN&apos;, // default // `onUploadProgress`允许处理上传的进度事件 onUploadProgress: function (progressEvent) &#123; // 使用本地 progress 事件做任何你想要做的 &#125;, // `onDownloadProgress`允许处理下载的进度事件 onDownloadProgress: function (progressEvent) &#123; // Do whatever you want with the native progress event &#125;, // `maxContentLength`定义允许的http响应内容的最大大小 maxContentLength: 2000, // `validateStatus`定义是否解析或拒绝给定的promise // HTTP响应状态码。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被 // 拒绝。 validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // default &#125;, // `maxRedirects`定义在node.js中要遵循的重定向的最大数量。 // 如果设置为0，则不会遵循重定向。 maxRedirects: 5, // 默认 // `httpAgent`和`httpsAgent`用于定义在node.js中分别执行http和https请求时使用的自定义代理。 // 允许配置类似`keepAlive`的选项， // 默认情况下不启用。 httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // &apos;proxy&apos;定义代理服务器的主机名和端口 // `auth`表示HTTP Basic auth应该用于连接到代理，并提供credentials。 // 这将设置一个`Proxy-Authorization` header，覆盖任何使用`headers`设置的现有的`Proxy-Authorization` 自定义 headers。 proxy: &#123; host: &apos;127.0.0.1&apos;, port: 9000, auth: : &#123; username: &apos;mikeymike&apos;, password: &apos;rapunz3l&apos; &#125; &#125;, // “cancelToken”指定可用于取消请求的取消令牌 // (see Cancellation section below for details) cancelToken: new CancelToken(function (cancel) &#123; &#125;) &#125;&#125; 响应模式请求的响应包含如下信息：12345678910111213141516171819//`data`是服务器提供的响应数据data:&#123;&#125;,//`status`是服务器响应的HTTP状态码status:200,//`statusText`是服务器响应的HTTP状态信息statusText:&apos;OK&apos;,//`headers`服务器响应的所有头的名称都是小写的headers:&#123;&#125;,//`config`是为请求提供给`axios`的配置config:&#123;&#125;,//`request`是生成此响应的请求//它是node.js(重定向)中的最后一个ClientRequest实例而且是浏览器中的一个XMLHttpRequest实例request:&#123;&#125;&#125; 当使用then时，你将收到如下响应：12345678axios.get(&apos;/user/12345&apos;) .then(function (response) &#123; console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config); &#125;); 当使用catch或将rejection回调作为then的第二个参数传递时，响应将通过error对象传递，如处理错误部分所述。 配置默认值您可以指定将应用于每个请求的配置默认值。 全局axios默认值123axios.defaults.baseURL = &apos;https://api.example.com&apos;;axios.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN;axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;; 自定义实例默认值1234567// 当生成实例时设置默认值const instance = axios.create(&#123; baseURL: &apos;https://api.example.com&apos;&#125;);// 在实例创建后改变默认值instance.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN; 配置优先级顺序配置将与优先顺序合并。 顺序是lib / defaults.js中的库默认值，然后是实例的defaults属性，最后是请求的config参数。 后者将优先于前者。 这里有一个例子。123456789101112//使用库提供的配置默认值创建实例//此时，超时配置值为`0`，这是库的默认值var instance = axios.create（）; //覆盖库的超时默认值//现在所有请求将在超时前等待2.5秒instance.defaults.timeout = 2500; //覆盖此请求的超时，因为它知道需要很长时间instance.get（&apos;/ longRequest&apos;，&#123; timeout：5000&#125;）; 拦截器你可以截取请求或响应在被 then 或者 catch 处理之前1234567891011121314151617//添加请求拦截器axios.interceptors.request.use（function（config）&#123; //在发送请求之前做某事 return config; &#125;，function（error）&#123; //请求错误时做些事 return Promise.reject（error）; &#125;）; //添加响应拦截器axios.interceptors.response.use（function（response）&#123; //对响应数据做些事 return response; &#125;，function（error）&#123; //请求错误时做些事 return Promise.reject（error）; &#125;）; 如果你以后可能需要删除拦截器。12var myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor); 你可以将拦截器添加到axios的自定义实例。12var instance = axios.create();instance.interceptors.request.use(function () &#123;/*...*/&#125;); 处理错误1234567891011121314axios.get（&apos;/ user / 12345&apos;） .catch（function（error）&#123; if（error.response）&#123; //请求已发出，但服务器使用状态代码进行响应 //落在2xx的范围之外 console.log（error.response.data）; console.log（error.response.status）; console.log（error.response.headers）; &#125; else &#123; //在设置触发错误的请求时发生了错误 console.log（&apos;Error&apos;，error.message）; &#125;&#125; console.log（error.config）; &#125;）; 您可以使用validateStatus配置选项定义自定义HTTP状态码错误范围。12345axios.get（&apos;/ user / 12345&apos;，&#123; validateStatus：function（status）&#123; return status &lt; 500; //仅当状态代码大于或等于500时拒绝 &#125;&#125;&#125;） 消除您可以使用取消令牌取消请求。 axios cancel token API基于可取消的promise提议，目前处于阶段1。 您可以使用CancelToken.source工厂创建一个取消令牌，如下所示：12345678910111213var CancelToken = axios.CancelToken;var source = CancelToken.source（）;axios.get(&apos;/user/12345&apos;, &#123; cancelToken: source.token&#125;).catch(function(thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log(&apos;Request canceled&apos;, thrown.message); &#125; else &#123; // 处理错误 &#125;&#125;);//取消请求（消息参数是可选的）source.cancel（&apos;操作被用户取消。&apos;）; 您还可以通过将执行器函数传递给CancelToken构造函数来创建取消令牌：123456789101112var CancelToken = axios.CancelToken;var cancel; axios.get（&apos;/ user / 12345&apos;，&#123; cancelToken：new CancelToken（function executor（c）&#123; //一个执行器函数接收一个取消函数作为参数 cancel = c; &#125;）&#125;）; // 取消请求clear(); 注意：您可以使用相同的取消令牌取消几个请求。 使用application / x-www-form-urlencoded格式默认情况下，axios将JavaScript对象序列化为JSON。 要以应用程序/ x-www-form-urlencoded格式发送数据，您可以使用以下选项之一。 浏览器在浏览器中，您可以使用URLSearchParams API，如下所示：1234var params = new URLSearchParams();params.append(&apos;param1&apos;, &apos;value1&apos;);params.append(&apos;param2&apos;, &apos;value2&apos;);axios.post(&apos;/foo&apos;, params); 请注意，所有浏览器都不支持URLSearchParams，但是有一个polyfill可用（确保polyfill全局环境）。 或者，您可以使用qs库对数据进行编码：12var qs = require(&apos;qs&apos;);axios.post(&apos;/foo&apos;, qs.stringify(&#123; &apos;bar&apos;: 123 &#125;); Node.js在node.js中，可以使用querystring模块，如下所示：12var querystring = require(&apos;querystring&apos;);axios.post(&apos;http://something.com/&apos;, querystring.stringify(&#123; foo: &apos;bar&apos; &#125;); 你也可以使用qs库。 Promiseaxios 依赖本机要支持ES6 Promise实现。 如果您的环境不支持ES6 Promises，您可以使用polyfill。 TypeScriptaxios包括TypeScript定义。12import axios from &apos;axios&apos;;axios.get(&apos;/user?ID=12345&apos;); axios在很大程度上受到Angular提供的$http服务的启发。 最终，axios努力提供一个在Angular外使用的独立的$http-like服务。]]></content>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TODOLists]]></title>
    <url>%2F2019%2F05%2F21%2FTODOLists%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[剖析Vue原理--实现双向绑定MVVM]]></title>
    <url>%2F2019%2F05%2F15%2F%E5%89%96%E6%9E%90Vue%E5%8E%9F%E7%90%86-%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9AMVVM%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[收藏的一些网站]]></title>
    <url>%2F2019%2F05%2F15%2F%E5%91%A8%E6%9F%90%E6%94%B6%E8%97%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[简历在线制作：http://www.jiaobu365.com/]]></content>
      <tags>
        <tag>收藏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么call比apply快？]]></title>
    <url>%2F2019%2F05%2F14%2F%E4%B8%BA%E4%BB%80%E4%B9%88call%E6%AF%94apply%E5%BF%AB%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[在看源码的过程中，总会遇到这样的写法：12345678910var triggerEvents = function(events, args) &#123; var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2]; switch (args.length) &#123; case 0: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx); return; case 1: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1); return; case 2: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return; case 3: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return; default: while (++i &lt; l) (ev = events[i]).callback.apply(ev.ctx, args); return; &#125;&#125;; 作者会在参数为3个（包含3）以内时，优先使用 call 方法进行事件的处理。而当参数过多（多余3个）时，才考虑使用 apply 方法。这个就是因为 call 比 apply 快。 为什么call比apply快？Function.prototype.apply(thisArg,argArray) 如果 IsCallable（Function）为false，即 Function 不可以被调用，则抛出一个 TypeError 异常。 如果 argArray 为 null 或未定义，则返回调用 Function 的 [[Call]] 内部方法的结果，提供thisArg 和一个空数组作为参数。 如果 Type（argArray）不是 Object，则抛出 TypeError 异常。 获取 argArray 的长度。调用 argArray 的 [[Get]] 内部方法，找到属性 length。 赋值给 len。 定义 n 为 ToUint32（len）。 初始化 argList 为一个空列表。 初始化 index 为 0。 循环迭代取出 argArray。重复循环 while（index &lt; n） 将下标转换成String类型。初始化 indexName 为 ToString(index). 定义 nextArg 为 使用 indexName 作为参数调用argArray的[[Get]]内部方法的结果。 将 nextArg 添加到 argList 中，作为最后一个元素。 设置 index ＝ index＋1 返回调用 Function 的 [[Call]] 内部方法的结果，提供 thisArg 作为该值，argList 作为参数列表。 Function.prototype.call(thisArg[,arg1[,arg2,…]]) 如果 IsCallable（Function）为 false，即 Function 不可以被调用，则抛出一个 TypeError 异常。 定义 argList 为一个空列表。如果使用超过一个参数调用此方法，则以从arg1开始的从左到右的顺序将每个参数附加为 argList 的最后一个元素 返回调用func的[[Call]]内部方法的结果，提供 thisArg 作为该值，argList 作为参数列表。 我们可以看到，明显 apply 比 call 的步骤多很多。由于 apply 中定义的参数格式（数组），使得被调用之后需要做更多的事，需要将给定的参数格式改变（步骤8）。 同时也有一些对参数的检查（步骤2），在 call 中却是不必要的。另外一个很重要的点：在 apply 中不管有多少个参数，都会执行循环，也就是步骤 6-8，在 call 中也就是对应步骤3 ，是有需要才会被执行。 综上，call 方法比 apply 快的原因是 call 方法的参数格式正是内部方法所需要的格式。 转自:为什么call比apply快？]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法]]></title>
    <url>%2F2019%2F05%2F09%2F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[时间复杂度 通常使用最差的时间复杂度来衡量一个算法的好坏。常数时间O(1)代表这个操作和数据量没有关系，是一个固定时间的操作，比如四则运算。 对于一个算法来说，可能会计算出如下操作次数aN + 1,N代表数据量。那么该算法的时间复杂度就是O(N)。因为我们在计算时间复杂度的时候，数据量通常是非常大的，这时候低阶项和常数项可以忽略不计。 当然可能会出现两个算法都是O(N)的时间复杂度，那么对比两个算法的好坏就要通过对比低阶项和常数项了。 位运算 位运算在算法中很有用，速度可以比四则运算快很多。 在学习位运算之前应该知道十进制如何转二进制，二进制如何转十进制。这里说明下简单的计算方式 十进制33可以看成是32+1，并且33应该是六位二进制的（因为33近似32，而32是2的五次方，所以是六位），那么十进制33就是100001，只要是2的次方，那么就是1否则都为0 那么二进制100001同理，首位是2^5,末位是2^0,相加得出33 左移&lt;&lt;110 &lt;&lt; 1 // -&gt; 20 左移就是将二进制全部往左移动，10在二进制中表示为1010，左移一位后变成10100，转换为十进制也就是20，所以基本可以把左移看成以下公式 a*(2^b)。在此处 a为10 b为1。 右移&gt;&gt;110 &gt;&gt; 1 //-5 右移就是将二进制全部往右移动并去除多余的右边，10在二进制中表示为1010，右移一位后变成101,转换为十进制也就是5，所以基本可以把右移看成int v = a / (2^b)在此处 a为10，b为1右移很好用，比如可以用在二分算法中取出中间值113 &gt;&gt; 1 // -&gt; 6 按位操作按位与每一位都是1，结果才是112348 &amp; 7 // -&gt; 0//1000 &amp; 0111 -&gt; 0000 -&gt; 08 &amp; 8 // -&gt; 8//1000 &amp; 1000 -&gt; 1000 -&gt; 8 按位或其中一位为1，结果就是1128 | 7 // -&gt; 15// 1000 | 0111 -&gt; 1111 -&gt;15 按位异或每一位都不同，结果才为112348 ^ 7 // -&gt; 15// 1000 ^ 0111 -&gt; 1111 -&gt; 158 ^ 8 // -&gt; 0// 1000 ^ 1000 -&gt; 0000 -&gt; 0 从以上代码中可以发现按位异或就是不进位加法 面试题 ：两个数不使用四则运算得出和这道题中可以按位异或，以为按位异或就是不进位加法，8^8 = 0,如果进位了，就是16了，所以我们只需要将两个数进行异或操作，然后进位。那么也就是说两个二进制都是1的位置，左边应该有一个进位1，所以可以得出一下公式 a + b =(a ^ b) + ((a &amp; b) &lt;&lt; 1),然后通过迭代的方式模拟加法。1234567function sum(a,b)&#123; if(a == 0) return b if(b == 0) return a let newA = a ^ b let newB = (a &amp; b) &lt;&lt; 1 return sum(newA,newB)&#125; 排序 以下两个函数是排序中会用到的通用函数，就不一一写了123456789function checkArray(array)&#123; if(!array || array.length &lt;= 2) return&#125;function swap(array,left,right)&#123; let rightValue = array[right] array[right] = array[left] array[left] = rightValue&#125; 冒泡排序冒泡排序的原理如下，从第一个元素开始，把当前元素和下一个索引元素进行比较。如果当前元素大，那么就交换位置，重复操作直到比较到最后一个元素，那么此时最后一个元素就是该数组中最大的数。下一轮重复以上操作，但是此时最后一个元素已经是最大数了，所以不需要再比较最后一个元素，只需要比较到length-1的位置。12345678910function bubble(array)&#123; checkArray(array) for(let i = array.length - 1; i &gt; 0; i--)&#123; for(let j = 0; j &lt; i; j++)&#123; if(array[j] &gt; array[j+1]) swap(array,j,j + 1) &#125; &#125; return array&#125; 该算法的操作次数是一个等差数列 n + (n - 1) + (n - 2) + 1 ，去掉常数项以后得出时间复杂度是 O(n * n) 插入排序插入排序的原理如下。第一个元素默认是已排序元素，取出下一个元素和当前元素比较，如果当前元素大就交换位置。那么此时第一个元素就是当前的最小数，所以下次取出操作从第三个元素开始，向前对比，重复之前的操作。12345678function insertion(array)&#123; checkArray() for (let i = 1; i &lt; array.length; i++)&#123; for(let j = 1 - 1; j &gt;= 0 &amp;&amp; array[j] &gt; array[j + 1]; j--) swap(array, j, j+1) &#125; return array&#125; 该算法的操作次数是一个等差数列 n + (n - 1) + (n - 2) + 1 ，去掉常数项以后得出时间复杂度是 O(n * n) 选择排序选择排序的原理如下。遍历数组，设置最小值的索引为0，如果取出的值比当前最小值小，就替换最小值索引，遍历完成后，将第一个元素和最小值索引上的值交换。如果操作后，第一个元素就是数组中的最小值，下次遍历就可以从索引1开始重复上述操作。1234567891011function selection(array)&#123; checkArray(array) for(let i = 0; i &lt; array.length-1; i++)&#123; let minIndex = i for(let j = i + 1;j &lt; array.length; j++)&#123; minIndex = array[j] &lt; array[minIndex] ? j : minIndex &#125; swap(array, i, minIndex) &#125; return array&#125; 该算法的操作次数是一个等差数列 n + (n - 1) + (n - 2) + 1 ，去掉常数项以后得出时间复杂度是 O(n * n) 归并排序归并排序的原理如下。递归的将数组两两分开直到最多包含两个元素，然后将数组排序合并，最终合并为排序好的数组。假设我有一组数组 [3, 1, 2, 8, 9, 7, 6]，中间数索引是 3，先排序数组 [3, 1, 2, 8] 。在这个左边数组上，继续拆分直到变成数组包含两个元素（如果数组长度是奇数的话，会有一个拆分数组只包含一个元素）。然后排序数组 [3, 1] 和 [2, 8] ，然后再排序数组 [1, 3, 2, 8] ，这样左边数组就排序完成，然后按照以上思路排序右边数组，最后将数组 [1, 2, 3, 8] 和 [6, 7, 9] 排序。123456789101112131415161718192021222324252627function mergeSort(arr)&#123; var len = arr.length; if(len&lt;2)&#123; return arr; &#125; var middle = Math.floor(len/2), left = arr.slice(0,middle), right = arr.slice(middle); return merge(mergeSort(left),mergeSort(right));&#125;function merge(left,right)&#123; var result = []; while(left.length &amp;&amp; right.length)&#123; if(left[0]&lt;=right[0]&#123; result.push(left.shift()); &#125;else&#123; result.push(right.shift()); &#125; &#125; while(left.length)&#123; result.push(left.shift()); &#125; while(right.length)&#123; result.push(right.shift()); &#125; return result;&#125; 该算法的操作次数是可以这样计算：递归了两次，每次数据量是数组的一半，并且最后把整个数组迭代了一次，所以得出表达式 2T(N / 2) + T(N) （T 代表时间，N 代表数据量）。根据该表达式可得出时间复杂度为 O(N * logN) 快排原理： .从数列中挑出一个元素，称为 “基准”（pivot）； .重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； .递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。123456789101112131415161718var quickSort2 = function(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort2(left).concat([pivot], quickSort2(right));&#125;; var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(quickSort2(arr)); 堆排序堆排序利用二叉堆的特性来做，二叉堆通常用数组表示，并且二叉堆是一颗完全二叉树（所有叶节点（最底层的节点）都是从左往右顺序排序，并且其他层的节点都是满的）。二叉堆又分为大根堆与小根堆 大根堆是某个节点的所有子节点的值都比他小 小根堆是某个节点的所有子节点的值都比他大堆排序的原理就是组成一个大根堆或者小根堆。以小根堆为例，某个节点的左边子节点索引是 i2+1,右边是 i2+2，父节点是 (i-1)/2。 首先遍历数组，判断该节点的父节点是否比他小，如果小就交换位置并继续判断，直到他的父节点比他大 重新以上操作1，直到数组首位是最大值 然后将首位与末尾交换位置并将数组长度减一，表示数组末尾已是最大值，不需要再比较大小 对比左右节点哪个大，然后记住大的节点的索引并且和父节点对比大小，如果子节点大就交换位置 重复以上操作 3 - 4 直到整个数组都是大根堆。]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2019%2F05%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[栈 概念 栈式一个线性结构，在计算机中是一个相当常见的数据结构。特点是只能在某一端添加或删除数据，遵循先进后出的原则 实现每种数据结构都可以用很多种方式来实现，其实可以把栈看成是数组的一个子集，所以这里使用数组来实现1234567891011121314151617181920class Stack &#123; constructor() &#123; this.stack = [] &#125; push(item) &#123; this.stack.push(item) &#125; pop() &#123; this.stack.pop() &#125; peek() &#123; return this.stack[this.getCount() - 1] &#125; getCount() &#123; return this.stack.length &#125; isEmpty() &#123; return this.getCount() === 0 &#125;&#125; 应用匹配括号1234567891011121314151617181920212223var isValid = function(s)&#123; let map = &#123; &apos;(&apos;: -1, &apos;)&apos;: 1, &apos;[&apos;: -2, &apos;]&apos;: 2, &apos;&#123;&apos;: -3, &apos;&#125;&apos;: 3 &#125; let stack = [] for(let i = 0; i &lt; s.length; i++)&#123; if(map[s[i]] &lt; 0)&#123; stack.push(s[i]) &#125;else&#123; let last = stack.pop() if(map[last] + map[s[i]] != 0) return false &#125; &#125; if(stack.length &gt; 0) return false return true&#125; 队列 概念队列一个线性结构，特点是在某一端添加数据，在另一端删除数据，遵循先进先出的原则。 实现这里会讲解两种实现队列的方法，分别是单链队列和循环队列。 单链队列1234567891011121314151617181920class Queue &#123; constructor() &#123; this.queue = [] &#125; enQueue(item) &#123; this.queue.push(item) &#125; deQueue() &#123; return this.queue.shift() &#125; getHeader() &#123; return this.queue[0] &#125; getLength() &#123; return this.queue.length &#125; isEmpty() &#123; return this.getLength() === 0 &#125;&#125; 因为单链队列在出队操作的时候需要O(n)的时间复杂度，所以引入了循环队列。循环队列的出队操作平均是O(1)的时间复杂度。 循环队列`class sqQueue { constructor(length){ this.queue = new Array(length + 1) //队头 this.first = 0 //队尾 this.last = 0 //当前队列大小 this.size = 0 } enQueue(item) { //判断队尾+1是否为队头 //如果是就代表需要扩容数组 // % this.queue.length是为了防止数组越界 if(this.first === (this.last + 1) % this.queue.length) { this.resize(this.getLength() *2 + 1) } thisqueue[this.last] = item this.size++ this.last = (this.last + 1) % this.queue.length } deQueue() { if(this.isEmpty()){ throw Error(‘Queue is empty’) } let r = this.queue[this.first] this.queue[this.first] = null //菜鸡看不懂写不下去辽 }}]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写代码]]></title>
    <url>%2F2019%2F05%2F09%2F%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[实现new操作符 new操作符做了什么？ 它创建了一个全新的对象。 它会被执行[[Prototype]]（也就是proto）链接。 它使this指向新创建的对象。 通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。 如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用。 实现：12345678function myNew(func)&#123; let res = &#123;&#125; res.__proto__ = func.prototype let ret = func.apply(res,Array.prototype.slice.call(arguments,1)); return ret instanceof Object ? ret : res &#125;slice(start,end) ==&gt; 返回一个从[start（从0开始） ,end)的新数组 实现一个instanceofinstanceof的原理？instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。 实现：1234567891011function myInstanceof(left, right) &#123; let prototype = right.prototype left = left.__proto__ while (true) &#123; if (left === null || left === undefined) return false if (prototype === left) return true left = left.__proto__ &#125;&#125; 分析： 首先获取类型的原型 然后获得对象的原型 然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null 实现一个call &amp; applycall123456789101112实现：Function.prototype.myCall = function(context)&#123; if(typeof this !== &apos;function&apos;)&#123; throw new TypeError(&apos;Error&quot;) &#125;context = context || windowcontext.fn = thisconst args = [...arguments].slice(1)const result = context.fn(...args)delete context.fnreturn result&#125; 以下是对实现的分析： 首先 context 为可选参数，如果不传的话默认上下文为 window接下来给 context 创建一个 fn 属性，并将值设置为需要调用的函数因为 call 可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来然后调用函数并将对象上的函数删除 apply12345678910111213141516Function.prototype.myApply = function(context) &#123;if (typeof this !== &apos;function&apos;) &#123;throw new TypeError(&apos;Error&apos;)&#125;context = context || windowcontext.fn = thislet result// 处理参数和 call 有区别if (arguments[1]) &#123;result = context.fn(...arguments[1])&#125; else &#123;result = context.fn()&#125;delete context.fnreturn result&#125; 实现一个bind123456789101112131415Function.prototype.myBind = function (context) &#123;if (typeof this !== &apos;function&apos;) &#123;throw new TypeError(&apos;Error&apos;)&#125;const _this = thisconst args = [...arguments].slice(1)// 返回一个函数return function F() &#123;// 因为返回了一个函数，我们可以 new F()，所以需要判断if (this instanceof F) &#123;return new _this(...args, ...arguments)&#125;return _this.apply(context, args.concat(...arguments))&#125;&#125; 以下是对实现的分析： 前几步和之前的实现差不多，就不赘述了bind 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 new 的方式，我们先来说直接调用的方式对于直接调用来说，这里选择了 apply 的方式实现，但是对于参数需要注意以下情况：因为 bind 可以实现类似这样的代码 f.bind(obj, 1)(2)，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 args.concat(…arguments)最后来说通过 new 的方式，在之前的章节中我们学习过如何判断 this，对于 new 的情况来说，不会被任何方式改变 this，所以对于这种情况我们需要忽略传入的 this 实现一个简易版的promise12345678910111213const PENDING = &apos;pending&apos;const RESOLVED = &apos;resolved&apos;const REJECTED = &apos;rejected&apos;function MyPromise(fn) &#123; const that = this that.state = PENDING that.value = null that.resolvedCallbacks = [] that.rejectedCallbacks = [] // 待完善 resolve 和 reject 函数 // 待完善执行 fn 函数&#125; 首先我们创建了三个常量用于表示状态，对于经常使用的一些值都应该通过常量来管理，便于开发及后期维护 在函数体内部首先创建了常量 that，因为代码可能会异步执行，用于获取正确的 this 对象 一开始 Promise 的状态应该是 pendingvalue 变量用于保存 resolve 或者 reject 中传入的值 resolvedCallbacks 和 rejectedCallbacks 用于保存 then 中的回调，因为当执行完 Promise 时状态可能还是等待中，这时候应该把 then 中的回调保存起来用于状态改变时使用 接下来我们来完善 resolve 和 reject 函数，添加在 MyPromise 函数体内部123456789101112131415function resolve(value) &#123; if (that.state === PENDING) &#123; that.state = RESOLVED that.value = value that.resolvedCallbacks.map(cb =&gt; cb(that.value)) &#125;&#125;function reject(value) &#123; if (that.state === PENDING) &#123; that.state = REJECTED that.value = value that.rejectedCallbacks.map(cb =&gt; cb(that.value)) &#125;&#125; 这两个函数代码类似，就一起解析了 首先两个函数都得判断当前状态是否为等待中，因为规范规定只有等待态才可以改变状态 将当前状态更改为对应状态，并且将传入的值赋值给 value 遍历回调数组并执行 完成以上两个函数以后，我们就该实现如何执行 Promise 中传入的函数了12345try &#123; fn(resolve, reject)&#125; catch (e) &#123; reject(e)&#125; 实现很简单，执行传入的参数并且将之前两个函数当做参数传进去 要注意的是，可能执行函数过程中会遇到错误，需要捕获错误并且执行 reject 函数 最后我们来实现较为复杂的 then 函数1234567891011121314151617181920MyPromise.prototype.then = function(onFulfilled, onRejected) &#123; const that = this onFulfilled = typeof onFulfilled === &apos;function&apos; ? onFulfilled : v =&gt; v onRejected = typeof onRejected === &apos;function&apos; ? onRejected : r =&gt; &#123; throw r &#125; if (that.state === PENDING) &#123; that.resolvedCallbacks.push(onFulfilled) that.rejectedCallbacks.push(onRejected) &#125; if (that.state === RESOLVED) &#123; onFulfilled(that.value) &#125; if (that.state === REJECTED) &#123; onRejected(that.value) &#125;&#125; 首先判断两个参数是否为函数类型，因为这两个参数是可选参数 当参数不是函数类型时，需要创建一个函数赋值给对应的参数，同时也实现了透传，比如如下代码 123// 该代码目前在简单版中会报错// 只是作为一个透传的例子Promise.resolve(4).then().then((value) =&gt; console.log(value)) 接下来就是一系列判断状态的逻辑，当状态不是等待态时，就去执行相对应的函数。如果状态是等待态的话，就往回调函数中 push 函数，比如如下代码就会进入等待态的逻辑 1234567new MyPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1) &#125;, 0)&#125;).then(value =&gt; &#123; console.log(value)&#125;) 实现防抖 &amp; 节流 实现深拷贝 继承原型链继承123456789101112function Parent()&#123; this.name = &quot;Dad&quot;&#125;Parent.prototype.getName = function()&#123; console.log(this.name);&#125;function Child()&#123;&#125;## Child.prototype = new Parent();var child1 = new Child();console.log(child.getName()) 问题：1.引用类型的属性被所有实例共享，如果在实例1中修改了属性的值，实例2也会被修改2.在创建Child的实例时，不能向Parent传参 借用构造函数继承1234567891011function Parent()&#123; this.name = [&apos;kevin&apos;,&apos;daisy&apos;];&#125;function Child()&#123; ## Parent.call(this)&#125;## var child1 = new Child();child1.name.push(&apos;yayu&apos;);console.log(child1.names);//[&apos;kevin&apos;,&apos;daisy&apos;,&apos;yayu&apos;]var child2 = new Child();console.log(child2.names);//[&apos;kevin&apos;,&apos;daisy&apos;] 缺点：方法都在构造函数中定义，每次创建实例都会创建一遍方法 组合继承|经典继承(最常用)123456789101112131415161718192021function Parent(name)&#123; this.name = name; this.colors = [&apos;red&apos;,&apos;blue&apos;,&apos;green&apos;];&#125;Parent.prototype.getName = function()&#123; console.log(this.name)&#125;function Child(name,age)&#123; ## Parent.call(this,name) this.age = age;&#125;## Child.prototype = new Parent();var child1 = new Child(&apos;kevin&apos;,&apos;18&apos;)child1.colors.push(&apos;black&apos;);console.log(child1.name);//kevinconsole.log(child1.age);//18console.log(child1.colors);//[&apos;red&apos;,&apos;blue&apos;,&apos;green&apos;,&apos;black&apos;]var child2 = new Child(&apos;daisy&apos;,&apos;20&apos;);console.log(child2.name)//daisyconsole.log(child2.age)//20console.log(child2.colors)//[&apos;red&apos;,&apos;blue&apos;,&apos;green&apos;] 缺点是会调用两次构造函数1.设置子类型实例的原型的时候 Child.prototype = new Parent();2.一次是在创建子类型实例的时候 var child1 = new Child(‘kevin’,’18’); 原型式继承123456789101112131415function createObj(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;var person = &#123; name:&apos;kevin&apos;, friends:[&apos;daisy&apos;,&apos;kelly&apos;]&#125;var person1 = createObj(person);var person2 = createObj(person);person1.name = &apos;person&apos;;console.log(person2.name); // kevinperson1.firends.push(&apos;taylor&apos;);console.log(person2.friends); // [&quot;daisy&quot;, &quot;kelly&quot;, &quot;taylor&quot;] 缺点：包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样 寄生组合式继承1234567891011121314151617function Parent(name)&#123; this.name = name; this.color = [&apos;red&apos;,&apos;blue&apos;,&apos;green&apos;];&#125;Parent.prototype.getName = function()&#123; console.log(this.name);&#125;function Child(name,age)&#123; Parent.call(this,name); this.age = age;&#125;//关键的三步var F = function()&#123;&#125;;F.prototype = Parent.prototype;Child.prototype = new F();var child1 = new Child(&apos;kevin&apos;,&apos;18&apos;);console.log(child1); class继承1234567891011121314151617class Parent&#123; constructor(value)&#123; this.val = value &#125; getValue()&#123; console.log(this.val) &#125;&#125;class Child extend Parent&#123; constructor(value)&#123; super(value) this.val = value &#125;&#125;let child = new Child(1)child.getValue()//1child instanceof Parent //true 说明：class 实现继承的核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super，因为这段代码可以看成 Parent.call(this, value)。 Promise-all1234567891011121314151617Promise.all = function(promises)&#123; return new Promise((resolve,reject) =&gt; &#123; let results = []; let count = 0; for(let i = 0, len = promises.length; i &lt; len; i++)&#123; promises[i].then((res) =&gt; &#123; results[i] = res; count++; if(count === len)&#123; resolve(results); &#125; &#125;,(err) =&gt; &#123; return reject(err); &#125;); &#125; &#125;)&#125; Promise-race1234567Promise.race = function(promises)&#123; return new Promise((resolve,reject) =&gt; &#123; for(let i = 0; i &lt; promises.length; i++)&#123; promises[i].then(resolve,reject); &#125; &#125;)&#125;]]></content>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件通信]]></title>
    <url>%2F2019%2F04%2F17%2Fvue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[组件 组件是可以复用的Vue实例 在Vue中，根据注册方式的不同，可以分为： 局部组件（局部注册） 全局组件（全局注册） 顾名思义，全局注册的组件，可以用在 Vue 实例的任意模板中。但是带来的隐患是，在 webpack 模块化构建时，即便你没有在项目中使用这个组件，依然会打包到最终的项目代码中。而局部组件，则需要在使用到的实例中注册该组件。1234567891011121314151617181920212223// 全局注册// install.jsimport Icon from &apos;./Icon.vue&apos;;const install = &#123; install:function(Vue)&#123; Vue.component(&apos;VIcon&apos;, Icon); &#125;&#125;;export default install;// main.jsimport install from &apos;./install.js&apos;; // 引入全局插件Vue.use(install); // 注册// 局部注册import VIcon from &apos;./Icon.vue&apos;;export default&#123; components: &#123; VIcon &#125;&#125;// 使用&lt;v-icon&gt; &lt;/v-icon&gt; 根据应用场景的不同，又可以分为： 页面组件：我们使用 Vue 时，每个路由代表的页面，都可以称之为组件。 基础组件：就像上面栗子中的 Icon 组件，就是一个典型的基础组件。基本上不掺杂业务逻辑，在项目中可能被大量使用，易于移植。类似的基础组件还有 Button、Input 等，常见于各类 UI 组件库。 业务组件：业务组件和项目具体的业务逻辑有大量耦合，一般抽离于当前项目。 以上就是组件的简单介绍，那我们到底为什么要推崇组件化？组件化有什么好处？复用？我个人认为组件化最大的好处，便是解耦，易于项目管理。所以在大型项目管理中，组件化是非常有必要的。当然，这并不是今天学习的重点，以后有机会再聊。正因为在 Vue 中处处都是组件，而我们也偏向于组件化、模块化。那我们在一堆组件中，便需要解决一个问题 — 组件间通信。下面，我们就进入今天的主题，Vue 的组件间通信。 组件间通信 PropsVue 中，最基本的通信方式就是 Props，它是父子组件通信中父组件传值给子组件的一种方式。它允许以数组形式接收，但是更推荐你开启类型检查的形式1234567891011121314151617181920212223242526//communication.vue&lt;communication-sub v-bind=&quot;dataProps&quot;&gt;&lt;/communication-sub&gt;//v-bind=&quot;dataProps&quot;等同于:title=&quot;title&quot;，适用于多个参数一起传递...data()&#123; return &#123; dataProps:&#123; title:&apos;我是父组件的值&apos; &#125; &#125;&#125;//communication-sub.vue&lt;div class=&quot;communication-sub&quot;&gt; &#123;&#123;title&#125;&#125;&lt;/div&gt;...props:[&apos;title&apos;]//更推荐开启类型检查props:&#123; title:&#123; type:String, required:true, default:&apos;&apos;//允许指定默认值，引用类型需要函数返回 &#125;&#125;... 我们都知道，Props 是单向数据流，这是 Vue 为了避免子组件意外改变父组件的状态，从而导致数据流向难以理解而做出的限制。所以 Vue 推荐需要改动的时候，通过改变父组件的值从而触发 Props 的响应。或者，我们可以在接收非引用类型的值时，使用子组件自身的 data 做一次接收。123456props: [&apos;title&apos;],data: function () &#123; return &#123; text: this.title &#125;;&#125; 为什么是非引用类型呢，因为在 JavaScript 中，引用类型的赋值，实际是内存地址的传递。所以上面栗子中的简单赋值，显然会指向同一个内存地址，所以如果是数组或是对象，你可能需要一次深拷贝。1let obj = JSON.parse(JSON.stringify(obj)); 上面这个操作有一些缺陷，不能序列化函数、undefined、循环引用等.事实上，在 Props 是引用类型时，单独修改对象、数组的某个属性或下标，Vue 并不会抛出错误。当然，前提是你要非常清楚自己在做什么，并写好注释，防止你的小伙伴们疑惑。有的同学可能知道，在组件上绑定的属性，如果没有在组件内部用 Props 声明，会默认绑定到组件的根元素上去。还是之前的栗子：1&lt;communication-sub v-bind=&quot;dataProps&quot; class=&quot;one&quot; type=&quot;div&quot;&gt;&lt;/communication-sub&gt; 这是 Vue 默认处理的，而且，除了 class 和 style 采用合并策略，其它特性（如上栗 type）会替换掉原来根元素上的属性值。当然，我们也可以显示的在组件内部关闭掉这个特性：123...inheritAttrs: false,props: [&apos;title&apos;] 利用 inheritAttrs，我们还可以方便的把组件绑定的其它特性，转移到我们指定的元素上。这就需要用到下一个我们要讲的 $attrs 了。 attrs,listeners我们在使用组件库的时候经常会这么写：1&lt;el-input v-model=&quot;input&quot; placeholder=&quot;请输入内容&quot;&gt;&lt;/el-input&gt; 实际渲染后：可以看到我们指定的的 placeholder 是渲染在 input 上的，但是 input 并不是根元素。难道都用 Props 声明后，再赋值给 input？这种情况就可以用到 $attrs 了，改造一下我们之前那个栗子。123456789101112131415161718192021222324252627282930313233// communication.vue&lt;template&gt; &lt;div class=&quot;communication&quot;&gt; &lt;communication-sub v-bind=&quot;dataProps&quot; class=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;请输入内容&quot;&gt; &lt;/communication-sub&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import communicationSub from &apos;./communication-sub.vue&apos;;export default&#123; name: &apos;communication&apos;, data() &#123; return &#123; dataProps: &#123; title: &apos;我是 communication 的值&apos;, &#125; &#125; &#125;, components: &#123; communicationSub &#125;&#125;&lt;/script&gt;// communication-sub.vue···&lt;div class=&quot;communication-sub&quot;&gt; &lt;input v-bind=&quot;$attrs&quot; v-model=&quot;title&quot;&gt;&lt;/input&gt;&lt;/div&gt;··· export default &#123; inheritAttrs: false&#125; 可以看到，type 已经转移到了子元素 input 标签上，但是 class 没有。这是因为 inheritAttrs: false选项不会影响 style 和 class 的绑定。可以看出 $attrs则是将没有被组件内部 Props 声明的传值（也叫非 Props 特性）收集起来的一个对象，再通过 v-bind 将其绑定在指定元素上。这也是 Element 等组件库采用的策略。这里需要注意一点，通过 $attrs 指定给元素的属性，不会与该元素原有属性发生合并或替换，而是以原有属性为准。举个例子，假如我将上述 input 的 type 默认设置为 password。1&lt;input v-bind=&quot;$attrs&quot; v-model=&quot;title&quot; type=&quot;password&quot;&gt;&lt;/input&gt; 则不会采用 $attrs 中的 type: ‘text’，将以 password 为准，所以如果需要默认值的属性，建议不要用这种方式。 $listeners同$attrs类似，可以看作是一个包含了组件上所有事件监听器(包括自定义事件，不包括.native修饰的事件)的对象。它也支持上述的写法，适用于将事件安放于组件内指定元素上。123456789101112131415// communication.vue&lt;communication-sub v-bind=&quot;dataProps&quot;class=&quot;input&quot;type=&quot;text&quot;placeholder=&quot;请输入内容&quot;@focus=&quot;onFocus&quot; &gt;&lt;/communication-sub&gt;···methods: &#123; onFocus() &#123; console.log(&apos;onFocus&apos;); &#125;&#125;// communication-sub.vue&lt;input v-bind=&quot;$attrs&quot; v-model=&quot;title&quot; v-on=&quot;$listeners&quot;&gt;&lt;/input&gt; 给之前的栗子绑定一个聚焦事件，在子组件中通过 $listeners 绑定给 input，则会在 input 聚焦时触发。那么除了用在这种给组件内指定元素绑定特性和事件的情况，还有哪些场景可以用到呢？官方说明：在创建更高层次的组件时非常有用。比如在祖孙组件中传递数据，在孙子组件中触发事件后要在祖辈中做相应更新。我们继续之前的栗子：在孙辈组件触发点击事件，然后在祖辈中修改相应的 data。123456789101112131415161718192021222324252627// communication.vue&lt;communication-sub v-bind=&quot;dataProps&quot; @click=&quot;onCommunicationClick&quot;&gt;&lt;/communication-sub&gt;···methods: &#123; onCommunicationClick() &#123; this.dataProps.title = &apos;我是点击之后的值&apos;; &#125;&#125;;// communication-sub.vue&lt;communication-min-sub v-on=&quot;$listeners&quot;&gt;&lt;/communication-min-sub&gt; // 子组件中将事件透传到孙辈// communication-min-sub.vue&lt;template&gt; &lt;div class=&quot;communication-min-sub&quot;&gt; &lt;p&gt;我是 communication-min-sub&lt;/p&gt; &lt;button v-on=&quot;$listeners&quot;&gt;click&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123; name: &apos;communication-min-sub&apos;, inheritAttrs: false&#125;&lt;/script&gt; 这样就能很方便的在多级组件的子级组件中，快速访问到父组件的数据和方法。正如在刚才的例子中，button 点击时，是直接调用的 communication.vue 中定义的方法。 依赖注入provide.inject上面的方法，在大多数多级组件嵌套的场景很有用，但有时我们遇到的并不一定是有父子关系的组件。比如基础组件中的 Select 下拉选择器。12345678&lt;el-select v-model=&quot;value&quot; placeholder=&quot;请选择&quot;&gt; &lt;el-option v-for=&quot;item in options&quot; :key=&quot;item.value&quot; :label=&quot;item.label&quot; :value=&quot;item.value&quot;&gt; &lt;/el-option&gt;&lt;/el-select&gt; 相信大家都使用过上栗或者类似于上栗的基础组件，它们借助 vue 插槽 实现。所以这个时候，el-select 和 el-option 之间的数据通信，我们之前的 $attrs、$listeners就没有用武之地了。有同学可能不太理解上面的代码为什么要通信，我简单介绍一下 Element 的处理方式： 我们可以简单的认为（Element 源码比这个要稍复杂，为了方便理解，简化一下，如有需要，可直接前往源码阅读），在 el-select 中有一个 input 元素，el-option 中是一列渲染好的 li。根据需求，我们在选中某个 li 的时候，要通知 input 展示相应的数据。而且我们在实际使用的时候，一般还伴随 el-form、el-form-item等组件，所以迫切需要一种方式: 可以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。 有同学可能会想到，这种多级的可以用 Vuex、EventBus等方式，当然可以。只不过我们现在的前提是基础组件，一般第三方组件库是不会增加一些额外的依赖的。事实上 Vue 本身并不推荐直接在业务中使用 provide、inject，一般在组件、插件库用到的比较多。但是在项目比较小、业务逻辑比较简单的时候，我们完全不必特意引入 Vuex。只要使用得当，provide、inject 确实不失为一种好办法。说了这么多，我们来看一下具体用法，我们将之前的栗子，改为用 provide、inject 来实现。123456789101112131415161718192021222324252627282930313233343536// communication.vue&lt;communication-sub v-bind=&quot;dataProps&quot; &gt;&lt;/communication-sub&gt;// @click=&quot;onCommunicationClick&quot; 移除之前绑定的时间···// 在 provide 添加子代需要接收的方法 onCommunicationClick，// 也可以直接指定为 this，子代便能访问父代所有的数据和方法。provide: function () &#123; return &#123; onCommunicationClick: this.onCommunicationClick &#125;&#125;,methods: &#123; onCommunicationClick() &#123; this.dataProps.title = &apos;我是点击之后的值&apos;; &#125;&#125;;// communication-sub.vue&lt;communication-min-sub&gt;&lt;/communication-min-sub&gt;// 移除之前的 v-on=&quot;$listeners&quot;，因为在这个组件中不需要用到父组件的方法，所以不用做其它处理// communication-min-sub.vue&lt;template&gt; &lt;div class=&quot;communication-min-sub&quot;&gt; ··· &lt;button @click=&quot;onCommunicationClick&quot;&gt;click&lt;/button&gt; // 移除 v-on=&quot;$listeners&quot;，然后绑定 inject 接收到的方法 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123; name: &apos;communication-min-sub&apos;, inject: [&apos;onCommunicationClick&apos;] // inject 接收父组件的方法&#125;&lt;/script&gt; 这种写法和之前的 $listeners 得到的效果是一样的.思考：有些同学可能会想到，如果我在根实例，app.vue 中如此设置：123456789101112131415&lt;script&gt; export default &#123; provide () &#123; return &#123; app: this // 设置app为this &#125; &#125;, data () &#123; return &#123; userInfo: null, otherState: null &#125; &#125; &#125;&lt;/script&gt; 那这样把所有的状态管理都放在 app.data 中，所有的子代中不就可以共享了吗？是不是就不需要 Vuex 了呢？实际上，Vue 本身就提供了一个方法来访问根实例 $root，所以即使没有 provide 也是可以做到的。那为什么不这么用呢？还是前面提到的原因，不利于追踪维护，也失去了所谓状态管理的意义。不过，如果你的项目足够小的话，依然可以这么使用。 ref,parent,children我们前面一直说的都是子组件如何触达父组件，那么父组件能不能访问到子组件呢？当然是可以的。 ref简单来说就是获取元素的 Dom 对象和子组件实例。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例。获取 Dom 元素就是为了进行一些 Dom 操作，需要注意的一点就是，要在 Dom 加载完成后使用，否则可能获取不到。比如我要将之前 input 的字体颜色改成红色：12345678&lt;input type=&quot;text&quot; v-model=&quot;dataProps.title&quot; ref=&quot;input&quot;&gt;...mounted() &#123; this.$nextTick(_ =&gt; &#123; // 确保 Dom 更新完成 this.$refs[&apos;input&apos;].style.color = &apos;red&apos;; &#125;);&#125;// 这里只是举一个栗子，实际项目中的需求，最好通过 class 的方式，尽量减少 Dom 操作。 那什么情况下需要获取组件实例呢？比如父元素的某个状态改变，需要子组件进行 http 请求更新数据。通常情况下，我们会选择通过 Props 将状态传递给子组件，然后子组件进行 Watch 监测，如果有变更，则进行相应操作。这个时候，我们便可以选择使用 ref。1234567891011&lt;child ref=&quot;child&quot;&gt;&lt;/child&gt;···&lt;script&gt; export default &#123; methods () &#123; onStateChange() &#123; // 变更状态后直接调用子组件方法进行更新 this.$refs[&apos;child&apos;].updateData(); &#125; &#125; &#125;&lt;/script&gt; $children,$parent无独有偶，$children 同样可以完成上面的任务。$children 和 $parent，顾名思义，一个会找到当前组件的子组件，一个会找到当前组件的父组件。如果有多个子组件，需要依赖组件实例的 name 属性。改写一下上面的方法：123456789&lt;script&gt; export default &#123; methods () &#123; onStateChange() &#123; // 子组件返回的是一个数组，多个子组件用 $options.name 区分。 this.$children[0].updateData(); &#125; &#125; &#125;&lt;/script&gt; $parent 和 $children 用法一样，不过 $parent 返回的父组件实例，不是数组，因为父组件肯定只有一个。ref、parent、children 它们几个的一个缺点就是无法处理跨级组件和兄弟组件，后续我们会介绍 dispatch 和 broadcast 方法，实现跨级通信。 emit,on,off$emit，想必大家都非常熟悉，我们通常用作父子组件间通信，我们也叫它自定义事件。$emit 和 $on都是组件自身的方法，$on 可以监听 $emit 派发的事件，$off 则用来取消事件监听。这也是我们下一个要讲的通信方式 EventBus 所依赖的原理。12345678910111213141516171819202122232425262728293031// 父组件&lt;template&gt; &lt;button-component @clickButton=&quot;clickButton&quot;&gt;&lt;/button-component&gt; // 在父组件利用 v-on 监听&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; clickButton () &#123; ··· &#125; &#125;&#125;&lt;/script&gt;// 子组件&lt;template&gt; &lt;button @click=&quot;handleClick&quot;&gt;&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; handleClick () &#123; // 触发 $emit this.$emit(&apos;clickButton&apos;); &#125; &#125;, mounted() &#123; this.$on(&apos;clickButton&apos;, (...arr) =&gt; &#123; // 也可以自己监听 $emit，虽然没什么用··· console.log(...arr); &#125;) &#125;&#125;&lt;/script&gt; EventBus$emit的痛点依然是支持跨级和兄弟组件，Vue 官方推荐我们使用一个新的 Vue 实例来做一个全局的事件通信（或者叫中央事件总线···），也就是我们要讲的 EventBus。了解过的同学都知道，正常的 bus，我们一般会挂载到 Vue 的 prototype 上，方便全局调用。12// main.jsVue.prototype.$bus = new Vue(); 依旧改写之前的栗子：1234567891011121314151617181920212223242526272829&lt;!--communication.vue--&gt;&lt;communication-sub v-bind=&quot;dataProps&quot; &gt;&lt;/communication-sub&gt;···beforeDestroy() &#123; &lt;!-- 实例销毁时，需要卸载监听事件 --&gt; this.$bus.$off(&apos;busClick&apos;);&#125;,created() &#123; &lt;!-- 监听子组件触发的 Bus 事件--&gt; this.$bus.$on(&apos;busClick&apos;, (data) =&gt; &#123; this.dataProps.title = data; &#125;);&#125;&lt;!--communication-min-sub.vue--&gt;&lt;template&gt; &lt;div class=&quot;communication-min-sub&quot;&gt; &lt;button @click=&quot;busClick&quot;&gt;click bus&lt;/button&gt; &lt;!--子组件触发点击事件--&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123; methods: &#123; busClick() &#123; this.$bus.$emit(&apos;busClick&apos;, &apos;bus 触发了&apos;); &#125; &#125;&#125;&lt;/script&gt; 这是一个基础的 EventBus 的实现。现在我们设想一下，类似于 userInfo 这样的信息，在很多页面都需要用到，那我们需要在许多页面都做 $on 监听的操作。那能否将这些操作整合到一起呢？我们一起来看：1234567891011121314151617181920212223242526 // 新建一个 eventBus.jsimport Vue from &apos;vue&apos;;const bus = new Vue(&#123; data () &#123; return &#123; userInfo: &#123;&#125; &#125; &#125;, created () &#123; this.$on(&apos;getUserInfo&apos;, val =&gt; &#123; this.userInfo = val; &#125;) &#125;&#125;);export default bus;// main.jsimport bus from &apos;./eventBus&apos;;Vue.prototype.$bus = bus;// app.vuemethods: &#123; getUserInfo() &#123; ajax.post(***).then(data =&gt; &#123; this.$bus.$emit(&apos;getUserInfo&apos;, data); // 通知 EventBus 更新 userInfo &#125;) &#125;&#125; 这样在其他页面用到 userInfo 的时候，只需要 this.$bus.userInfo 就可以了。注意刚刚其实没有用 off 卸载掉监听，因为其实 userInfo 这种全局信息，并没有一个准确的说要销毁的时机，浏览器关闭的时候，也用不着我们处理了。但是，如果只是某个页面组件用到的，建议还是用最开始的方法，在页面销毁的时候卸载掉。 派发与广播:dispath与broadcast在 Vue 1.x 的实现中，有 $dispatch 和 $broadcast 方法，但是在 2.x 被废弃了。$dispatch 的主要作用是向上级组件派发事件，$broadcast 则是向下级广播。它们的优点是都支持跨级，再看一下官方废弃这两个方法的理由： 因为基于组件树结构的事件流方式实在是让人难以理解，并且在组件结构扩展的过程中会变得越来越脆弱。并且 $dispatch 和 $broadcast 也没有解决兄弟组件间的通信问题。 可以看到，主要原因是在组件结构扩展后不易理解，以及没有解决兄弟组件通信的问题。但是对于组件库来说，这依旧是十分有用的，所以它们大多自己实现了这两个方法。对我们来讲，也许在项目中用不到，但学习这种解决问题的思路，是十分必要的。派发和广播，依赖于组件的 name（最怕此处有人说：如果不写 name，这方法不就没用了？2333···），以此来逐级查找对应的组件实例。Element 的实现中，给所有的组件都加了一个 componentName 属性，所以它是根据 componentName 来查找的。我们在实现的时候还是直接用 name。我们先来看一下 $dispatch 的简单用法，再来分析思路。123456789101112131415&lt;!--communication-min-sub.vue--&gt;&lt;template&gt; &lt;button @click=&quot;handleDispatch&quot;&gt;dispatch&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import Emitter from &apos;../../utils/emitter&apos;;export default &#123; mixins: [Emitter], // 混入，方便直接调用 methods: &#123; handleDispatch () &#123; this.dispatch(&apos;communication&apos;, &apos;onMessage&apos;, &apos;触发了dispatch&apos;); &#125; &#125;&#125;&lt;/script&gt; 12345678910111213&lt;!--communication.vue--&gt;&lt;script&gt; export default &#123; beforeDestroy() &#123; // 销毁 this.$off(&apos;onMessage&apos;); &#125;, mounted () &#123; this.$on(&apos;onMessage&apos;, (data) =&gt; &#123; // 监听 this.dataProps.title = data; &#125;) &#125; &#125;&lt;/script&gt; 现在明确一下目标，dispatch 方法接收三个参数，组件 name、事件名称、基础数据（可不传）。要做到向上跨级派发事件，需要向上找到指定 name 的组件实例，利用我们前文提到的 $emit方法做派送，所以在指定组件就可以用 $on 来监听了。所以 dispatch 本质上就是向上查找到指定组件并触发其自身的 $emit，以此来做响应，broadcast 则相反。那么如何做到跨级查找呢？12345678910111213141516171819202122232425262728293031function broadcast(componentName, eventName, params) &#123; this.$children.forEach(child =&gt; &#123; // 遍历所有的 $children var name = child.$options.name; // 拿到实例的name，Element 此处用的 componentName if (name === componentName) &#123; // 如果是想要的那个，进行广播 child.$emit.apply(child, [eventName].concat(params)); &#125; else &#123; // 不是则递归查找 直到 $children 为 [] broadcast.apply(child, [componentName, eventName].concat([params])); &#125; &#125;);&#125;export default &#123; methods: &#123; dispatch(componentName, eventName, params) &#123; var parent = this.$parent || this.$root; var name = parent.$options.name; while (parent &amp;&amp; (!name || name !== componentName)) &#123; // 存在 parent 且 (不存在 name 或 name 和 指定参数不一样) 则继续查找 parent = parent.$parent; // 不存在继续取上级 if (parent) &#123; name = parent.$options.name; // 存在上级 再次赋值并再次循环，进行判断 &#125; &#125; if (parent) &#123; // 找到以后 如果有 进行事件派发 parent.$emit.apply(parent, [eventName].concat(params)); &#125; &#125;, broadcast(componentName, eventName, params) &#123; broadcast.call(this, componentName, eventName, params); &#125; &#125;&#125;; 以上是详细的 emitter.js，可以看见，这和我们之前讲到的 $parent、$children、$emit、$on都密切相关。这也是为什么把它放到后面讲的原因。之前说过，派发和广播并没有解决兄弟组件通信的问题，所以这里大家也可以拓展思考一下，如何支持兄弟组件间通信。依然是依赖于$parent、$children，可以找到任意指定组件。 总结本期文章内容到这里就讲完了，我们来总结回顾一下： 子组件触达父组件的方式：Props、$parent、$attrs、$listeners、provide 和 inject、$dispatch 父组件触达子组件的方式：$emit 和 $on、$children、$ref、broadcast 全局通信：EventBus、Vuex 转载：Vue 组件间通信方式完整版]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[async/await]]></title>
    <url>%2F2019%2F04%2F13%2Fasync-await%2F</url>
    <content type="text"><![CDATA[关于async/await执行顺序首先是因为一个关于事件循环的面试题 1234567891011121314151617181920212223242526272829303132333435async function async1() &#123; console.log(&apos;async1 start&apos;); await async2(); console.log(&apos;async1 end&apos;);&#125;async function async2() &#123; console.log(&apos;async2&apos;);&#125;console.log(&apos;script start&apos;);setTimeout(function() &#123; console.log(&apos;setTimeout&apos;);&#125;, 0)async1();new Promise(function(resolve) &#123; console.log(&apos;promise1&apos;); resolve();&#125;).then(function() &#123; console.log(&apos;promise2&apos;);&#125;);console.log(&apos;script end&apos;);/*script startasync1 startasync2promise1script endasync1 endpromise2setTimeout*/ 说一下宏任务可以理解是每次执行栈执行的代码就是一个宏任务。浏览器为了能够使得js内部宏任务与DOM任务能够有序的执行，会在一个(macro)task执行结束后，在下一个(macro)task 执行开始前，对页面进行重新渲染，流程为：(macro)task -&gt; 渲染 -&gt;(macro)task-&gt;... (macro)task主要包含：script(整体代码)、setTimeout、setInterval、I/O、UI交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境) 说一下微任务microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前task任务后，下一个task之前，在渲染之前。 所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染。也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）。 microtask主要包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境) 执行（每个）宏任务之前都会检查有没有微任务需要执行，如果有就会把微任务执行了再执行。 Promise和async中的立即执行Promise中的异步体现在then和catch中，所以写在Promise中的代码是被当做同步任务立即执行的。而在async/await中，在出现await出现之前，其中的代码也是立即执行的。 await做了什么从字面意思上看await就是等待，await 等待的是一个表达式，这个表达式的返回值可以是一个promise对象也可以是其他值。 很多人以为await会一直等待之后的表达式执行完之后才会继续执行后面的代码，实际上await是一个让出线程的标志。await后面的表达式会先执行一遍，将await后面的代码加入到microtask中(因为async await本身就是promise+generator的语法糖)，然后就会跳出整个async函数来执行后面的代码。所以题中12345async function async1() &#123; console.log(&apos;async1 start&apos;); await async2(); console.log(&apos;async1 end&apos;);&#125; 等价于123456async function async1() &#123; console.log(&apos;async1 start&apos;); Promise.resolve(async2()).then(() =&gt; &#123; console.log(&apos;async1 end&apos;); &#125;)&#125; 所以本题的执行顺序为：执行script start-&gt;遇到setTimeout,将它放入宏任务队列中-&gt;遇到async1(),执行它的同步代码,async1 start以及跟在await屁股后面的代码，这里是个函数async2(),执行async2,后面那句console.log(‘async1 end’)则被让出线程放入微任务队列中-&gt;继续执行promise中的同步代码promise1,.then后的代码放出微任务队列中-&gt;继续执行script end-&gt;同步代码执行完毕，再执行异步代码，先微任务队列中的async1 end再promise2,最后宏任务队列中的setTimeout。即为：script start -- async1 start -- async2 --promise1 -- script end -- aync1 end -- promise2 -- setTimeout 再做几个题:1234567891011121314151617181920212223242526272829async function async1() &#123; console.log(&apos;async1 start&apos;); await async2(); console.log(&apos;async1 end&apos;);&#125;async function async2() &#123; //async2做出如下更改： new Promise(function(resolve) &#123; console.log(&apos;promise1&apos;); resolve();&#125;).then(function() &#123; console.log(&apos;promise2&apos;); &#125;);&#125;console.log(&apos;script start&apos;);setTimeout(function() &#123; console.log(&apos;setTimeout&apos;);&#125;, 0)async1();new Promise(function(resolve) &#123; console.log(&apos;promise3&apos;); resolve();&#125;).then(function() &#123; console.log(&apos;promise4&apos;);&#125;);console.log(&apos;script end&apos;); 根据以上的分析很容易得出：123456789script startasync1 startpromise1promise3script endpromise2async1 endpromise4setTimeout 12345678910111213141516171819202122232425262728async function async1() &#123; console.log(&apos;async1 start&apos;); await async2(); //更改如下： setTimeout(function() &#123; console.log(&apos;setTimeout1&apos;) &#125;,0)&#125;async function async2() &#123; //更改如下： setTimeout(function() &#123; console.log(&apos;setTimeout2&apos;) &#125;,0)&#125;console.log(&apos;script start&apos;);setTimeout(function() &#123; console.log(&apos;setTimeout3&apos;);&#125;, 0)async1();new Promise(function(resolve) &#123; console.log(&apos;promise1&apos;); resolve();&#125;).then(function() &#123; console.log(&apos;promise2&apos;);&#125;);console.log(&apos;script end&apos;); 结果：12345678script startasync1 startpromise1script endpromise2setTimeout3setTimeout2setTimeout1 123456789101112131415161718192021222324252627282930313233async function a1 () &#123; console.log(&apos;a1 start&apos;) await a2() console.log(&apos;a1 end&apos;)&#125;async function a2 () &#123; console.log(&apos;a2&apos;)&#125;console.log(&apos;script start&apos;)setTimeout(() =&gt; &#123; console.log(&apos;setTimeout&apos;)&#125;, 0)Promise.resolve().then(() =&gt; &#123; console.log(&apos;promise1&apos;)&#125;)a1()let promise2 = new Promise((resolve) =&gt; &#123; resolve(&apos;promise2.then&apos;) console.log(&apos;promise2&apos;)&#125;)promise2.then((res) =&gt; &#123; console.log(res) Promise.resolve().then(() =&gt; &#123; console.log(&apos;promise3&apos;) &#125;)&#125;)console.log(&apos;script end&apos;) 结果：12345678910script starta1 starta2promise2script endpromise1a1 endpromise2.thenpromise3setTimeout 主要内容 async做了一件什么事情？ await在等什么？ await等到之后，做了一件什么事情？ async/await比promise有哪些优势？ async做了一件什么事情？ 一句话概括：带 async 关键字的函数，它使得你的函数的返回值必定是 promise 对象也就是 如果async关键字函数返回的不是promise，会自动用Promise.resolve()包装 如果async关键字函数显式地返回promise，那就以你返回的promise为准 这是一个简单的例子，可以看到 async 关键字函数和普通函数的返回值的区别1234567891011121314async function fn1()&#123; return 123&#125;function fn2()&#123; return 123&#125;console.log(fn1())console.log(fn2())Promise &#123;&lt;resolved&gt;: 123&#125;123 所以你看，async 函数也没啥了不起的，以后看到带有 async 关键字的函数也不用慌张，你就想它无非就是把return值包装了一下，其他就跟普通函数一样。关于async关键字还有那些要注意的？ 在语义上要理解，async表示函数内部有异步操作 另外注意，一般 await 关键字要在 async 关键字函数的内部，await 写在外面会报错。 await在等什么？ 一句话概括： await等的是右侧「表达式」的结果也就是说， 右侧如果是函数，那么函数的return值就是「表达式的结果」 右侧如果是一个 ‘hello’ 或者什么值，那表达式的结果就是 ‘hello’12345678910async function async1() &#123; console.log( &apos;async1 start&apos; ) await async2() console.log( &apos;async1 end&apos; )&#125;async function async2() &#123; console.log( &apos;async2&apos; )&#125;async1()console.log( &apos;script start&apos; ) await会让出线程，阻塞后面的代码，那么是怎么让出线程呢？‘async2’和’script start’谁会先打印呢？语句 await async2()是怎么执行呢？实践结论是，从右往左执行，先执行async2后，发现有await关键字，于是让出线程，阻塞代码 await等到之后，做了一件什么事情？ 那么await右侧表达式的结果就是它要等的东西。等到之后，对于await来说，分2个情况 不是promise对象 是promise对象 如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。 看到上面的阻塞一词，心慌了吧……放心，这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。 async/await比promise有哪些优势？ async/await 的优势在于处理 then 链。单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 传入参数 n，表示这个函数执行的时间（毫秒） * 执行的结果是 n + 200，这个值将用于下一步骤 */function takeLongTime(n) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(n + 200), n); &#125;);&#125;function step1(n) &#123; console.log(`step1 with $&#123;n&#125;`); return takeLongTime(n);&#125;function step2(n) &#123; console.log(`step2 with $&#123;n&#125;`); return takeLongTime(n);&#125;function step3(n) &#123; console.log(`step3 with $&#123;n&#125;`); return takeLongTime(n);&#125;现在用 Promise 方式来实现这三个步骤的处理function doIt() &#123; console.time(&quot;doIt&quot;); const time1 = 300; step1(time1) .then(time2 =&gt; step2(time2)) .then(time3 =&gt; step3(time3)) .then(result =&gt; &#123; console.log(`result is $&#123;result&#125;`); console.timeEnd(&quot;doIt&quot;); &#125;);&#125;doIt();// step1 with 300// step2 with 500// step3 with 700// result is 900// doIt: 1507.251ms输出结果 result 是 step3() 的参数 700 + 200 = 900。doIt() 顺序执行了三个步骤，一共用了 300 + 500 + 700 = 1500 毫秒，和 console.time()/console.timeEnd() 计算的结果一致。如果用 async/await 来实现呢，会是这样async function doIt() &#123; console.time(&quot;doIt&quot;); const time1 = 300; const time2 = await step1(time1); const time3 = await step2(time2); const result = await step3(time3); console.log(`result is $&#123;result&#125;`); console.timeEnd(&quot;doIt&quot;);&#125;doIt();结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样 参考：理解 JavaScript 的 async/await关于第10题的一些见解]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>
