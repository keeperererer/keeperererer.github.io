<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[为什么call比apply快？]]></title>
    <url>%2F2019%2F05%2F14%2F%E4%B8%BA%E4%BB%80%E4%B9%88call%E6%AF%94apply%E5%BF%AB%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[在看源码的过程中，总会遇到这样的写法：12345678910var triggerEvents = function(events, args) &#123; var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2]; switch (args.length) &#123; case 0: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx); return; case 1: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1); return; case 2: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return; case 3: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return; default: while (++i &lt; l) (ev = events[i]).callback.apply(ev.ctx, args); return; &#125;&#125;; 作者会在参数为3个（包含3）以内时，优先使用 call 方法进行事件的处理。而当参数过多（多余3个）时，才考虑使用 apply 方法。这个就是因为 call 比 apply 快。 为什么call比apply快？Function.prototype.apply(thisArg,argArray) 如果 IsCallable（Function）为false，即 Function 不可以被调用，则抛出一个 TypeError 异常。 如果 argArray 为 null 或未定义，则返回调用 Function 的 [[Call]] 内部方法的结果，提供thisArg 和一个空数组作为参数。 如果 Type（argArray）不是 Object，则抛出 TypeError 异常。 获取 argArray 的长度。调用 argArray 的 [[Get]] 内部方法，找到属性 length。 赋值给 len。 定义 n 为 ToUint32（len）。 初始化 argList 为一个空列表。 初始化 index 为 0。 循环迭代取出 argArray。重复循环 while（index &lt; n） 将下标转换成String类型。初始化 indexName 为 ToString(index). 定义 nextArg 为 使用 indexName 作为参数调用argArray的[[Get]]内部方法的结果。 将 nextArg 添加到 argList 中，作为最后一个元素。 设置 index ＝ index＋1 返回调用 Function 的 [[Call]] 内部方法的结果，提供 thisArg 作为该值，argList 作为参数列表。 Function.prototype.call(thisArg[,arg1[,arg2,…]]) 如果 IsCallable（Function）为 false，即 Function 不可以被调用，则抛出一个 TypeError 异常。 定义 argList 为一个空列表。如果使用超过一个参数调用此方法，则以从arg1开始的从左到右的顺序将每个参数附加为 argList 的最后一个元素 返回调用func的[[Call]]内部方法的结果，提供 thisArg 作为该值，argList 作为参数列表。 我们可以看到，明显 apply 比 call 的步骤多很多。由于 apply 中定义的参数格式（数组），使得被调用之后需要做更多的事，需要将给定的参数格式改变（步骤8）。 同时也有一些对参数的检查（步骤2），在 call 中却是不必要的。另外一个很重要的点：在 apply 中不管有多少个参数，都会执行循环，也就是步骤 6-8，在 call 中也就是对应步骤3 ，是有需要才会被执行。 综上，call 方法比 apply 快的原因是 call 方法的参数格式正是内部方法所需要的格式。 转自:为什么call比apply快？]]></content>
  </entry>
  <entry>
    <title><![CDATA[算法]]></title>
    <url>%2F2019%2F05%2F09%2F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[时间复杂度 通常使用最差的时间复杂度来衡量一个算法的好坏。常数时间O(1)代表这个操作和数据量没有关系，是一个固定时间的操作，比如四则运算。 对于一个算法来说，可能会计算出如下操作次数aN + 1,N代表数据量。那么该算法的时间复杂度就是O(N)。因为我们在计算时间复杂度的时候，数据量通常是非常大的，这时候低阶项和常数项可以忽略不计。 当然可能会出现两个算法都是O(N)的时间复杂度，那么对比两个算法的好坏就要通过对比低阶项和常数项了。 位运算 位运算在算法中很有用，速度可以比四则运算快很多。 在学习位运算之前应该知道十进制如何转二进制，二进制如何转十进制。这里说明下简单的计算方式 十进制33可以看成是32+1，并且33应该是六位二进制的（因为33近似32，而32是2的五次方，所以是六位），那么十进制33就是100001，只要是2的次方，那么就是1否则都为0 那么二进制100001同理，首位是2^5,末位是2^0,相加得出33 左移&lt;&lt;110 &lt;&lt; 1 // -&gt; 20 左移就是将二进制全部往左移动，10在二进制中表示为1010，左移一位后变成10100，转换为十进制也就是20，所以基本可以把左移看成以下公式 a*(2^b)。在此处 a为10 b为1。 右移&gt;&gt;110 &gt;&gt; 1 //-5 右移就是将二进制全部往右移动并去除多余的右边，10在二进制中表示为1010，右移一位后变成101,转换为十进制也就是5，所以基本可以把右移看成int v = a / (2^b)在此处 a为10，b为1右移很好用，比如可以用在二分算法中取出中间值113 &gt;&gt; 1 // -&gt; 6 按位操作按位与每一位都是1，结果才是112348 &amp; 7 // -&gt; 0//1000 &amp; 0111 -&gt; 0000 -&gt; 08 &amp; 8 // -&gt; 8//1000 &amp; 1000 -&gt; 1000 -&gt; 8 按位或其中一位为1，结果就是1128 | 7 // -&gt; 15// 1000 | 0111 -&gt; 1111 -&gt;15 按位异或每一位都不同，结果才为112348 ^ 7 // -&gt; 15// 1000 ^ 0111 -&gt; 1111 -&gt; 158 ^ 8 // -&gt; 0// 1000 ^ 1000 -&gt; 0000 -&gt; 0 从以上代码中可以发现按位异或就是不进位加法 面试题 ：两个数不使用四则运算得出和这道题中可以按位异或，以为按位异或就是不进位加法，8^8 = 0,如果进位了，就是16了，所以我们只需要将两个数进行异或操作，然后进位。那么也就是说两个二进制都是1的位置，左边应该有一个进位1，所以可以得出一下公式 a + b =(a ^ b) + ((a &amp; b) &lt;&lt; 1),然后通过迭代的方式模拟加法。1234567function sum(a,b)&#123; if(a == 0) return b if(b == 0) return a let newA = a ^ b let newB = (a &amp; b) &lt;&lt; 1 return sum(newA,newB)&#125; 排序 以下两个函数是排序中会用到的通用函数，就不一一写了123456789function checkArray(array)&#123; if(!array || array.length &lt;= 2) return&#125;function swap(array,left,rigth)&#123; let rightValue = array[right] array[right] = array[left] array[left] = rightValue&#125; 冒泡排序冒泡排序的原理如下，从第一个元素开始，把当前元素和下一个索引元素进行比较。如果当前元素大，那么就交换位置，重复操作直到比较到最后一个元素，那么此时最后一个元素就是该数组中最大的数。下一轮重复以上操作，但是此时最后一个元素已经是最大数了，所以不需要再比较最后一个元素，只需要比较到length-1的位置。12345678910function bubble(array)&#123; checkArray(array) for(let i = array.length - 1; i &gt; 0; i++)&#123; for(let j = 0; j &lt; i; j++)&#123; if(array[j] &gt; array[j+1]) swap(array,j,j + 1) &#125; &#125; return array&#125; 该算法的操作次数是一个等差数列 n + (n - 1) + (n - 2) + 1 ，去掉常数项以后得出时间复杂度是 O(n * n) 插入排序插入排序的原理如下。第一个元素默认是已排序元素，取出下一个元素和当前元素比较，如果当前元素大就交换位置。那么此时第一个元素就是当前的最小数，所以下次取出操作从第三个元素开始，向前对比，重复之前的操作。12345678function insertion(array)&#123; checkArray() for (let i = 1; i &lt; array.length; i++)&#123; for(let j = 1 - 1; j &gt;= 0 &amp;&amp; array[j] &gt; array[j + 1]; j--) swap(array, j, j+1) &#125; return array&#125; 该算法的操作次数是一个等差数列 n + (n - 1) + (n - 2) + 1 ，去掉常数项以后得出时间复杂度是 O(n * n) 选择排序选择排序的原理如下。遍历数组，设置最小值的索引为0，如果取出的值比当前最小值小，就替换最小值索引，遍历完成后，将第一个元素和最小值索引上的值交换。如果操作后，第一个元素就是数组中的最小值，下次遍历就可以从索引1开始重复上述操作。1234567891011function selection(array)&#123; checkArray(array) for(let i = 0; i &lt; array.length-1; i++)&#123; let minIndex = i for(let j = i + 1;j &lt; array.length; j++)&#123; minIndex = array[j] &lt; array[minIndex] ? j : minIndex &#125; swap(array, i, minIndex) &#125; return array&#125; 该算法的操作次数是一个等差数列 n + (n - 1) + (n - 2) + 1 ，去掉常数项以后得出时间复杂度是 O(n * n 归并排序归并排序的原理如下。递归的将数组两两分开直到最多包含两个元素，然后将数组排序合并，最终合并为排序好的数组。假设我有一组数组 [3, 1, 2, 8, 9, 7, 6]，中间数索引是 3，先排序数组 [3, 1, 2, 8] 。在这个左边数组上，继续拆分直到变成数组包含两个元素（如果数组长度是奇数的话，会有一个拆分数组只包含一个元素）。然后排序数组 [3, 1] 和 [2, 8] ，然后再排序数组 [1, 3, 2, 8] ，这样左边数组就排序完成，然后按照以上思路排序右边数组，最后将数组 [1, 2, 3, 8] 和 [6, 7, 9] 排序。123456789101112131415161718192021222324252627function mergeSort(arr)&#123; var len = arr.length; if(len&lt;2)&#123; return arr; &#125; var middle = Math.floor(len/2), left = arr.slice(0,middle), right = arr.slice(middle); return merge(mergeSort(left),mergeSort(right));&#125;function merge(left,right)&#123; var result = []; while(left.length &amp;&amp; right.length)&#123; if(left[0]&lt;=right[0]&#123; result.push(left.shift()); &#125;else&#123; result.push(right.shift()); &#125; &#125; while(left.length)&#123; result.push(left.shift()); &#125; while(right.length)&#123; result.push(right.shift()); &#125; return result;&#125; 该算法的操作次数是可以这样计算：递归了两次，每次数据量是数组的一半，并且最后把整个数组迭代了一次，所以得出表达式 2T(N / 2) + T(N) （T 代表时间，N 代表数据量）。根据该表达式可得出时间复杂度为 O(N * logN) 快排原理： .从数列中挑出一个元素，称为 “基准”（pivot）； .重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； .递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。123456789101112131415161718var quickSort2 = function(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort2(left).concat([pivot], quickSort2(right));&#125;; var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(quickSort2(arr)); 堆排序堆排序利用二叉堆的特性来做，二叉堆通常用数组表示，并且二叉堆是一颗完全二叉树（所有叶节点（最底层的节点）都是从左往右顺序排序，并且其他层的节点都是满的）。二叉堆又分为大根堆与小根堆 大根堆是某个节点的所有子节点的值都比他小 小根堆是某个节点的所有子节点的值都比他大堆排序的原理就是组成一个大根堆或者小根堆。以小根堆为例，某个节点的左边子节点索引是 i2+1,右边是 i2+2，父节点是 (i-1)/2。 首先遍历数组，判断该节点的父节点是否比他小，如果小就交换位置并继续判断，直到他的父节点比他大 重新以上操作1，直到数组首位是最大值 然后将首位与末尾交换位置并将数组长度减一，表示数组末尾已是最大值，不需要再比较大小 对比左右节点哪个大，然后记住大的节点的索引并且和父节点对比大小，如果子节点大就交换位置 重复以上操作 3 - 4 直到整个数组都是大根堆。]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2019%2F05%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[栈 概念 栈式一个线性结构，在计算机中是一个相当常见的数据结构。特点是只能在某一端添加或删除数据，遵循先进后出的原则 实现每种数据结构都可以用很多种方式来实现，其实可以把栈看成是数组的一个子集，所以这里使用数组来实现1234567891011121314151617181920class Stack &#123; constructor() &#123; this.stack = [] &#125; push(item) &#123; this.stack.push(item) &#125; pop() &#123; this.stack.pop() &#125; peek() &#123; return this.stack[this.getCount() - 1] &#125; getCount() &#123; return this.stack.length &#125; isEmpty() &#123; return this.getCount() === 0 &#125;&#125; 应用匹配括号1234567891011121314151617181920212223var isValid = function(s)&#123; let map = &#123; &apos;(&apos;: -1, &apos;)&apos;: 1, &apos;[&apos;: -2, &apos;]&apos;: 2, &apos;&#123;&apos;: -3, &apos;&#125;&apos;: 3 &#125; let stack = [] for(let i = 0; i &lt; s.length; i++)&#123; if(map[s[i]] &lt; 0)&#123; stack.push(s[i]) &#125;else&#123; let last = stack.pop() if(map[last] + map[s[i]] != 0) return false &#125; &#125; if(stack.length &gt; 0) return false return true&#125; 队列 概念队列一个线性结构，特点是在某一端添加数据，在另一端删除数据，遵循先进先出的原则。 实现这里会讲解两种实现队列的方法，分别是单链队列和循环队列。 单链队列1234567891011121314151617181920class Queue &#123; constructor() &#123; this.queue = [] &#125; enQueue(item) &#123; this.queue.push(item) &#125; deQueue() &#123; return this.queue.shift() &#125; getHeader() &#123; return this.queue[0] &#125; getLength() &#123; return this.queue.length &#125; isEmpty() &#123; return this.getLength() === 0 &#125;&#125; 因为单链队列在出队操作的时候需要O(n)的时间复杂度，所以引入了循环队列。循环队列的出队操作平均是O(1)的时间复杂度。 循环队列`class sqQueue { constructor(length){ this.queue = new Array(length + 1) //队头 this.first = 0 //队尾 this.last = 0 //当前队列大小 this.size = 0 } enQueue(item) { //判断队尾+1是否为队头 //如果是就代表需要扩容数组 // % this.queue.length是为了防止数组越界 if(this.first === (this.last + 1) % this.queue.length) { this.resize(this.getLength() *2 + 1) } thisqueue[this.last] = item this.size++ this.last = (this.last + 1) % this.queue.length } deQueue() { if(this.isEmpty()){ throw Error(‘Queue is empty’) } let r = this.queue[this.first] this.queue[this.first] = null //菜鸡看不懂写不下去辽 }}]]></content>
  </entry>
  <entry>
    <title><![CDATA[手写代码]]></title>
    <url>%2F2019%2F05%2F09%2F%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[实现new操作符 new操作符做了什么？ 它创建了一个全新的对象。 它会被执行[[Prototype]]（也就是proto）链接。 它使this指向新创建的对象。 通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。 如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用。 实现：12345678function myNew(func)&#123; let res = &#123;&#125; res.__proto__ = func.prototype let ret = func.apply(res,Array.prototype.slice.call(arguments,1)); return ret instanceof Object ? ret : res &#125;slice(start,end) ==&gt; 返回一个从[start（从0开始） ,end)的新数组 实现一个instanceofinstanceof的原理？instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。 实现：1234567891011function myInstanceof(left, right) &#123; let prototype = right.prototype left = left.__proto__ while (true) &#123; if (left === null || left === undefined) return false if (prototype === left) return true left = left.__proto__ &#125;&#125; 分析： 首先获取类型的原型 然后获得对象的原型 然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null 实现一个call &amp; applycall123456789101112实现：Function.prototype.myCall = function(context)&#123; if(typeof this !== &apos;function&apos;)&#123; throw new TypeError(&apos;Error&quot;) &#125;context = context || windowcontext.fn = thisconst args = [...arguments].slice(1)const result = context.fn(...args)delete context.fnreturn result&#125; apply12345678910111213141516Function.prototype.myApply = function(context) &#123;if (typeof this !== &apos;function&apos;) &#123;throw new TypeError(&apos;Error&apos;)&#125;context = context || windowcontext.fn = thislet result// 处理参数和 call 有区别if (arguments[1]) &#123;result = context.fn(...arguments[1])&#125; else &#123;result = context.fn()&#125;delete context.fnreturn result&#125; 实现一个bind123456789101112131415Function.prototype.myBind = function (context) &#123;if (typeof this !== &apos;function&apos;) &#123;throw new TypeError(&apos;Error&apos;)&#125;const _this = thisconst args = [...arguments].slice(1)// 返回一个函数return function F() &#123;// 因为返回了一个函数，我们可以 new F()，所以需要判断if (this instanceof F) &#123;return new _this(...args, ...arguments)&#125;return _this.apply(context, args.concat(...arguments))&#125;&#125; 实现一个简易版的promise12345678910111213const PENDING = &apos;pending&apos;const RESOLVED = &apos;resolved&apos;const REJECTED = &apos;rejected&apos;function MyPromise(fn) &#123; const that = this that.state = PENDING that.value = null that.resolvedCallbacks = [] that.rejectedCallbacks = [] // 待完善 resolve 和 reject 函数 // 待完善执行 fn 函数&#125; 首先我们创建了三个常量用于表示状态，对于经常使用的一些值都应该通过常量来管理，便于开发及后期维护 在函数体内部首先创建了常量 that，因为代码可能会异步执行，用于获取正确的 this 对象 一开始 Promise 的状态应该是 pendingvalue 变量用于保存 resolve 或者 reject 中传入的值 resolvedCallbacks 和 rejectedCallbacks 用于保存 then 中的回调，因为当执行完 Promise 时状态可能还是等待中，这时候应该把 then 中的回调保存起来用于状态改变时使用 接下来我们来完善 resolve 和 reject 函数，添加在 MyPromise 函数体内部123456789101112131415function resolve(value) &#123; if (that.state === PENDING) &#123; that.state = RESOLVED that.value = value that.resolvedCallbacks.map(cb =&gt; cb(that.value)) &#125;&#125;function reject(value) &#123; if (that.state === PENDING) &#123; that.state = REJECTED that.value = value that.rejectedCallbacks.map(cb =&gt; cb(that.value)) &#125;&#125; 这两个函数代码类似，就一起解析了 首先两个函数都得判断当前状态是否为等待中，因为规范规定只有等待态才可以改变状态 将当前状态更改为对应状态，并且将传入的值赋值给 value 遍历回调数组并执行 完成以上两个函数以后，我们就该实现如何执行 Promise 中传入的函数了12345try &#123; fn(resolve, reject)&#125; catch (e) &#123; reject(e)&#125; 实现很简单，执行传入的参数并且将之前两个函数当做参数传进去 要注意的是，可能执行函数过程中会遇到错误，需要捕获错误并且执行 reject 函数 最后我们来实现较为复杂的 then 函数1234567891011121314151617181920MyPromise.prototype.then = function(onFulfilled, onRejected) &#123; const that = this onFulfilled = typeof onFulfilled === &apos;function&apos; ? onFulfilled : v =&gt; v onRejected = typeof onRejected === &apos;function&apos; ? onRejected : r =&gt; &#123; throw r &#125; if (that.state === PENDING) &#123; that.resolvedCallbacks.push(onFulfilled) that.rejectedCallbacks.push(onRejected) &#125; if (that.state === RESOLVED) &#123; onFulfilled(that.value) &#125; if (that.state === REJECTED) &#123; onRejected(that.value) &#125;&#125; 首先判断两个参数是否为函数类型，因为这两个参数是可选参数 当参数不是函数类型时，需要创建一个函数赋值给对应的参数，同时也实现了透传，比如如下代码 123// 该代码目前在简单版中会报错// 只是作为一个透传的例子Promise.resolve(4).then().then((value) =&gt; console.log(value)) 接下来就是一系列判断状态的逻辑，当状态不是等待态时，就去执行相对应的函数。如果状态是等待态的话，就往回调函数中 push 函数，比如如下代码就会进入等待态的逻辑 1234567new MyPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1) &#125;, 0)&#125;).then(value =&gt; &#123; console.log(value)&#125;) 实现防抖 &amp; 节流 实现深拷贝]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue响应式]]></title>
    <url>%2F2019%2F04%2F24%2Fvue%E5%93%8D%E5%BA%94%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Vue官方的响应式原理图]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue组件通信]]></title>
    <url>%2F2019%2F04%2F17%2Fvue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[组件 组件是可以复用的Vue实例 在Vue中，根据注册方式的不同，可以分为： 局部组件（局部注册） 全局组件（全局注册） 顾名思义，全局注册的组件，可以用在 Vue 实例的任意模板中。但是带来的隐患是，在 webpack 模块化构建时，即便你没有在项目中使用这个组件，依然会打包到最终的项目代码中。而局部组件，则需要在使用到的实例中注册该组件。1234567891011121314151617181920212223// 全局注册// install.jsimport Icon from &apos;./Icon.vue&apos;;const install = &#123; install:function(Vue)&#123; Vue.component(&apos;VIcon&apos;, Icon); &#125;&#125;;export default install;// main.jsimport install from &apos;./install.js&apos;; // 引入全局插件Vue.use(install); // 注册// 局部注册import VIcon from &apos;./Icon.vue&apos;;export default&#123; components: &#123; VIcon &#125;&#125;// 使用&lt;v-icon&gt; &lt;/v-icon&gt; 根据应用场景的不同，又可以分为： 页面组件：我们使用 Vue 时，每个路由代表的页面，都可以称之为组件。 基础组件：就像上面栗子中的 Icon 组件，就是一个典型的基础组件。基本上不掺杂业务逻辑，在项目中可能被大量使用，易于移植。类似的基础组件还有 Button、Input 等，常见于各类 UI 组件库。 业务组件：业务组件和项目具体的业务逻辑有大量耦合，一般抽离于当前项目。 以上就是组件的简单介绍，那我们到底为什么要推崇组件化？组件化有什么好处？复用？我个人认为组件化最大的好处，便是解耦，易于项目管理。所以在大型项目管理中，组件化是非常有必要的。当然，这并不是今天学习的重点，以后有机会再聊。正因为在 Vue 中处处都是组件，而我们也偏向于组件化、模块化。那我们在一堆组件中，便需要解决一个问题 — 组件间通信。下面，我们就进入今天的主题，Vue 的组件间通信。 组件间通信 PropsVue 中，最基本的通信方式就是 Props，它是父子组件通信中父组件传值给子组件的一种方式。它允许以数组形式接收，但是更推荐你开启类型检查的形式1234567891011121314151617181920212223242526//communication.vue&lt;communication-sub v-bind=&quot;dataProps&quot;&gt;&lt;/communication-sub&gt;//v-bind=&quot;dataProps&quot;等同于:title=&quot;title&quot;，适用于多个参数一起传递...data()&#123; return &#123; dataProps:&#123; title:&apos;我是父组件的值&apos; &#125; &#125;&#125;//communication-sub.vue&lt;div class=&quot;communication-sub&quot;&gt; &#123;&#123;title&#125;&#125;&lt;/div&gt;...props:[&apos;title&apos;]//更推荐开启类型检查props:&#123; title:&#123; type:String, required:true, default:&apos;&apos;//允许指定默认值，引用类型需要函数返回 &#125;&#125;... 我们都知道，Props 是单向数据流，这是 Vue 为了避免子组件意外改变父组件的状态，从而导致数据流向难以理解而做出的限制。所以 Vue 推荐需要改动的时候，通过改变父组件的值从而触发 Props 的响应。或者，我们可以在接收非引用类型的值时，使用子组件自身的 data 做一次接收。123456props: [&apos;title&apos;],data: function () &#123; return &#123; text: this.title &#125;;&#125; 为什么是非引用类型呢，因为在 JavaScript 中，引用类型的赋值，实际是内存地址的传递。所以上面栗子中的简单赋值，显然会指向同一个内存地址，所以如果是数组或是对象，你可能需要一次深拷贝。1let obj = JSON.parse(JSON.stringify(obj)); 上面这个操作有一些缺陷，不能序列化函数、undefined、循环引用等.事实上，在 Props 是引用类型时，单独修改对象、数组的某个属性或下标，Vue 并不会抛出错误。当然，前提是你要非常清楚自己在做什么，并写好注释，防止你的小伙伴们疑惑。有的同学可能知道，在组件上绑定的属性，如果没有在组件内部用 Props 声明，会默认绑定到组件的根元素上去。还是之前的栗子：1&lt;communication-sub v-bind=&quot;dataProps&quot; class=&quot;one&quot; type=&quot;div&quot;&gt;&lt;/communication-sub&gt; 这是 Vue 默认处理的，而且，除了 class 和 style 采用合并策略，其它特性（如上栗 type）会替换掉原来根元素上的属性值。当然，我们也可以显示的在组件内部关闭掉这个特性：123...inheritAttrs: false,props: [&apos;title&apos;] 利用 inheritAttrs，我们还可以方便的把组件绑定的其它特性，转移到我们指定的元素上。这就需要用到下一个我们要讲的 $attrs 了。 attrs,listeners我们在使用组件库的时候经常会这么写：1&lt;el-input v-model=&quot;input&quot; placeholder=&quot;请输入内容&quot;&gt;&lt;/el-input&gt; 实际渲染后：可以看到我们指定的的 placeholder 是渲染在 input 上的，但是 input 并不是根元素。难道都用 Props 声明后，再赋值给 input？这种情况就可以用到 $attrs 了，改造一下我们之前那个栗子。123456789101112131415161718192021222324252627282930313233// communication.vue&lt;template&gt; &lt;div class=&quot;communication&quot;&gt; &lt;communication-sub v-bind=&quot;dataProps&quot; class=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;请输入内容&quot;&gt; &lt;/communication-sub&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import communicationSub from &apos;./communication-sub.vue&apos;;export default&#123; name: &apos;communication&apos;, data() &#123; return &#123; dataProps: &#123; title: &apos;我是 communication 的值&apos;, &#125; &#125; &#125;, components: &#123; communicationSub &#125;&#125;&lt;/script&gt;// communication-sub.vue···&lt;div class=&quot;communication-sub&quot;&gt; &lt;input v-bind=&quot;$attrs&quot; v-model=&quot;title&quot;&gt;&lt;/input&gt;&lt;/div&gt;··· export default &#123; inheritAttrs: false&#125; 可以看到，type 已经转移到了子元素 input 标签上，但是 class 没有。这是因为 inheritAttrs: false选项不会影响 style 和 class 的绑定。可以看出 $attrs则是将没有被组件内部 Props 声明的传值（也叫非 Props 特性）收集起来的一个对象，再通过 v-bind 将其绑定在指定元素上。这也是 Element 等组件库采用的策略。这里需要注意一点，通过 $attrs 指定给元素的属性，不会与该元素原有属性发生合并或替换，而是以原有属性为准。举个例子，假如我将上述 input 的 type 默认设置为 password。1&lt;input v-bind=&quot;$attrs&quot; v-model=&quot;title&quot; type=&quot;password&quot;&gt;&lt;/input&gt; 则不会采用 $attrs 中的 type: ‘text’，将以 password 为准，所以如果需要默认值的属性，建议不要用这种方式。 $listeners同$attrs类似，可以看作是一个包含了组件上所有事件监听器(包括自定义事件，不包括.native修饰的事件)的对象。它也支持上述的写法，适用于将事件安放于组件内指定元素上。123456789101112131415// communication.vue&lt;communication-sub v-bind=&quot;dataProps&quot;class=&quot;input&quot;type=&quot;text&quot;placeholder=&quot;请输入内容&quot;@focus=&quot;onFocus&quot; &gt;&lt;/communication-sub&gt;···methods: &#123; onFocus() &#123; console.log(&apos;onFocus&apos;); &#125;&#125;// communication-sub.vue&lt;input v-bind=&quot;$attrs&quot; v-model=&quot;title&quot; v-on=&quot;$listeners&quot;&gt;&lt;/input&gt; 给之前的栗子绑定一个聚焦事件，在子组件中通过 $listeners 绑定给 input，则会在 input 聚焦时触发。那么除了用在这种给组件内指定元素绑定特性和事件的情况，还有哪些场景可以用到呢？官方说明：在创建更高层次的组件时非常有用。比如在祖孙组件中传递数据，在孙子组件中触发事件后要在祖辈中做相应更新。我们继续之前的栗子：在孙辈组件触发点击事件，然后在祖辈中修改相应的 data。123456789101112131415161718192021222324252627// communication.vue&lt;communication-sub v-bind=&quot;dataProps&quot; @click=&quot;onCommunicationClick&quot;&gt;&lt;/communication-sub&gt;···methods: &#123; onCommunicationClick() &#123; this.dataProps.title = &apos;我是点击之后的值&apos;; &#125;&#125;;// communication-sub.vue&lt;communication-min-sub v-on=&quot;$listeners&quot;&gt;&lt;/communication-min-sub&gt; // 子组件中将事件透传到孙辈// communication-min-sub.vue&lt;template&gt; &lt;div class=&quot;communication-min-sub&quot;&gt; &lt;p&gt;我是 communication-min-sub&lt;/p&gt; &lt;button v-on=&quot;$listeners&quot;&gt;click&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123; name: &apos;communication-min-sub&apos;, inheritAttrs: false&#125;&lt;/script&gt; 这样就能很方便的在多级组件的子级组件中，快速访问到父组件的数据和方法。正如在刚才的例子中，button 点击时，是直接调用的 communication.vue 中定义的方法。 依赖注入provide.inject上面的方法，在大多数多级组件嵌套的场景很有用，但有时我们遇到的并不一定是有父子关系的组件。比如基础组件中的 Select 下拉选择器。12345678&lt;el-select v-model=&quot;value&quot; placeholder=&quot;请选择&quot;&gt; &lt;el-option v-for=&quot;item in options&quot; :key=&quot;item.value&quot; :label=&quot;item.label&quot; :value=&quot;item.value&quot;&gt; &lt;/el-option&gt;&lt;/el-select&gt; 相信大家都使用过上栗或者类似于上栗的基础组件，它们借助 vue 插槽 实现。所以这个时候，el-select 和 el-option 之间的数据通信，我们之前的 $attrs、$listeners就没有用武之地了。有同学可能不太理解上面的代码为什么要通信，我简单介绍一下 Element 的处理方式： 我们可以简单的认为（Element 源码比这个要稍复杂，为了方便理解，简化一下，如有需要，可直接前往源码阅读），在 el-select 中有一个 input 元素，el-option 中是一列渲染好的 li。根据需求，我们在选中某个 li 的时候，要通知 input 展示相应的数据。而且我们在实际使用的时候，一般还伴随 el-form、el-form-item等组件，所以迫切需要一种方式: 可以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。 有同学可能会想到，这种多级的可以用 Vuex、EventBus等方式，当然可以。只不过我们现在的前提是基础组件，一般第三方组件库是不会增加一些额外的依赖的。事实上 Vue 本身并不推荐直接在业务中使用 provide、inject，一般在组件、插件库用到的比较多。但是在项目比较小、业务逻辑比较简单的时候，我们完全不必特意引入 Vuex。只要使用得当，provide、inject 确实不失为一种好办法。说了这么多，我们来看一下具体用法，我们将之前的栗子，改为用 provide、inject 来实现。123456789101112131415161718192021222324252627282930313233343536// communication.vue&lt;communication-sub v-bind=&quot;dataProps&quot; &gt;&lt;/communication-sub&gt;// @click=&quot;onCommunicationClick&quot; 移除之前绑定的时间···// 在 provide 添加子代需要接收的方法 onCommunicationClick，// 也可以直接指定为 this，子代便能访问父代所有的数据和方法。provide: function () &#123; return &#123; onCommunicationClick: this.onCommunicationClick &#125;&#125;,methods: &#123; onCommunicationClick() &#123; this.dataProps.title = &apos;我是点击之后的值&apos;; &#125;&#125;;// communication-sub.vue&lt;communication-min-sub&gt;&lt;/communication-min-sub&gt;// 移除之前的 v-on=&quot;$listeners&quot;，因为在这个组件中不需要用到父组件的方法，所以不用做其它处理// communication-min-sub.vue&lt;template&gt; &lt;div class=&quot;communication-min-sub&quot;&gt; ··· &lt;button @click=&quot;onCommunicationClick&quot;&gt;click&lt;/button&gt; // 移除 v-on=&quot;$listeners&quot;，然后绑定 inject 接收到的方法 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123; name: &apos;communication-min-sub&apos;, inject: [&apos;onCommunicationClick&apos;] // inject 接收父组件的方法&#125;&lt;/script&gt; 这种写法和之前的 $listeners 得到的效果是一样的.思考：有些同学可能会想到，如果我在根实例，app.vue 中如此设置：123456789101112131415&lt;script&gt; export default &#123; provide () &#123; return &#123; app: this // 设置app为this &#125; &#125;, data () &#123; return &#123; userInfo: null, otherState: null &#125; &#125; &#125;&lt;/script&gt; 那这样把所有的状态管理都放在 app.data 中，所有的子代中不就可以共享了吗？是不是就不需要 Vuex 了呢？实际上，Vue 本身就提供了一个方法来访问根实例 $root，所以即使没有 provide 也是可以做到的。那为什么不这么用呢？还是前面提到的原因，不利于追踪维护，也失去了所谓状态管理的意义。不过，如果你的项目足够小的话，依然可以这么使用。 ref,parent,children我们前面一直说的都是子组件如何触达父组件，那么父组件能不能访问到子组件呢？当然是可以的。 ref简单来说就是获取元素的 Dom 对象和子组件实例。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例。获取 Dom 元素就是为了进行一些 Dom 操作，需要注意的一点就是，要在 Dom 加载完成后使用，否则可能获取不到。比如我要将之前 input 的字体颜色改成红色：12345678&lt;input type=&quot;text&quot; v-model=&quot;dataProps.title&quot; ref=&quot;input&quot;&gt;...mounted() &#123; this.$nextTick(_ =&gt; &#123; // 确保 Dom 更新完成 this.$refs[&apos;input&apos;].style.color = &apos;red&apos;; &#125;);&#125;// 这里只是举一个栗子，实际项目中的需求，最好通过 class 的方式，尽量减少 Dom 操作。 那什么情况下需要获取组件实例呢？比如父元素的某个状态改变，需要子组件进行 http 请求更新数据。通常情况下，我们会选择通过 Props 将状态传递给子组件，然后子组件进行 Watch 监测，如果有变更，则进行相应操作。这个时候，我们便可以选择使用 ref。1234567891011&lt;child ref=&quot;child&quot;&gt;&lt;/child&gt;···&lt;script&gt; export default &#123; methods () &#123; onStateChange() &#123; // 变更状态后直接调用子组件方法进行更新 this.$refs[&apos;child&apos;].updateData(); &#125; &#125; &#125;&lt;/script&gt; $children,$parent无独有偶，$children 同样可以完成上面的任务。$children 和 $parent，顾名思义，一个会找到当前组件的子组件，一个会找到当前组件的父组件。如果有多个子组件，需要依赖组件实例的 name 属性。改写一下上面的方法：123456789&lt;script&gt; export default &#123; methods () &#123; onStateChange() &#123; // 子组件返回的是一个数组，多个子组件用 $options.name 区分。 this.$children[0].updateData(); &#125; &#125; &#125;&lt;/script&gt; $parent 和 $children 用法一样，不过 $parent 返回的父组件实例，不是数组，因为父组件肯定只有一个。ref、parent、children 它们几个的一个缺点就是无法处理跨级组件和兄弟组件，后续我们会介绍 dispatch 和 broadcast 方法，实现跨级通信。 emit,on,off$emit，想必大家都非常熟悉，我们通常用作父子组件间通信，我们也叫它自定义事件。$emit 和 $on都是组件自身的方法，$on 可以监听 $emit 派发的事件，$off 则用来取消事件监听。这也是我们下一个要讲的通信方式 EventBus 所依赖的原理。12345678910111213141516171819202122232425262728293031// 父组件&lt;template&gt; &lt;button-component @clickButton=&quot;clickButton&quot;&gt;&lt;/button-component&gt; // 在父组件利用 v-on 监听&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; clickButton () &#123; ··· &#125; &#125;&#125;&lt;/script&gt;// 子组件&lt;template&gt; &lt;button @click=&quot;handleClick&quot;&gt;&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; handleClick () &#123; // 触发 $emit this.$emit(&apos;clickButton&apos;); &#125; &#125;, mounted() &#123; this.$on(&apos;clickButton&apos;, (...arr) =&gt; &#123; // 也可以自己监听 $emit，虽然没什么用··· console.log(...arr); &#125;) &#125;&#125;&lt;/script&gt; EventBus$emit的痛点依然是支持跨级和兄弟组件，Vue 官方推荐我们使用一个新的 Vue 实例来做一个全局的事件通信（或者叫中央事件总线···），也就是我们要讲的 EventBus。了解过的同学都知道，正常的 bus，我们一般会挂载到 Vue 的 prototype 上，方便全局调用。12// main.jsVue.prototype.$bus = new Vue(); 依旧改写之前的栗子：1234567891011121314151617181920212223242526272829&lt;!--communication.vue--&gt;&lt;communication-sub v-bind=&quot;dataProps&quot; &gt;&lt;/communication-sub&gt;···beforeDestroy() &#123; &lt;!-- 实例销毁时，需要卸载监听事件 --&gt; this.$bus.$off(&apos;busClick&apos;);&#125;,created() &#123; &lt;!-- 监听子组件触发的 Bus 事件--&gt; this.$bus.$on(&apos;busClick&apos;, (data) =&gt; &#123; this.dataProps.title = data; &#125;);&#125;&lt;!--communication-min-sub.vue--&gt;&lt;template&gt; &lt;div class=&quot;communication-min-sub&quot;&gt; &lt;button @click=&quot;busClick&quot;&gt;click bus&lt;/button&gt; &lt;!--子组件触发点击事件--&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123; methods: &#123; busClick() &#123; this.$bus.$emit(&apos;busClick&apos;, &apos;bus 触发了&apos;); &#125; &#125;&#125;&lt;/script&gt; 这是一个基础的 EventBus 的实现。现在我们设想一下，类似于 userInfo 这样的信息，在很多页面都需要用到，那我们需要在许多页面都做 $on 监听的操作。那能否将这些操作整合到一起呢？我们一起来看：1234567891011121314151617181920212223242526 // 新建一个 eventBus.jsimport Vue from &apos;vue&apos;;const bus = new Vue(&#123; data () &#123; return &#123; userInfo: &#123;&#125; &#125; &#125;, created () &#123; this.$on(&apos;getUserInfo&apos;, val =&gt; &#123; this.userInfo = val; &#125;) &#125;&#125;);export default bus;// main.jsimport bus from &apos;./eventBus&apos;;Vue.prototype.$bus = bus;// app.vuemethods: &#123; getUserInfo() &#123; ajax.post(***).then(data =&gt; &#123; this.$bus.$emit(&apos;getUserInfo&apos;, data); // 通知 EventBus 更新 userInfo &#125;) &#125;&#125; 这样在其他页面用到 userInfo 的时候，只需要 this.$bus.userInfo 就可以了。注意刚刚其实没有用 off 卸载掉监听，因为其实 userInfo 这种全局信息，并没有一个准确的说要销毁的时机，浏览器关闭的时候，也用不着我们处理了。但是，如果只是某个页面组件用到的，建议还是用最开始的方法，在页面销毁的时候卸载掉。 派发与广播:dispath与broadcast在 Vue 1.x 的实现中，有 $dispatch 和 $broadcast 方法，但是在 2.x 被废弃了。$dispatch 的主要作用是向上级组件派发事件，$broadcast 则是向下级广播。它们的优点是都支持跨级，再看一下官方废弃这两个方法的理由： 因为基于组件树结构的事件流方式实在是让人难以理解，并且在组件结构扩展的过程中会变得越来越脆弱。并且 $dispatch 和 $broadcast 也没有解决兄弟组件间的通信问题。 可以看到，主要原因是在组件结构扩展后不易理解，以及没有解决兄弟组件通信的问题。但是对于组件库来说，这依旧是十分有用的，所以它们大多自己实现了这两个方法。对我们来讲，也许在项目中用不到，但学习这种解决问题的思路，是十分必要的。派发和广播，依赖于组件的 name（最怕此处有人说：如果不写 name，这方法不就没用了？2333···），以此来逐级查找对应的组件实例。Element 的实现中，给所有的组件都加了一个 componentName 属性，所以它是根据 componentName 来查找的。我们在实现的时候还是直接用 name。我们先来看一下 $dispatch 的简单用法，再来分析思路。123456789101112131415&lt;!--communication-min-sub.vue--&gt;&lt;template&gt; &lt;button @click=&quot;handleDispatch&quot;&gt;dispatch&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import Emitter from &apos;../../utils/emitter&apos;;export default &#123; mixins: [Emitter], // 混入，方便直接调用 methods: &#123; handleDispatch () &#123; this.dispatch(&apos;communication&apos;, &apos;onMessage&apos;, &apos;触发了dispatch&apos;); &#125; &#125;&#125;&lt;/script&gt; 12345678910111213&lt;!--communication.vue--&gt;&lt;script&gt; export default &#123; beforeDestroy() &#123; // 销毁 this.$off(&apos;onMessage&apos;); &#125;, mounted () &#123; this.$on(&apos;onMessage&apos;, (data) =&gt; &#123; // 监听 this.dataProps.title = data; &#125;) &#125; &#125;&lt;/script&gt; 现在明确一下目标，dispatch 方法接收三个参数，组件 name、事件名称、基础数据（可不传）。要做到向上跨级派发事件，需要向上找到指定 name 的组件实例，利用我们前文提到的 $emit方法做派送，所以在指定组件就可以用 $on 来监听了。所以 dispatch 本质上就是向上查找到指定组件并触发其自身的 $emit，以此来做响应，broadcast 则相反。那么如何做到跨级查找呢？12345678910111213141516171819202122232425262728293031function broadcast(componentName, eventName, params) &#123; this.$children.forEach(child =&gt; &#123; // 遍历所有的 $children var name = child.$options.name; // 拿到实例的name，Element 此处用的 componentName if (name === componentName) &#123; // 如果是想要的那个，进行广播 child.$emit.apply(child, [eventName].concat(params)); &#125; else &#123; // 不是则递归查找 直到 $children 为 [] broadcast.apply(child, [componentName, eventName].concat([params])); &#125; &#125;);&#125;export default &#123; methods: &#123; dispatch(componentName, eventName, params) &#123; var parent = this.$parent || this.$root; var name = parent.$options.name; while (parent &amp;&amp; (!name || name !== componentName)) &#123; // 存在 parent 且 (不存在 name 或 name 和 指定参数不一样) 则继续查找 parent = parent.$parent; // 不存在继续取上级 if (parent) &#123; name = parent.$options.name; // 存在上级 再次赋值并再次循环，进行判断 &#125; &#125; if (parent) &#123; // 找到以后 如果有 进行事件派发 parent.$emit.apply(parent, [eventName].concat(params)); &#125; &#125;, broadcast(componentName, eventName, params) &#123; broadcast.call(this, componentName, eventName, params); &#125; &#125;&#125;; 以上是详细的 emitter.js，可以看见，这和我们之前讲到的 $parent、$children、$emit、$on都密切相关。这也是为什么把它放到后面讲的原因。之前说过，派发和广播并没有解决兄弟组件通信的问题，所以这里大家也可以拓展思考一下，如何支持兄弟组件间通信。依然是依赖于$parent、$children，可以找到任意指定组件。 总结本期文章内容到这里就讲完了，我们来总结回顾一下： 子组件触达父组件的方式：Props、$parent、$attrs、$listeners、provide 和 inject、$dispatch 父组件触达子组件的方式：$emit 和 $on、$children、$ref、broadcast 全局通信：EventBus、Vuex 转载：Vue 组件间通信方式完整版]]></content>
  </entry>
  <entry>
    <title><![CDATA[async/await]]></title>
    <url>%2F2019%2F04%2F13%2Fasync-await%2F</url>
    <content type="text"><![CDATA[关于async/await执行顺序首先是因为一个关于事件循环的面试题 1234567891011121314151617181920212223242526272829303132333435async function async1() &#123; console.log(&apos;async1 start&apos;); await async2(); console.log(&apos;async1 end&apos;);&#125;async function async2() &#123; console.log(&apos;async2&apos;);&#125;console.log(&apos;script start&apos;);setTimeout(function() &#123; console.log(&apos;setTimeout&apos;);&#125;, 0)async1();new Promise(function(resolve) &#123; console.log(&apos;promise1&apos;); resolve();&#125;).then(function() &#123; console.log(&apos;promise2&apos;);&#125;);console.log(&apos;script end&apos;);/*script startasync1 startasync2promise1script endasync1 endpromise2setTimeout*/ 说一下宏任务可以理解是每次执行栈执行的代码就是一个宏任务。浏览器为了能够使得js内部宏任务与DOM任务能够有序的执行，会在一个(macro)task执行结束后，在下一个(macro)task 执行开始前，对页面进行重新渲染，流程为：(macro)task -&gt; 渲染 -&gt;(macro)task-&gt;... (macro)task主要包含：script(整体代码)、setTimeout、setInterval、I/O、UI交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境) 说一下微任务microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前task任务后，下一个task之前，在渲染之前。 所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染。也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）。 microtask主要包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境) 执行（每个）宏任务之前都会检查有没有微任务需要执行，如果有就会把微任务执行了再执行。 Promise和async中的立即执行Promise中的异步体现在then和catch中，所以写在Promise中的代码是被当做同步任务立即执行的。而在async/await中，在出现await出现之前，其中的代码也是立即执行的。 await做了什么从字面意思上看await就是等待，await 等待的是一个表达式，这个表达式的返回值可以是一个promise对象也可以是其他值。 很多人以为await会一直等待之后的表达式执行完之后才会继续执行后面的代码，实际上await是一个让出线程的标志。await后面的表达式会先执行一遍，将await后面的代码加入到microtask中(因为async await本身就是promise+generator的语法糖)，然后就会跳出整个async函数来执行后面的代码。所以题中12345async function async1() &#123; console.log(&apos;async1 start&apos;); await async2(); console.log(&apos;async1 end&apos;);&#125; 等价于123456async function async1() &#123; console.log(&apos;async1 start&apos;); Promise.resolve(async2()).then(() =&gt; &#123; console.log(&apos;async1 end&apos;); &#125;)&#125; 所以本题的执行顺序为：执行script start-&gt;遇到setTimeout,将它放入宏任务队列中-&gt;遇到async1(),执行它的同步代码,async1 start以及跟在await屁股后面的代码，这里是个函数async2(),执行async2,后面那句console.log(‘async1 end’)则被让出线程放入微任务队列中-&gt;继续执行promise中的同步代码promise1,.then后的代码放出微任务队列中-&gt;继续执行script end-&gt;同步代码执行完毕，再执行异步代码，先微任务队列中的async1 end再promise2,最后宏任务队列中的setTimeout。即为：script start -- async1 start -- async2 --promise1 -- script end -- aync1 end -- promise2 -- setTimeout 再做几个题:1234567891011121314151617181920212223242526272829async function async1() &#123; console.log(&apos;async1 start&apos;); await async2(); console.log(&apos;async1 end&apos;);&#125;async function async2() &#123; //async2做出如下更改： new Promise(function(resolve) &#123; console.log(&apos;promise1&apos;); resolve();&#125;).then(function() &#123; console.log(&apos;promise2&apos;); &#125;);&#125;console.log(&apos;script start&apos;);setTimeout(function() &#123; console.log(&apos;setTimeout&apos;);&#125;, 0)async1();new Promise(function(resolve) &#123; console.log(&apos;promise3&apos;); resolve();&#125;).then(function() &#123; console.log(&apos;promise4&apos;);&#125;);console.log(&apos;script end&apos;); 根据以上的分析很容易得出：123456789script startasync1 startpromise1promise3script endpromise2async1 endpromise4setTimeout 12345678910111213141516171819202122232425262728async function async1() &#123; console.log(&apos;async1 start&apos;); await async2(); //更改如下： setTimeout(function() &#123; console.log(&apos;setTimeout1&apos;) &#125;,0)&#125;async function async2() &#123; //更改如下： setTimeout(function() &#123; console.log(&apos;setTimeout2&apos;) &#125;,0)&#125;console.log(&apos;script start&apos;);setTimeout(function() &#123; console.log(&apos;setTimeout3&apos;);&#125;, 0)async1();new Promise(function(resolve) &#123; console.log(&apos;promise1&apos;); resolve();&#125;).then(function() &#123; console.log(&apos;promise2&apos;);&#125;);console.log(&apos;script end&apos;); 结果：12345678script startasync1 startpromise1script endpromise2setTimeout3setTimeout2setTimeout1 123456789101112131415161718192021222324252627282930313233async function a1 () &#123; console.log(&apos;a1 start&apos;) await a2() console.log(&apos;a1 end&apos;)&#125;async function a2 () &#123; console.log(&apos;a2&apos;)&#125;console.log(&apos;script start&apos;)setTimeout(() =&gt; &#123; console.log(&apos;setTimeout&apos;)&#125;, 0)Promise.resolve().then(() =&gt; &#123; console.log(&apos;promise1&apos;)&#125;)a1()let promise2 = new Promise((resolve) =&gt; &#123; resolve(&apos;promise2.then&apos;) console.log(&apos;promise2&apos;)&#125;)promise2.then((res) =&gt; &#123; console.log(res) Promise.resolve().then(() =&gt; &#123; console.log(&apos;promise3&apos;) &#125;)&#125;)console.log(&apos;script end&apos;) 结果：12345678910script starta1 starta2promise2script endpromise1a1 endpromise2.thenpromise3setTimeout 主要内容 async做了一件什么事情？ await在等什么？ await等到之后，做了一件什么事情？ async/await比promise有哪些优势？ async做了一件什么事情？ 一句话概括：带 async 关键字的函数，它使得你的函数的返回值必定是 promise 对象也就是 如果async关键字函数返回的不是promise，会自动用Promise.resolve()包装 如果async关键字函数显式地返回promise，那就以你返回的promise为准 这是一个简单的例子，可以看到 async 关键字函数和普通函数的返回值的区别1234567891011121314async function fn1()&#123; return 123&#125;function fn2()&#123; return 123&#125;console.log(fn1())console.log(fn2())Promise &#123;&lt;resolved&gt;: 123&#125;123 所以你看，async 函数也没啥了不起的，以后看到带有 async 关键字的函数也不用慌张，你就想它无非就是把return值包装了一下，其他就跟普通函数一样。关于async关键字还有那些要注意的？ 在语义上要理解，async表示函数内部有异步操作 另外注意，一般 await 关键字要在 async 关键字函数的内部，await 写在外面会报错。 await在等什么？ 一句话概括： await等的是右侧「表达式」的结果也就是说， 右侧如果是函数，那么函数的return值就是「表达式的结果」 右侧如果是一个 ‘hello’ 或者什么值，那表达式的结果就是 ‘hello’12345678910async function async1() &#123; console.log( &apos;async1 start&apos; ) await async2() console.log( &apos;async1 end&apos; )&#125;async function async2() &#123; console.log( &apos;async2&apos; )&#125;async1()console.log( &apos;script start&apos; ) await会让出线程，阻塞后面的代码，那么是怎么让出线程呢？‘async2’和’script start’谁会先打印呢？语句 await async2()是怎么执行呢？实践结论是，从右往左执行，先执行async2后，发现有await关键字，于是让出线程，阻塞代码 await等到之后，做了一件什么事情？ 那么await右侧表达式的结果就是它要等的东西。等到之后，对于await来说，分2个情况 不是promise对象 是promise对象 如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。 看到上面的阻塞一词，心慌了吧……放心，这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。 async/await比promise有哪些优势？ async/await 的优势在于处理 then 链。单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 传入参数 n，表示这个函数执行的时间（毫秒） * 执行的结果是 n + 200，这个值将用于下一步骤 */function takeLongTime(n) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(n + 200), n); &#125;);&#125;function step1(n) &#123; console.log(`step1 with $&#123;n&#125;`); return takeLongTime(n);&#125;function step2(n) &#123; console.log(`step2 with $&#123;n&#125;`); return takeLongTime(n);&#125;function step3(n) &#123; console.log(`step3 with $&#123;n&#125;`); return takeLongTime(n);&#125;现在用 Promise 方式来实现这三个步骤的处理function doIt() &#123; console.time(&quot;doIt&quot;); const time1 = 300; step1(time1) .then(time2 =&gt; step2(time2)) .then(time3 =&gt; step3(time3)) .then(result =&gt; &#123; console.log(`result is $&#123;result&#125;`); console.timeEnd(&quot;doIt&quot;); &#125;);&#125;doIt();// step1 with 300// step2 with 500// step3 with 700// result is 900// doIt: 1507.251ms输出结果 result 是 step3() 的参数 700 + 200 = 900。doIt() 顺序执行了三个步骤，一共用了 300 + 500 + 700 = 1500 毫秒，和 console.time()/console.timeEnd() 计算的结果一致。如果用 async/await 来实现呢，会是这样async function doIt() &#123; console.time(&quot;doIt&quot;); const time1 = 300; const time2 = await step1(time1); const time3 = await step2(time2); const result = await step3(time3); console.log(`result is $&#123;result&#125;`); console.timeEnd(&quot;doIt&quot;);&#125;doIt();结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样 参考：理解 JavaScript 的 async/await关于第10题的一些见解]]></content>
  </entry>
</search>
