<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue组件通信]]></title>
    <url>%2F2019%2F04%2F17%2Fvue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[组件 组件是可以复用的Vue实例 在Vue中，根据注册方式的不同，可以分为： 局部组件（局部注册） 全局组件（全局注册） 顾名思义，全局注册的组件，可以用在 Vue 实例的任意模板中。但是带来的隐患是，在 webpack 模块化构建时，即便你没有在项目中使用这个组件，依然会打包到最终的项目代码中。而局部组件，则需要在使用到的实例中注册该组件。1234567891011121314151617181920212223// 全局注册// install.jsimport Icon from &apos;./Icon.vue&apos;;const install = &#123; install:function(Vue)&#123; Vue.component(&apos;VIcon&apos;, Icon); &#125;&#125;;export default install;// main.jsimport install from &apos;./install.js&apos;; // 引入全局插件Vue.use(install); // 注册// 局部注册import VIcon from &apos;./Icon.vue&apos;;export default&#123; components: &#123; VIcon &#125;&#125;// 使用&lt;v-icon&gt; &lt;/v-icon&gt; 根据应用场景的不同，又可以分为： 页面组件：我们使用 Vue 时，每个路由代表的页面，都可以称之为组件。 基础组件：就像上面栗子中的 Icon 组件，就是一个典型的基础组件。基本上不掺杂业务逻辑，在项目中可能被大量使用，易于移植。类似的基础组件还有 Button、Input 等，常见于各类 UI 组件库。 业务组件：业务组件和项目具体的业务逻辑有大量耦合，一般抽离于当前项目。 以上就是组件的简单介绍，那我们到底为什么要推崇组件化？组件化有什么好处？复用？我个人认为组件化最大的好处，便是解耦，易于项目管理。所以在大型项目管理中，组件化是非常有必要的。当然，这并不是今天学习的重点，以后有机会再聊。正因为在 Vue 中处处都是组件，而我们也偏向于组件化、模块化。那我们在一堆组件中，便需要解决一个问题 — 组件间通信。下面，我们就进入今天的主题，Vue 的组件间通信。 组件间通信 PropsVue 中，最基本的通信方式就是 Props，它是父子组件通信中父组件传值给子组件的一种方式。它允许以数组形式接收，但是更推荐你开启类型检查的形式1234567891011121314151617181920212223242526//communication.vue&lt;communication-sub v-bind=&quot;dataProps&quot;&gt;&lt;/communication-sub&gt;//v-bind=&quot;dataProps&quot;等同于:title=&quot;title&quot;，适用于多个参数一起传递...data()&#123; return &#123; dataProps:&#123; title:&apos;我是父组件的值&apos; &#125; &#125;&#125;//communication-sub.vue&lt;div class=&quot;communication-sub&quot;&gt; &#123;&#123;title&#125;&#125;&lt;/div&gt;...props:[&apos;title&apos;]//更推荐开启类型检查props:&#123; title:&#123; type:String, required:true, default:&apos;&apos;//允许指定默认值，引用类型需要函数返回 &#125;&#125;... 我们都知道，Props 是单向数据流，这是 Vue 为了避免子组件意外改变父组件的状态，从而导致数据流向难以理解而做出的限制。所以 Vue 推荐需要改动的时候，通过改变父组件的值从而触发 Props 的响应。或者，我们可以在接收非引用类型的值时，使用子组件自身的 data 做一次接收。123456props: [&apos;title&apos;],data: function () &#123; return &#123; text: this.title &#125;;&#125; 为什么是非引用类型呢，因为在 JavaScript 中，引用类型的赋值，实际是内存地址的传递。所以上面栗子中的简单赋值，显然会指向同一个内存地址，所以如果是数组或是对象，你可能需要一次深拷贝。1let obj = JSON.parse(JSON.stringify(obj)); 上面这个操作有一些缺陷，不能序列化函数、undefined、循环引用等.事实上，在 Props 是引用类型时，单独修改对象、数组的某个属性或下标，Vue 并不会抛出错误。当然，前提是你要非常清楚自己在做什么，并写好注释，防止你的小伙伴们疑惑。有的同学可能知道，在组件上绑定的属性，如果没有在组件内部用 Props 声明，会默认绑定到组件的根元素上去。还是之前的栗子：1&lt;communication-sub v-bind=&quot;dataProps&quot; class=&quot;one&quot; type=&quot;div&quot;&gt;&lt;/communication-sub&gt; 这是 Vue 默认处理的，而且，除了 class 和 style 采用合并策略，其它特性（如上栗 type）会替换掉原来根元素上的属性值。当然，我们也可以显示的在组件内部关闭掉这个特性：123...inheritAttrs: false,props: [&apos;title&apos;] 利用 inheritAttrs，我们还可以方便的把组件绑定的其它特性，转移到我们指定的元素上。这就需要用到下一个我们要讲的 $attrs 了。 attrs,listeners我们在使用组件库的时候经常会这么写：1&lt;el-input v-model=&quot;input&quot; placeholder=&quot;请输入内容&quot;&gt;&lt;/el-input&gt; 实际渲染后：可以看到我们指定的的 placeholder 是渲染在 input 上的，但是 input 并不是根元素。难道都用 Props 声明后，再赋值给 input？这种情况就可以用到 $attrs 了，改造一下我们之前那个栗子。123456789101112131415161718192021222324252627282930313233// communication.vue&lt;template&gt; &lt;div class=&quot;communication&quot;&gt; &lt;communication-sub v-bind=&quot;dataProps&quot; class=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;请输入内容&quot;&gt; &lt;/communication-sub&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import communicationSub from &apos;./communication-sub.vue&apos;;export default&#123; name: &apos;communication&apos;, data() &#123; return &#123; dataProps: &#123; title: &apos;我是 communication 的值&apos;, &#125; &#125; &#125;, components: &#123; communicationSub &#125;&#125;&lt;/script&gt;// communication-sub.vue···&lt;div class=&quot;communication-sub&quot;&gt; &lt;input v-bind=&quot;$attrs&quot; v-model=&quot;title&quot;&gt;&lt;/input&gt;&lt;/div&gt;··· export default &#123; inheritAttrs: false&#125; 可以看到，type 已经转移到了子元素 input 标签上，但是 class 没有。这是因为 inheritAttrs: false选项不会影响 style 和 class 的绑定。可以看出 $attrs则是将没有被组件内部 Props 声明的传值（也叫非 Props 特性）收集起来的一个对象，再通过 v-bind 将其绑定在指定元素上。这也是 Element 等组件库采用的策略。这里需要注意一点，通过 $attrs 指定给元素的属性，不会与该元素原有属性发生合并或替换，而是以原有属性为准。举个例子，假如我将上述 input 的 type 默认设置为 password。1&lt;input v-bind=&quot;$attrs&quot; v-model=&quot;title&quot; type=&quot;password&quot;&gt;&lt;/input&gt; 则不会采用 $attrs 中的 type: ‘text’，将以 password 为准，所以如果需要默认值的属性，建议不要用这种方式。]]></content>
  </entry>
  <entry>
    <title><![CDATA[async/await]]></title>
    <url>%2F2019%2F04%2F13%2Fasync-await%2F</url>
    <content type="text"><![CDATA[关于async/await执行顺序首先是因为一个关于事件循环的面试题 1234567891011121314151617181920212223242526272829303132333435async function async1() &#123; console.log(&apos;async1 start&apos;); await async2(); console.log(&apos;async1 end&apos;);&#125;async function async2() &#123; console.log(&apos;async2&apos;);&#125;console.log(&apos;script start&apos;);setTimeout(function() &#123; console.log(&apos;setTimeout&apos;);&#125;, 0)async1();new Promise(function(resolve) &#123; console.log(&apos;promise1&apos;); resolve();&#125;).then(function() &#123; console.log(&apos;promise2&apos;);&#125;);console.log(&apos;script end&apos;);/*script startasync1 startasync2promise1script endasync1 endpromise2setTimeout*/ 说一下宏任务可以理解是每次执行栈执行的代码就是一个宏任务。浏览器为了能够使得js内部宏任务与DOM任务能够有序的执行，会在一个(macro)task执行结束后，在下一个(macro)task 执行开始前，对页面进行重新渲染，流程为：(macro)task -&gt; 渲染 -&gt;(macro)task-&gt;... (macro)task主要包含：script(整体代码)、setTimeout、setInterval、I/O、UI交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境) 说一下微任务microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前task任务后，下一个task之前，在渲染之前。 所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染。也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）。 microtask主要包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境) 执行（每个）宏任务之前都会检查有没有微任务需要执行，如果有就会把微任务执行了再执行。 Promise和async中的立即执行Promise中的异步体现在then和catch中，所以写在Promise中的代码是被当做同步任务立即执行的。而在async/await中，在出现await出现之前，其中的代码也是立即执行的。 await做了什么从字面意思上看await就是等待，await 等待的是一个表达式，这个表达式的返回值可以是一个promise对象也可以是其他值。 很多人以为await会一直等待之后的表达式执行完之后才会继续执行后面的代码，实际上await是一个让出线程的标志。await后面的表达式会先执行一遍，将await后面的代码加入到microtask中(因为async await本身就是promise+generator的语法糖)，然后就会跳出整个async函数来执行后面的代码。所以题中12345async function async1() &#123; console.log(&apos;async1 start&apos;); await async2(); console.log(&apos;async1 end&apos;);&#125; 等价于123456async function async1() &#123; console.log(&apos;async1 start&apos;); Promise.resolve(async2()).then(() =&gt; &#123; console.log(&apos;async1 end&apos;); &#125;)&#125; 所以本题的执行顺序为：执行script start-&gt;遇到setTimeout,将它放入宏任务队列中-&gt;遇到async1(),执行它的同步代码,async1 start以及跟在await屁股后面的代码，这里是个函数async2(),执行async2,后面那句console.log(‘async1 end’)则被让出线程放入微任务队列中-&gt;继续执行promise中的同步代码promise1,.then后的代码放出微任务队列中-&gt;继续执行script end-&gt;同步代码执行完毕，再执行异步代码，先微任务队列中的async1 end再promise2,最后宏任务队列中的setTimeout。即为：script start -- async1 start -- async2 --promise1 -- script end -- aync1 end -- promise2 -- setTimeout 再做几个题:1234567891011121314151617181920212223242526272829async function async1() &#123; console.log(&apos;async1 start&apos;); await async2(); console.log(&apos;async1 end&apos;);&#125;async function async2() &#123; //async2做出如下更改： new Promise(function(resolve) &#123; console.log(&apos;promise1&apos;); resolve();&#125;).then(function() &#123; console.log(&apos;promise2&apos;); &#125;);&#125;console.log(&apos;script start&apos;);setTimeout(function() &#123; console.log(&apos;setTimeout&apos;);&#125;, 0)async1();new Promise(function(resolve) &#123; console.log(&apos;promise3&apos;); resolve();&#125;).then(function() &#123; console.log(&apos;promise4&apos;);&#125;);console.log(&apos;script end&apos;); 根据以上的分析很容易得出：123456789script startasync1 startpromise1promise3script endpromise2async1 endpromise4setTimeout 12345678910111213141516171819202122232425262728async function async1() &#123; console.log(&apos;async1 start&apos;); await async2(); //更改如下： setTimeout(function() &#123; console.log(&apos;setTimeout1&apos;) &#125;,0)&#125;async function async2() &#123; //更改如下： setTimeout(function() &#123; console.log(&apos;setTimeout2&apos;) &#125;,0)&#125;console.log(&apos;script start&apos;);setTimeout(function() &#123; console.log(&apos;setTimeout3&apos;);&#125;, 0)async1();new Promise(function(resolve) &#123; console.log(&apos;promise1&apos;); resolve();&#125;).then(function() &#123; console.log(&apos;promise2&apos;);&#125;);console.log(&apos;script end&apos;); 结果：12345678script startasync1 startpromise1script endpromise2setTimeout3setTimeout2setTimeout1 123456789101112131415161718192021222324252627282930313233async function a1 () &#123; console.log(&apos;a1 start&apos;) await a2() console.log(&apos;a1 end&apos;)&#125;async function a2 () &#123; console.log(&apos;a2&apos;)&#125;console.log(&apos;script start&apos;)setTimeout(() =&gt; &#123; console.log(&apos;setTimeout&apos;)&#125;, 0)Promise.resolve().then(() =&gt; &#123; console.log(&apos;promise1&apos;)&#125;)a1()let promise2 = new Promise((resolve) =&gt; &#123; resolve(&apos;promise2.then&apos;) console.log(&apos;promise2&apos;)&#125;)promise2.then((res) =&gt; &#123; console.log(res) Promise.resolve().then(() =&gt; &#123; console.log(&apos;promise3&apos;) &#125;)&#125;)console.log(&apos;script end&apos;) 结果：12345678910script starta1 starta2promise2script endpromise1a1 endpromise2.thenpromise3setTimeout 主要内容 async做了一件什么事情？ await在等什么？ await等到之后，做了一件什么事情？ async/await比promise有哪些优势？ async做了一件什么事情？ 一句话概括：带 async 关键字的函数，它使得你的函数的返回值必定是 promise 对象也就是 如果async关键字函数返回的不是promise，会自动用Promise.resolve()包装 如果async关键字函数显式地返回promise，那就以你返回的promise为准 这是一个简单的例子，可以看到 async 关键字函数和普通函数的返回值的区别1234567891011121314async function fn1()&#123; return 123&#125;function fn2()&#123; return 123&#125;console.log(fn1())console.log(fn2())Promise &#123;&lt;resolved&gt;: 123&#125;123 所以你看，async 函数也没啥了不起的，以后看到带有 async 关键字的函数也不用慌张，你就想它无非就是把return值包装了一下，其他就跟普通函数一样。关于async关键字还有那些要注意的？ 在语义上要理解，async表示函数内部有异步操作 另外注意，一般 await 关键字要在 async 关键字函数的内部，await 写在外面会报错。 await在等什么？ 一句话概括： await等的是右侧「表达式」的结果也就是说， 右侧如果是函数，那么函数的return值就是「表达式的结果」 右侧如果是一个 ‘hello’ 或者什么值，那表达式的结果就是 ‘hello’12345678910async function async1() &#123; console.log( &apos;async1 start&apos; ) await async2() console.log( &apos;async1 end&apos; )&#125;async function async2() &#123; console.log( &apos;async2&apos; )&#125;async1()console.log( &apos;script start&apos; ) await会让出线程，阻塞后面的代码，那么是怎么让出线程呢？‘async2’和’script start’谁会先打印呢？语句 await async2()是怎么执行呢？实践结论是，从右往左执行，先执行async2后，发现有await关键字，于是让出线程，阻塞代码 await等到之后，做了一件什么事情？ 那么await右侧表达式的结果就是它要等的东西。等到之后，对于await来说，分2个情况 不是promise对象 是promise对象 如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。 看到上面的阻塞一词，心慌了吧……放心，这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。 async/await比promise有哪些优势？ async/await 的优势在于处理 then 链。单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 传入参数 n，表示这个函数执行的时间（毫秒） * 执行的结果是 n + 200，这个值将用于下一步骤 */function takeLongTime(n) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(n + 200), n); &#125;);&#125;function step1(n) &#123; console.log(`step1 with $&#123;n&#125;`); return takeLongTime(n);&#125;function step2(n) &#123; console.log(`step2 with $&#123;n&#125;`); return takeLongTime(n);&#125;function step3(n) &#123; console.log(`step3 with $&#123;n&#125;`); return takeLongTime(n);&#125;现在用 Promise 方式来实现这三个步骤的处理function doIt() &#123; console.time(&quot;doIt&quot;); const time1 = 300; step1(time1) .then(time2 =&gt; step2(time2)) .then(time3 =&gt; step3(time3)) .then(result =&gt; &#123; console.log(`result is $&#123;result&#125;`); console.timeEnd(&quot;doIt&quot;); &#125;);&#125;doIt();// step1 with 300// step2 with 500// step3 with 700// result is 900// doIt: 1507.251ms输出结果 result 是 step3() 的参数 700 + 200 = 900。doIt() 顺序执行了三个步骤，一共用了 300 + 500 + 700 = 1500 毫秒，和 console.time()/console.timeEnd() 计算的结果一致。如果用 async/await 来实现呢，会是这样async function doIt() &#123; console.time(&quot;doIt&quot;); const time1 = 300; const time2 = await step1(time1); const time3 = await step2(time2); const result = await step3(time3); console.log(`result is $&#123;result&#125;`); console.timeEnd(&quot;doIt&quot;);&#125;doIt();结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样]]></content>
  </entry>
</search>
