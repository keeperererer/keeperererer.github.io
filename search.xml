<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[fetch]]></title>
    <url>%2F2019%2F09%2F05%2Ffetch%2F</url>
    <content type="text"><![CDATA[使用 Fetch fetch 如何请求数据从ajax到fetch、axios]]></content>
  </entry>
  <entry>
    <title><![CDATA[离线缓存技术]]></title>
    <url>%2F2019%2F09%2F04%2F%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[用途当客户端本地与web应用程序的服务器没有建立连接时，也能正常在客户端本地使用该web应用程序进行有关操作。文件等放在本地缓存中，当服务器没有和Internet建立连接时，也可以利用本地缓存中的资源文件正常运行web应用程序。 本地缓存与浏览器网页缓存的区别 本地缓存为整个web应用程序服务的，而浏览器的网页缓存只存在单个网页。 网页缓存不安全不可靠，因为我们不知道在网站中到底缓存了哪些网页，以及缓存了网页上的哪些资源。而本地缓存可靠，我们可以控制对哪些内容进行缓存，不对哪些内容进行缓存，开发人员还可以利用编程的手段来控制缓存的更新，利用缓存对象的各种属性、状态和事件来开发出更加强大的离线应用程序。 如何实现离线缓存 创建一个cache.manifest文件，并确保文件具有正确的内容 在服务器上设置内容类型 所有的html文件都指向cache.manifest 分析： cache.manifest文件1234567891011121314151617181920CACHE MANIFEST#version1CACHE:index.html404.htmlfavicon.icorobots.txthumans.txtapple-touch-icon.pngcss/normalize.min.csscss/main.csscss/bootmetro-icons.min.cssimg/pho-cat.jpgimg/pho-huangshan.jpg FALLBACK:online.js local.js NETWORK:* 注意事项： 1、第一行必须是”CACHE DMANIFEST”文字，以把本文件的作用告知浏览器，即对本地缓存中的资源文件进行具体设置。 2、在manifest文件中，可以加上注释来进行一些必要说明或解释。注释行以”#”文字开头。 3、在CACHE之后的部分为列出我们需要缓存的文件。 4、在FALLBACK之后的部分每一行中指定两个资源文件，第一个资源文件为能够在线访问时使用的资源文件，第二个资源文件为 不能在线访问时使用的备用资源文件。 5、在NETWORK之后可以指定在线白名单，即列出我们不希望离线存储的文件，因为通常它们的内容需要互联网访问才有意义。 另外，在此部分我们可以使用快捷方式：通配符*。这将告诉浏览器，应用服务器中获取没有在显示部分中提到的任何文件或URL。 服务器上设置内容类型让服务器支持text/cache-manifest这个MIME类型 设置HTML文件的指向1&lt;html manifest=”/cache.manifest” &gt; 注意事项：1、网站的每一个html页面都必须设置html元素的manifest属性。Must to do； 2、在你的整个网站应用中，只能有一个cache.manifest文件（建议放在网站根目录下）； 3、部分浏览器（如IE8-）不支持HTML5离线缓存； 4、“#” 开头的注释行可满足其他用途。应用的缓存会在其 manifest 文件更改时被更新。如果您编辑了一幅图片，或者修改了一个 JavaScript 函数， 这些改变都不会被重新缓存。更新注释行中的日期和版本号是一种使浏览器重新缓存文件的办法。 更新1.自动更新：浏览器除了在第一次访问 Web 应用时缓存资源外，只会在 cache manifest 文件本身发生变化（即使是注释变化）时更新缓存。而 cache manifest 中的资源文件发生变化并不会触发更新。2.手动更新：开发者也可以使用 window.applicationCache 的接口更新缓存。方法是检测 window.applicationCache.status 的值，如果是 UPDATEREADY，那么可以调用 window.applicationCache.update() 更新缓存。示范代码如下。123if (window.applicationCache.status == window.applicationCache.UPDATEREADY) ｛ window.applicationCache.update(); ｝]]></content>
  </entry>
  <entry>
    <title><![CDATA[移动端页面适配方案]]></title>
    <url>%2F2019%2F09%2F02%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B5%E9%9D%A2%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[适配的目标 在不同尺寸的手机设备上，页面“相对性的达到合理的展示(自适应)”，或者“保持统一效果的等比缩放(看起来差不多)”。 概念理解viewport视口viewport是严格的等于浏览器的窗口。 先看看大佬们的文章,再自己好好总结 移动端适配方案(上) 移动端适配方案(下)使用Flexible实现手淘H5页面的终端适配移动前端开发之viewport的深入理解 移动端图片模糊问题移动端1px误差的原因以及解决方案移动端300ms延迟的解决方法]]></content>
  </entry>
  <entry>
    <title><![CDATA[z-index]]></title>
    <url>%2F2019%2F08%2F31%2Fz-index%2F</url>
    <content type="text"><![CDATA[z-index的默认值是auto;同级元素之间的比较：z-index:0的层叠关系大于z-index:auto;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中的computed实现原理]]></title>
    <url>%2F2019%2F08%2F31%2FVue%E4%B8%AD%E7%9A%84computed%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[computed运行原理 computed的属性是动态挂载到vm实例上的，和普通的响应式数据在data里声明不同。 设置computed的getter，如果执行了computed对应的函数，由于函数会读取data属性值，因此又会触发data属性值的getter函数，在这个执行过程中就可以处理computed相对于data的依赖收集关系。 首次计算computed的值时，会执行vm.computed属性对应的getter函数(用户指定的computed函数，如果没有设置getter，那么将当前指定的函数赋值computed属性的getter)，进行上述的依赖收集 如果computed的属性值又依赖了其他computed计算属性值，那么会将当前target暂存到栈中，先进行其他computed计算属性值的依赖收集，等其他计算属性依赖收集完成后，再从栈中pop出来，继续进行当前computed的依赖收集123456789101112var vm = new Vue(&#123; el:'#demo', data:&#123; firstName:"Foo", lastName:"Bar" &#125;, computed:&#123; fullName:function()&#123; return this.firstName + " " +this.lastName &#125; &#125;&#125;) 由于this.firstName和this.lastName都是响应式变量，因此会触发它们的getter，根据我们之前的分析，它们会把自身持有的dep添加到当前正在计算的watcher中，这个时候Dep.target就是这个computed watcher,具体步骤如下： data属性初始化getter setter computed计算属性初始化，提供的函数将用作属性vm.fullName的getter 当首次获取fullName计算属性的值时，Dep开始依赖收集 在执行message getter方法时，如果Dep处于依赖收集状态，则判定firstName和lastName为fullName的依赖，并建立依赖关系 当firstName或lastName发生变化时，根据依赖关系，触发fullName的重新计算 如果计算值没有发生变化，不会触发视图更新 通过以上的分析，我们知道计算属性本质上就是一个 computed watcher，也了解了它的创建过程和被访问触发 getter 以及依赖更新的过程，其实这是最新的计算属性的实现，之所以这么设计是因为 Vue 想确保不仅仅是计算属性依赖的值发生变化，而是当计算属性最终计算的值发生变化才会触发渲染 watcher 重新渲染，本质上是一种优化。 watch的实现原理watch的分类： deep watch（深层次监听） user watch（用户监听） computed watcher（计算属性） sync watcher（同步监听） watch实现过程：watch的初始化在data初始化之后（此时的data已经通过Object.defineProperty的设置成响应式）watch的key会在Watcher里进行值的读取，也就是立马执行get获取value（从而实现data对应的key执行getter实现对于watch的依赖收集），此时如果有immediate属性那么立马执行watch对应的回调函数当data对应的key发生变化时，触发user watch实现watch回调函数的执行 原文]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小题]]></title>
    <url>%2F2019%2F08%2F27%2F%E5%B0%8F%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1 ~number = -number + 1eg: ~4 -&gt; -5 简单请求 请求方法是head,get,post之一 http的头信息不超出一下几种字段 Accept Accept-Language Content-Language Content-Type:只能取三个值application/x-www-form-urlencoded、multipart/form-data、text/plain Last-Event-ID 为什么不能在state里直接修改状态因为state是实时更新的，mutations无法进行异步操作，而如果直接修改state的话是能够异步操作的，当你异步对state进行操作时，还没执行完，这时候如果state已经在其他地方被修改了，这样就会导致程序存在问题了。所以state要同步操作，通过mutations的方式限制了不允许异步。 定义在data里的变量a,为什么可以直接this.a调用，而不是this.data.a(this.$data、this._data、this.xxx 为什么都能获取数据？)this.$data.xxx、this._data.xxx、this.xxx 都能获取数据，先让 this.$data.xxx = this._data.xxx，然后用 call 让当前组件实例 this 继承了 this.$data 的值，也就是 getData 方法 return 出了一份用 call 改变指向将 $data 指向 this 的数据。 data为什么是个函数？data 定义成一个函数，确保了各个组件实例能拥有一份只属于自己的唯一数据如果 data 是个对象，那么整个vue实例将共享一份数据，也就是各个组件实例间可以随意修改其他组件的任意值，这就很坑爹了。但是 data 定义成一个函数，将会 return 出一个唯一的对象，不会和其他组件共享一个对象。 使用Vuex只需执行 Vue.use(Vuex)，并在Vue的配置中传入一个store对象的示例，store是如何实现注入的？Vue.use(Vuex) 方法执行的是install方法，它实现了Vue实例对象的init方法封装和注入，使传入的store对象被设置到Vue上下文环境的$store中。因此在Vue Component任意地方都能够通过this.$store访问到该store。 state内部支持模块配置和模块嵌套，如何实现的？在store构造方法中有makeLocalContext方法，所有module都会有一个local context，根据配置时的path进行匹配。所以执行如dispatch(‘submitOrder’, payload)这类action时，默认的拿到都是module的local state，如果要访问最外层或者是其他module的state，只能从rootState按照path路径逐步进行访问。 在执行dispatch触发action(commit同理)的时候，只需传入(type, payload)，action执行函数中第一个参数store从哪里获取的？store初始化时，所有配置的action和mutation以及getters均被封装过。在执行如dispatch(‘submitOrder’, payload)的时候，actions中type为submitOrder的所有处理方法都是被封装后的，其第一个参数为当前的store对象，所以能够获取到 { dispatch, commit, state, rootState } 等数据。 Vuex如何区分state是外部直接修改，还是通过mutation方法修改的？Vuex中修改state的唯一渠道就是执行 commit(‘xx’, payload) 方法，其底层通过执行 this._withCommit(fn) 设置_committing标志变量为true，然后才能修改state，修改完毕还需要还原_committing变量。外部修改虽然能够直接修改state，但是并没有修改_committing标志位，所以只要watch一下state，state change时判断是否_committing值为true，即可判断修改的合法性。 调试时的”时空穿梭”功能是如何实现的？devtoolPlugin中提供了此功能。因为dev模式下所有的state change都会被记录下来，’时空穿梭’ 功能其实就是将当前的state替换为记录中某个时刻的state状态，利用 store.replaceState(targetState) 方法将执行this._vm.state = state 实现。 405 method not allowed问题原因： 请求的方式（get、post、delete）方法与后台规定的方式不符合。 比如： 后台方法规定的请求方式只接受get，如果用post请求，就会出现 405 method not allowed的提示 git fetch 与 git pull的区别git fetch 相当于是从远程获取最新到本地，不会自动merge git pull：相当于是从远程获取最新版本并merge到本地 在实际使用中，git fetch更安全一些]]></content>
  </entry>
  <entry>
    <title><![CDATA[屏幕，浏览器，页面宽高]]></title>
    <url>%2F2019%2F08%2F26%2F%E5%B1%8F%E5%B9%95%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%8C%E9%A1%B5%E9%9D%A2%E5%AE%BD%E9%AB%98%2F</url>
    <content type="text"><![CDATA[HTML 获取屏幕、浏览器、页面的高度宽度搞清clientHeight、offsetHeight、scrollHeight、offsetTop、scrollTopoffsetTop和scrollTop的区别 scrollHeightscrollHeight含有scroll当然这个高度与滚动相关。 读写：只读 描述：包括overflow样式属性导致的视图中不可见内容，没有垂直滚动条的情况下，scrollHeight值与元素视图填充所有内容所需要的最小值clientHeight相同。包括元素的padding，但不包括元素的margin. 拓展：判定元素是否滚动到底 如果元素滚动到底，下面等式返回true，没有则返回false. element.scrollHeight - element.scrollTop === element.clientHeight scrollTop 读写：可读可写 描述：这个Element.scrollTop 属性可以设置或者获取一个元素距离他容器顶部的像素距离。一个元素的 scrollTop 是可以去计算出这个元素距离它容器顶部的可见高度。当一个元素的容器没有产生垂直方向的滚动条,那它的 scrollTop 的值默认为0. 注意事项：scrollTop可以被设置任何的整数, 但以下情况会报错: 如果一个元素不能被滚动 (e.g. 它没有益处容器或者 这个元素是不可滚动的), scrollTop被设置为0. 设置scrollTop的值小于0，scrollTop 被设为0 如果设置了超出这个容器可滚动的值, scrollTop 会被设为最大值.]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS操作cookie]]></title>
    <url>%2F2019%2F08%2F26%2FJS%E6%93%8D%E4%BD%9Ccookie%2F</url>
    <content type="text"><![CDATA[js设置cookie 假设在A页面种要保存变量username的值(“jack”)到cookie种，key值为name，则相应的JS代码为：1document.cookie = "name=" + username; js读取cookie假设cookie中存储的内容为:name=jack;password=123则在B页面中获取变量username的值的JS代码如下：1var username = document.cookie.split(";")[0].split("=")[1]; JS操作cookies方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//写cookiesfunction setCookie(name,value)&#123; var Days = 30; var exp = new Date(); exp.setTime(exp.getTime() + Days*24*60*60*1000); document.cookie = name + "=" + escape(value) + ";expires=" + exp.toGMTString();&#125;//读取cookiesfunction getCookie(name)&#123; var arr ,reg = new RegExp("(^|)" + name + "=([^;]*)(;|$)"); if(arr = document.cookie.match(reg)) return unescape(arr[2]); else return null;&#125;//删除cookies function delCookie(name) &#123; var exp = new Date(); exp.setTime(exp.getTime() - 1); var cval=getCookie(name); if(cval!=null) document.cookie= name + "="+cval+";expires="+exp.toGMTString(); &#125; //使用示例 setCookie("name","hayden"); alert(getCookie("name")); //如果需要设定自定义过期时间 //那么把上面的setCookie 函数换成下面两个函数就ok; //程序代码 function setCookie(name,value,time)&#123; var strsec = getsec(time); var exp = new Date(); exp.setTime(exp.getTime() + strsec*1); document.cookie = name + "="+ escape (value) + ";expires=" + exp.toGMTString(); &#125; function getsec(str)&#123; alert(str); var str1=str.substring(1,str.length)*1; var str2=str.substring(0,1); if (str2=="s") &#123; return str1*1000; &#125; else if (str2=="h") &#123; return str1*60*60*1000; &#125; else if (str2=="d") &#123; return str1*24*60*60*1000; &#125; &#125; //这是有设定过期时间的使用示例： //s20是代表20秒 //h是指小时，如12小时则是：h12 //d是天数，30天则：d30 setCookie("name","hayden","s20"); Cookie属性 name字段：一个cookie的名称 value字段：一个cookie的值 domain字段：可以访问此cookie的域名 path字段：可以访问此cookie的页面路径 Size字段：此cookie大小 http字段：cookie的httponly属性，若此属性为True，则只有在http请求头中会有此cookie信息，而不能通过document.cookie来访问此cookie。 secure字段：设置是否只能通过https来传递此条cookie。 expires/Max-Age字段：设置cookie超时时间。如果设置的值为一个时间，则当到达该时间时此cookie失效。不设置的话默认是session，意思是cookie会和session一起失效，当浏览器关闭（并不是浏览器标签关闭，而是整个浏览器关闭）后，cookie失效。]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTTP1.0,HTTP1.1和HTTP2.0的区别]]></title>
    <url>%2F2019%2F08%2F24%2FHTTP1-0-HTTP1-1%E5%92%8CHTTP2-0%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[HTTP的基本优化 影响一个HTTP网络请求的因素主要有两个：带宽和延迟。 带宽：如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么久只剩下延迟了。 延迟: 浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。 DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。 建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。 HTTP1.0和HTTP1.1的一些区别 缓存处理,在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。 带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 Host头处理,在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。 长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。 HTTP2.0和HTTP1.X相比的新特性 新的二进制格式,HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。 多路复用，即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。 header压缩,如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。 服务端推送，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。没有服务端推送的就只能要什么请求什么，一个一个的来。 HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？ HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接； HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞； HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行。如图： HTTP2.0多路复用有多好？HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。 为什么需要头部压缩假定一个页面有100个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1kb的消息头（这同样也并不少见，因为Cookie和引用等东西的存在）, 则至少需要多消耗100kb来获取这些消息头。HTTP2.0可以维护一个字典，差量更新HTTP头部，大大降低因头部传输产生的流量。]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[长列表]]></title>
    <url>%2F2019%2F08%2F23%2F%E9%95%BF%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[先自己好好看看https://zhuanlan.zhihu.com/p/26022258https://zhuanlan.zhihu.com/p/34585166]]></content>
  </entry>
  <entry>
    <title><![CDATA[单页面应用和多页面应用]]></title>
    <url>%2F2019%2F08%2F21%2F%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E5%92%8C%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[单页面应用(SinglePage Web Application,SPA) 只有一张Web页面的应用，是一种从Web服务器加载的富客户端，单页面跳转仅刷新局部资源，公共资源(JS,CSS等)仅需加载一次，常用于PC端官网，购物等网站如图： 多页面应用(MultiPage Application,MPA)多页面跳转刷新所有资源，每个公共资源(JS,CSS等)需选择性重新加载，常用于app或客户端等如图： 具体对比分析： SPA设计原理kk这个：https://github.com/livoras/blog/issues/3]]></content>
  </entry>
  <entry>
    <title><![CDATA[事件模型]]></title>
    <url>%2F2019%2F08%2F21%2FJS%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[DOM 0级模型最简单且兼容所有浏览器的事件模型，有两种方式。默认发生在冒泡阶段。 HTML中直接绑定（不推荐） 1&lt;button id = "button" onclick="click()"&gt; CLickMe&lt;/button&gt; js指定属性值 1234var button = document.getElementById("button")button.onclick = function()&#123; //...&#125; DOM 2级模型属于W3C标准模型，先事件捕获，到达目标后再进行冒泡。兼容现代浏览器。12345var button = document.getElementById('button')button.addEventListener('click',function()&#123; //...&#125;,false)//DOM 2级事件第三个参数是一个布尔值(默认为false),true表示捕获阶段调用事件处理程序，false表示冒泡阶段调用事件处理程序 DOM 0级和DOM 2级事件模型比较 移除监听函数 123456//DOM 0button.onclick = null//DOM 2要跟绑定的格式完全一致button.removeEventListener('click',click,false)//addEventListener()添加的匿名函数无法移除 同时绑定多个监听器 123456789101112131415161718//DOM 0button.onclick = function()&#123; console.log(1)&#125;button.onclick = function()&#123; console.log(2)&#125;//2//DOM 2button.addEventListener('click',function()&#123; console.log(3)&#125;,false)button.addEventListener('click',function()&#123; console.log(4)&#125;,false)//3//4 可见DOM 0 后绑定的函数会把前边的替换掉，而DOM 2级可以同时绑定多个监听器，因此推荐使用addEventListener方法监听事件。监听函数内部的this都指向触发事件的那个元素节点1234567891011&lt;button id="button" onclick="console.log(this.id)"&gt;&lt;/button&gt;var button = document.getElementById("button")button.onclick = function() &#123; console.log(this.id)&#125;button.addEventListener('click', function() &#123; console.log(this.id)&#125;, false)//输出结果均为"button" 事件流首先我们要先了解一下事件流。事件流描述的是在页面中接受的事件顺序。看下面的例子123456789&lt;!-- HTML --&gt;&lt;div id="container"&gt; &lt;button id="button"&gt;&lt;/button&gt;&lt;/div&gt;//JSvar container = document.getElementById("container")var button = document.getElementById("button")button.onclick = function() &#123;alert('button!')&#125;container.onclick = function() &#123;alert('container!')&#125; 当你点击button按钮时，会发生在button按钮上的单击事件，但同时，你也单击了container元素甚至是单击了整个页面。JS事件模型是一种观察者模式（又叫发布订阅者模式），当对应的事件被触发时，监听该事件的所有监听函数都会被调用。因此，如果你单击的多个元素都绑定了相同事件，他们执行的事件顺序是怎么样的呢？ 事件流有两种： 事件冒泡：事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接受，然后逐渐向上传播到较不具体的那个节点。1&lt;button&gt; -&gt; &lt;#container&gt; -&gt; &lt;body&gt; -&gt; &lt;html&gt; -&gt; document 事件捕获：与事件冒泡相反。事件最开始由不太具体的节点最早接受事件, 而最具体的节点最后接受事件。1document -&gt; &lt;html&gt; -&gt; &lt;body&gt; -&gt; &lt;#container&gt; -&gt; &lt;button&gt; 在这个例子中，事件是通过DOM 0级事件（默认发生在冒泡阶段）添加的，所以弹出button!后弹出container!。 要让事件发生在捕获阶段也很简单1234567//DOM 2级事件第三个参数是一个布尔值（默认为false），true表示捕获阶段调用事件处理程序，false表示冒泡阶段调用事件处理程序。button.addEventListener('click', function()&#123; alert('button!')&#125;, true)container.addEventListener('click', function()&#123; alert('container!')&#125;, true) 事件对象触发DOM上的事件后，会产生一个事件对象event，作为参数传给监听函数。所有的事件都是这个事件对象的示例。 事件对象常用属性type 被触发的事件的类型target 事件的目标currentTarget 注册这个事件监听的对象事件对象常用方法preventDefault() 取消事件的默认行为stopPropagation() 阻止事件继续传播（冒泡和捕获），不包括在当前节点上其他的事件监听函数。stopImmediatePropagation() 阻止所有事件继续传播，包括在当前节点上其他的事件监听函数。了解更多事件对象的属性和方法 事件对象 看到这里，尝试一下实现页面内点击弹窗外部关闭弹窗，点击弹窗内部不会关闭弹窗。1234567891011121314&lt;body&gt; &lt;div id="pop-up-window"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var body = document.querySelector('body') var popUpWindow = document.getElementById('pop-up-window') body.addEventListener('click', function(e) &#123; popUpWindow.style.display = 'none' &#125;, false) popUpWindow.addEventListener('click', function(e) &#123; e.stopPropagation() //在弹窗内部点击时阻止事件传播，因此不会触发body的click事件 &#125;, false)&lt;/script&gt; 事件委托借助事件冒泡和事件对象，可以实现事件委托（又叫事件代理）。 先思考如何给下面的按钮都绑定一个click事件，点击后输出按钮的id1234567891011121314151617 &lt;div id="contiainer"&gt; &lt;button id="button1"&gt;button1&lt;/button&gt; &lt;button id="button2"&gt;button2&lt;/button&gt; &lt;button id="button3"&gt;button3&lt;/button&gt; &lt;!-- ... --&gt; &lt;button id="button10"&gt;button10&lt;/button&gt; &lt;/div&gt;//或许你或你以前会这么写for (var i = 1; i &lt;= 10; i++) &#123; document.getElementById("button" + i).addEventListener('click', function(e) &#123; console.log(e.target.id) &#125;, false)&#125;//每个函数都是对象，都会占用内存，现在创建了10个监听事件，影响了页面性能。我们利用事件委托（又叫事件代理）可以解决这个问题。事件委托借助事件冒泡和事件对象，只需要创建一个监听器，就可以管理一个类型的所有事件。只需要在DOM树尽量最高的层次创建一个监听。document.getElementById('container').addEventListener('click', function(e) &#123; if (e.target.tagName.toLowerCase() === 'button') console.log(e.target.id)&#125;, false)]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式跟发布-订阅模式]]></title>
    <url>%2F2019%2F08%2F15%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E8%B7%9F%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[区别： 在观察者模式中，观察者是知道Subject的，Subject一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。 在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。 观察者模式大多数时候是同步的，比如当事件触发，Subject就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）。 观察者模式需要在单个应用程序地址空间中实现，而发布-订阅更像交叉应用模式。 原文]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue的钩子函数]]></title>
    <url>%2F2019%2F08%2F15%2FVue%E7%9A%84%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Vue的钩子函数[路由导航守卫、keep-alive、生命周期钩子] Vue-Router导航守卫：全局守卫vue-router全局有三个守卫： router.beforeEach 全局前置守卫 进入路由之前 router.beforeResolve 全局解析守卫 在beforeRouteEnter调用之后调用 router.afterEach全局后置钩子 进入路由之后 使用方法:1234567891011// main.js 入口文件import router from './router'; // 引入路由router.beforeEach((to, from, next) =&gt; &#123; next();&#125;);router.beforeResolve((to, from, next) =&gt; &#123; next();&#125;);router.afterEach((to, from) =&gt; &#123; console.log('afterEach 全局后置钩子');&#125;); to,from,next这三个参数：to和from是将要进入和将要离开的路由对象,路由对象指的是平时通过this.$route获取到的路由对象。next:Function 这个参数是个函数，且必须调用，否则不能进入路由(页面空白)。 next() 进入该路由。 next(false): 取消进入路由，url地址重置为from路由地址(也就是将要离开的路由地址)。 next 跳转新路由，当前的导航被中断，重新开始一个新的导航。 123我们可以这样跳转：next('path地址')或者next(&#123;path:''&#125;)或者next(&#123;name:''&#125;)且允许设置诸如 replace: true、name: 'home' 之类的选项以及你用在router-link或router.push的对象选项。 路由独享守卫如果你不想全局配置守卫的话，你可以为某些路由单独配置守卫：123456789101112 const router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // 参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖 // ... &#125; &#125; ]&#125;) 路由组件内的守卫 https://juejin.im/post/5b41bdef6fb9a04fe63765f1]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目首页加载速度优化]]></title>
    <url>%2F2019%2F08%2F15%2Fvue%E9%A1%B9%E7%9B%AE%E9%A6%96%E9%A1%B5%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[原因vue首页加载过慢，其原因是因为它是一个单页应用，需要将所有需要的资源都下载到浏览器并解析。 解决办法 使用CDN资源,减小服务器带宽压力 路由懒加载 将一些静态js css放到其他地方（如OSS），减小服务器压力 按需加载三方资源，如iview,建议按需引入iview中的组件 使用nginx开启gzip减小网络传输的流量大小 若首屏为登录页，可以做成多入口，登录页单独分离为一个入口 使用uglifyjs-webpack-plugin插件代替webpack自带UglifyJsPlugin插件 使用CDN资源，减少服务器带宽压力 在index.html中引入cdn资源 1234567891011... &lt;body&gt; &lt;div id="app"&gt; &lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;script src="https://cdn.bootcss.com/vue/2.5.2/vue.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/vue-router/3.0.1/vue-router.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/vuex/3.0.1/vuex.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/vue-resource/1.5.1/vue-resource.min.js"&gt;&lt;/script&gt; &lt;/body&gt; ... 修改build/webpack.base.conf.js 12345678910111213module.exports = &#123; context: path.resolve(__dirname, '../'), entry: &#123; app: './src/main.js' &#125;, externals:&#123; 'vue': 'Vue', 'vue-router': 'VueRouter', 'vuex':'Vuex', 'vue-resource': 'VueResource' &#125;, ...&#125; 修改src/main.js src/router/index.js 注释掉import引入的vue,vue-resource 123// import Vue from 'vue'// import VueResource from 'vue-resource'// Vue.use(VueResource) 路由懒加载 require.ensure方式 12const workCircle = r =&gt; require.ensure([], () =&gt; r(require('@/module/work-circle/Index')), 'workCircle')const workCircleList = r =&gt; require.ensure([], () =&gt; r(require('@/module/work-circle/page/List')), 'workCircleList') import方式 1const workCircle = () =&gt; import('@/module/work-circle/Index') 将一些静态js css放到其他地方(如OSS),减少服务器压力这里的js文件，需要将结果抛出，然后在需要用到该js的组件中import引入 按需加载三方资源比如一些组件什么的，用到什么就加载什么，不要全部加载]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Service Worker]]></title>
    <url>%2F2019%2F08%2F11%2FWorker%2F</url>
    <content type="text"><![CDATA[Service Worker是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用Service Worker的话，传输协议必须为HTTPS。因为Service Worker中涉及到请求拦截，所以必须使用HTTPS协议来保障安全。 Service Worker实现缓存功能一般分为三个步骤：首先需要先注册Service Worker,然后监听到install事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。以下是这个步骤的实现：12345678910111213141516171819202122232425262728293031323334//index.js//navigator.serviceWorker提供对ServiceWorker 的注册，删除，升级和通信的访问。if(navigator.serviceWorker)&#123; navigator.serviceWorker .register('sw.js') .then(function(registration)&#123; console.log('service worker 注册成功') &#125;) .catch(function(err)&#123; console.log('service worker 注册失败') &#125;)&#125;//sw.js//监听'install'事件，回调中缓存所需文件self.addEventListener('install', e =&gt; &#123; e.waitUntil( cache.open('my-cache').then(function(cache)&#123; return cache.addAll(['./index.html','./index.js']) &#125;) )&#125;)//拦截所有请求事件//如果缓存中已经有请求的数据就直接用缓存，否则去请求数据self.addEventListener('fetch', e =&gt; &#123; e.respondWith( cache.match(e.request).then(function(response)&#123; if(response)&#123; return response &#125; console.log('fetch source') &#125;) )&#125;)]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object.assign原理及其实现]]></title>
    <url>%2F2019%2F08%2F09%2FObject-assign%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[实现一个深拷贝]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[简单实现 其实深拷贝可以拆分为：浅拷贝+递归，浅拷贝时判断属性是否时对象，如果是对象就进行递归操作。浅拷贝代码如下1234567891011121314151617181920212223242526272829303132function cloneShallow(source)&#123; var target = &#123;&#125;; for(var key in source)&#123; if(Object.prototype.hasOwnProperty.call(source,key))&#123; target[key] = source[key]; &#125; &#125; return target;&#125;//测试用例var a = &#123; name: "muyiy", book:&#123; title:"You dont know JS", price:"45" &#125;, a1:undefined, a2:null, a3:123&#125;var b = cloneShallow(a);a.name = "高级前端进阶";a.book.price = "55";console.log(b);// &#123; // name: 'muyiy', // book: &#123; title: 'You Don\'t Know JS', price: '55' &#125;,// a1: undefined,// a2: null,// a3: 123// &#125; JavaScript中Object对象原型上的hasOwnProperty()用来判断一个属性是定义在对象本身而不是继承自原型链。因为javascript没有将hasOwnProperty作为一个敏感词，所以我们很有可能将对象的一个属性命名为hasOwnProperty，这样一来就无法再使用对象原型的 hasOwnProperty 方法来判断属性是否是来自原型链。所以要Object.prototype.hasOwnProperty指定是原型上的 再上面的代码上，加上是否事对象的判断并在相应的位置使用递归就可以实现简单深拷贝123456789101112131415161718192021222324function cloneDeep1(source)&#123; var target = &#123;&#125; for(var key in source)&#123; if(Object.prototype.hasOwnProperty.call(source,key))&#123; if(typeof source[key] === 'object')&#123; target[key] = cloneDeep1(source[key]); &#125;else&#123; target[key] = source[key]; &#125; &#125; &#125; return target;&#125;//使用上面的测试用例测试一下var b = cloneDeep1(a);console.log(b);// &#123; // name: 'muyiy', // book: &#123; title: 'You Don\'t Know JS', price: '45' &#125;, // a1: undefined,// a2: &#123;&#125;,// a3: 123// &#125; 一个简单的深拷贝就完成了，但是这个实现还存在很多问题 没有对传入参数进行校验，传入null时应该返回null而不是{} 对于对象的判断逻辑不严谨，因为typeof null === ‘object’ 没有考虑数组的兼容 拷贝数组我们来看下对于对象的判断：123function isObject(obj)&#123; return Object.prototype.toString.call(obj) === '[object Object]';&#125; 但是用在这里并不合适，因为我们要保留数组这种情况，所以这里使用typeof来处理1234typeof null //"object"typeof &#123;&#125; //"object"typeof [] //"object"typeof function foo()&#123;&#125; //"function" (特殊情况) 改动过后的isObject判断逻辑如下123function isObject(obj)&#123; return typeof obj === 'object' &amp;&amp; obj != null;&#125; 所以兼容数组的写法如下：123456789101112131415161718192021222324function cloneDeep2(source)&#123; if(!isObject(source)) return source;//非对象返回自身 var target = Array.isArray(source) ? [] : &#123;&#125;; for(var key in source)&#123; if(Object.prototype.hasOwnProperty.call(source,key))&#123; if(isObject(source[key]))&#123; target[key] = cloneDeep2(source[key]);//注意 &#125;else&#123; target[key] = source[key] &#125; &#125; &#125; return target;&#125;// 使用上面测试用例测试一下var b = cloneDeep2(a);console.log(b);// &#123; // name: 'muyiy', // book: &#123; title: 'You Don\'t Know JS', price: '45' &#125;,// a1: undefined,// a2: null,// a3: 123// &#125; 循环引用JSON无法深拷贝循环引用，遇到这种情况会抛出错误1234//a是文章开始的测试用例a.circleRef = a;JOSN.parse(JSON.stringify(a));//TypeError:Converting circular structure to JSON 使用哈希表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * @description: 深拷贝 * @param &#123;any&#125; object 被深拷贝的变量 * @return: target 深拷贝后的变量 */function deepclone(object, hash = new WeakMap()) &#123; if(!isObject(object)) return object; // hash处理循环引用 if(hash.has(object)) return hash.get(object); let target = Array.isArray(object) ? [] : &#123;&#125;; let value; hash.set(object, target); // 拿到键值，包括symbol，但是不能遍历原型链，若要遍历使用for in Reflect.ownKeys(object).forEach(key =&gt; &#123; value = object[key]; if(isObject(value)) &#123; if(Array.isArray(value)) &#123; let array = initArray(value); target[key] = copyArray(array, value, hash); &#125; else &#123; target[key] = deepclone(value, hash); &#125; &#125; else &#123; target[key] = value; &#125; &#125;) return target;&#125;/** * @description: 判断是否为对象 * @param &#123;any&#125; value 被判断目标 * @return: bool 是否为对象 */function isObject(value) &#123; const type = typeof value; return value != null &amp;&amp; (type === 'object' || type === 'function');&#125;/** * @description: 生成指定长度数组 * @param &#123;array&#125; array 被生成数组 * @return: result 生成的数组 */function initArray(array) &#123; const &#123; length &#125; = array; let result = array.constructor(length); return result;&#125;/** * @description: 复制数组 * @param &#123;array&#125; array 生成数组 * @param &#123;array&#125; value 被复制数组 * @param &#123;hash&#125; hash 哈希表 * @return: array 复制后的数组 */function copyArray(array, value, hash) &#123; let item; for(let i = 0 ; i &lt; value.length ; i++) &#123; item = value[i]; if(!isObject(item)) &#123; array[i] = item; &#125; else &#123; if(Array.isArray(item)) &#123; let temp = initArray(item); array[i] = copyArray(temp, item, hash); &#125; else &#123; array[i] = deepclone(item, hash); &#125; &#125; &#125; return array;&#125;module.exports = &#123; deepclone, initArray, copyArray&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么前端监控要用GIF打点？]]></title>
    <url>%2F2019%2F08%2F03%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E8%A6%81%E7%94%A8GIF%E6%89%93%E7%82%B9%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？ 能够完成整个 HTTP 请求+响应（尽管不需要响应内容） 触发 GET请求之后不需要获取和处理数据、服务器也不需要发送数据 跨域友好 执行过程无阻塞 相比 XMLHttpRequest 对象发送 GET 请求，性能上更好 GIF的最低合法体积最小（最小的BMP文件需要74个字节，PNG需要67个字节，而合法的GIF，只需要43个字节） https://mp.weixin.qq.com/s/v6R2w26qZkEilXY0mPUBCw?utm_source=tuicool&amp;utm_medium=referral]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端安全]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[XSS:https://segmentfault.com/a/1190000016551188CSRF:https://segmentfault.com/a/1190000016659945 首帧优化]]></content>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断数组的三个方法，介绍它们的区别]]></title>
    <url>%2F2019%2F07%2F31%2F%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%89%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%8C%E4%BB%8B%E7%BB%8D%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Object.prototype.toString.call() &amp;&amp; instanceof &amp;&amp; Array.isArray() Object.prototype.toString.call()每一个继承Object的对象都有toString方法，如果toString方法没有重写的话，会返回[Object type]，其中type为对象的类型。但当除了Object类型的对象外，其他类型直接使用toString方法时，会直接返回都是内容的字符串，所以我们需要使用call或者apply方法来改变toString方法的执行上下文。123const an = ['Hello','An'];an.toString();Object.prototype.toString.call(an);//"[object Array]" 这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined 。12345678Object.prototype.toString.call('An') // "[object String]"Object.prototype.toString.call(1) // "[object Number]"Object.prototype.toString.call(Symbol(1)) // "[object Symbol]"Object.prototype.toString.call(null) // "[object Null]"Object.prototype.toString.call(undefined) // "[object Undefined]"Object.prototype.toString.call(function()&#123;&#125;) // "[object Function]"Object.prototype.toString.call(&#123;name: 'An'&#125;) // "[object Object]"Object.prototype.toString.call() 常用于判断浏览器内置对象时。 instanceofinstanceof 的内部机制是通过判断对象的原型链中是不是能找到类型的prototype使用instanceof判断一个对象是否为数组，instanceof会判断这个对象的原型链是否会找到对应的Array的原型，找到返回true,否则返回false1[] instanceof Array; // true 但 instanceof 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true。1[] instanceof Object; // true Array.isArray()功能：用来判断对象是否为数组 instanceof 与 isArray 当检测Array实例时，Array.isArray 优于 instanceof ，因为 Array.isArray 可以检测出 iframes1234567891011var iframe = document.createElement('iframe');document.body.appendChild(iframe);xArray = window.frames[window.frames.length-1].Array;var arr = new xArray(1,2,3); // [1,2,3]// Correctly checking for ArrayArray.isArray(arr); // trueObject.prototype.toString.call(arr); // true// Considered harmful, because doesn't work though iframesarr instanceof Array; // falseArray.isArray() 与 Object.prototype.toString.call() Array.isArray()是ES5新增的方法，当不存在 Array.isArray() ，可以用 Object.prototype.toString.call() 实现。12345if (!Array.isArray) &#123; Array.isArray = function(arg) &#123; return Object.prototype.toString.call(arg) === '[object Array]'; &#125;;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[代码题]]></title>
    <url>%2F2019%2F07%2F30%2F%E4%BB%A3%E7%A0%81%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组 已知如下数组：1var arr = [[1,2,2],[3,4,5,5],[6,7,8,9,[11,12,[12,13,[14]]]],10]; 解答1Array.from(new Set(arr.flat(Infinity))).sort((a,b) =&gt; &#123; return a-b&#125;) 12345678910Array.prototype.flat = function()&#123; return [].concat(...this.map(item =&gt; (Array.isArray(item) ? item.flat() : [item])));&#125;//map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。// Array.prototype.concat == [].concatArray.prototype.unique = function() &#123; return [...new Set(this)]&#125;const sort = (a,b) =&gt; a - b;console.log(arr.flat().unique().sort(sort)); 1234567891011121314151617// 1、扁平化数组var flatArr = arr.toString().split(",");// 2、去重var hash = &#123;&#125;;for (var i = 0, len = flatArr.length; i &lt; len; i++) &#123;hash[flatArr[i]] = "abc"&#125;flatArr = [];// 3、将元素字符串转化为数字、遍历hash并不能保证输出顺序for (var i in hash) &#123;flatArr.push(+i)&#125;// 4、排序flatArr = flatArr.sort(function(a, b) &#123;return a - b&#125;)console.log(flatArr) 请把俩个数组 [A1, A2, B1, B2, C1, C2, D1, D2] 和 [A, B, C, D]，合并为 [A1, A2, A, B1, B2, B, C1, C2, C, D1, D2, D]。123456789101112let a1 = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2']let a2 = ['A', 'B', 'C', 'D'].map((item) =&gt; &#123; return item + 3&#125;)let a3 = [...a1, ...a2].sort().map((item) =&gt; &#123; if(item.includes('3'))&#123; return item.split('')[0] //"A3".split('')[0] =&gt; 把第[0]个 即为A 取出来然后返回出去 &#125; return item&#125;) 下面的代码打印什么内容，为什么？12345 var b = 10;(function b()&#123; b = 20; console.log(b); &#125;)(); 输出结果：1234ƒ b() &#123; b = 20; console.log(b)&#125; 分析：12345678var b = 10;(function b() &#123; // 内部作用域，会先去查找是有已有变量b的声明，有就直接赋值20，确实有了呀。发现了具名函数 function b()&#123;&#125;，拿此函数b做赋值； // IIFE的函数无法进行赋值（内部机制，类似const定义的常量），所以无效。即具名自执行函数的变量为只读属性，不可修改 b = 20; console.log(b); // [Function b] console.log(window.b); // 10，不是20&#125;)(); 所以严格模式下能看到错误：Uncaught TypeError: Assignment to constant variable123456var b = 10;(function b() &#123; 'use strict' b = 20; console.log(b)&#125;)() // "Uncaught TypeError: Assignment to constant variable." 其他情况例子： 有window：123456var b = 10;(function b() &#123; window.b = 20; console.log(b); // [Function b] console.log(window.b); // 20是必然的&#125;)(); 有var:123456var b = 10;(function b() &#123; var b = 20; // IIFE内部变量 console.log(b); // 20 console.log(window.b); // 10 &#125;)(); 实现一个sleep函数1234567891011121314151617181920212223242526272829303132333435363738//Promiseconst sleep = time =&gt; &#123; return new Promise(resolve =&gt; setTimeout(resolve,time))&#125;sleep(1000).then(()=&gt;&#123; console.log(1)&#125;)//Generatorfunction* sleepGenerator(time)&#123; yield new Promise(function(resolve,reject)&#123; setTimeout(resolve,time) &#125;)&#125;sleepGenerator(1000).next().value.then(()=&gt;&#123; console.log(1)&#125;)//asyncfunction sleep(time)&#123; return new Promise(resolve =&gt; setTimeout(resolve,time))&#125;async function output()&#123; let out = await sleep(1000); console.log(1); return out;&#125;output();//ES5function sleep(callback,time)&#123; if(typeof callback === 'function') setTimeout(callback,time)&#125;function output()&#123; console.log(1);&#125;sleep(output,1000); 下面代码中a在什么情况下会打印1？ 题目如下1234var a = ?if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)&#123; console.log(1);&#125; 考察的是 == 的隐式转换 123456789101112131415161718192021222324252627282930// 利用toStringlet a = &#123; i : 1, toString()&#123; return a.i++ &#125;&#125;if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)&#123; console.log('1');&#125;//利用valueOflet a = &#123; i : 1, valueOf()&#123; return a.i++ &#125;&#125;if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)&#123; console.log('1')&#125;//数组var a = [1,2,3];a.join = a.shift;if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)&#123; console.log('1')&#125; 使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果sort函数，可以接收一个函数，返回值是比较两个数的相对顺序的值1.默认没有函数是按照utf-16排序的，对于字母数字你可以利用ASCII进行记忆12[3,15,8,29,102,22].sort();//[102,15,22,29,3,8] 2.带函数的比较12[3,15,8,29,102,22].sort((a,b) =&gt; &#123;return a - b&#125;);//[3, 8, 15, 22, 29, 102] a - b =&gt; 从小到大b - a =&gt; 从大到小 输出以下代码的执行结果并解释为什么123456var a = &#123;n: 1&#125;;var b = a;a.x = a = &#123;n: 2&#125;;console.log(a.x) console.log(b.x) 结果:12undefined&#123;n:2&#125; 首先，a和b同时引用了{n:1}对象，接着执行到a.x = a = {n：2}语句，尽管赋值是从右到左的没错，但是.的优先级比=要高，所以这里首先执行a.x，相当于为a（或者b）所指向的{n:1}对象新增了一个属性x，即此时对象将变为{n:1;x:undefined}。之后按正常情况，从右到左进行赋值，此时执行a ={n:2}的时候，a的引用改变，指向了新对象{n：2},而b依然指向的是旧对象。之后执行a.x = {n：2}的时候，并不会重新解析一遍a，而是沿用最初解析a.x时候的a，也即旧对象，故此时旧对象的x的值为{n：2}，旧对象为 {n:1;x:{n：2}}，它被b引用着。后面输出a.x的时候，又要解析a了，此时的a是指向新对象的a，而这个新对象是没有x属性的，故访问时输出undefined；而访问b.x的时候，将输出旧对象的x的值，即{n:2}。 某公司 1 到 12 月份的销售额存在一个对象里面如下：{1:222, 2:123, 5:888}，请把数据处理为如下结构：[222, 123, null, null, 888, null, null, null, null, null, null, null]。12345678910let obj = &#123;1:222, 2:123, 5:888&#125;;obj.length = 12;let _obj = Array.from(obj).slice(1);//Array.from(obj)-&gt;[undefined, 222, 123, undefined, undefined, 888, undefined, undefined, undefined, undefined, undefined, undefined]//_obj-&gt;[222, 123, undefined, undefined, 888, undefined, undefined, undefined, undefined, undefined, undefined]//Array.from() 方法从一个类似数组或可迭代对象中创建一个新的，浅拷贝的数组实例。let newObj = _obj.map((item) =&gt; &#123;if(item === undefined) &#123;return null;&#125; else &#123;return item;&#125;&#125;);console.log(newObj); 已知如下代码，如何修改才能让图片宽度为 300px ？注意下面代码不可修改。1&lt;img src="1.jpg" style="width:480px!important;"&gt; 1.可以用max-width覆盖2.可以用transform: scale()缩小3.可以用box-sizing定义盒子模型的模式box-sizing:border-box|content-box 属性border-box以border为边界，宽高是包括边框和内边距的，所以border+padding+content = width；如果给宽高后再给padding是向里，盒模型的宽高不会改变 属性content-box以content为边界，宽高仅仅是内容的宽高，再给padding或者border是向外，所以盒模型的宽高是变大的 123456img&#123; /*max-width:300px;*/ /*transform: scale(0.625,0.625)*/ box-sizing: border-box; padding: 0 90px;&#125; 随机生成一个长度为10的整数类型的数组，再把连续的元素组成一个数组排列成新数组。比如[2,10,3,4,5,11,10,11,20],将其排列成一个新数组[[2,3,4,5],[10,11],[20]].12345678910111213141516171819202122232425262728293031323334353637//生成随机数组function buildArr() &#123; var _arr = []; for(var i=0; i&lt;10; i++) &#123; _arr.push(Math.floor(Math.random() * 20 + 1)) &#125; console.log('randomed:',_arr) return _arr;&#125;let ary = buildArr()//去重ary = Array.from(new Set(ary));console.log('setted:',ary)//排序ary.sort((a,b) =&gt; a - b);console.log('sorted:',ary)//保存结果let newAry = []for (let i = 0; i &lt; ary.length; i++) &#123; let tmpAry = [ary[i]] // index用于跳过已经处理过的数组元素 let index = ary.length for (let j = i + 1, count = 1; j &lt; ary.length; j++, count++) &#123; if (ary[i] + count === ary[j]) &#123; tmpAry.push(ary[j]) &#125; else &#123; index = j - 1 break &#125; &#125; i = index newAry.push(tmpAry)&#125;console.log('result', newAry) Math.random()得到一个大于等于0，小于1之间的随机数123function getRandom()&#123; return Math.random();&#125; 得到一个两数之间的随机数[min,max)123function getRandomArbitrary(min,max)&#123; return Math.random() * (max - min) + min;&#125; 得到一个两数之间的随机整数[min,max)12345function getRandomInt(min,max)&#123; min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min)) + min;&#125; 得到一个两数之间的随机整数，包括两个数在内[min,max]123min = Math.ceil(min);max = Math.floor(max);return Math.floor(Math.random() * (max - min + 1)) + min; 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。123456789示例:输入: [0,1,0,3,12]输出: [1,3,12,0,0]说明:必须在原数组上操作，不能拷贝额外的数组。尽量减少操作次数。 解答：12345678910111213function zeroMove(array) &#123; let len = array.length; let j = 0; for(let i=0;i&lt;len-j;i++)&#123; if(array[i]===0)&#123; array.push(0); array.splice(i,1); i --; j ++; &#125; &#125; return array;&#125; 123456789101112function moveZeroToLast(arr) &#123; let index = 0; for (let i = 0, length = arr.length; i &lt; length; i++) &#123; if (arr[i] === 0) &#123; index++; &#125; else if (index !== 0) &#123; arr[i - index] = arr[i]; arr[i] = 0; &#125; &#125; return arr;&#125; 实现convert方法，把原始list转换成树形结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354以下数据结构中，id 代表部门编号，name 是部门名称，parentId 是父部门编号，为 0 代表一级部门，现在要求实现一个 convert 方法，把原始 list 转换成树形结构，parentId 为多少就挂载在该 id 的属性 children 数组下，结构如下：// 原始 list 如下let list =[ &#123;id:1,name:'部门A',parentId:0&#125;, &#123;id:2,name:'部门B',parentId:0&#125;, &#123;id:3,name:'部门C',parentId:1&#125;, &#123;id:4,name:'部门D',parentId:1&#125;, &#123;id:5,name:'部门E',parentId:2&#125;, &#123;id:6,name:'部门F',parentId:3&#125;, &#123;id:7,name:'部门G',parentId:2&#125;, &#123;id:8,name:'部门H',parentId:4&#125;];const result = convert(list, ...);// 转换后的结果如下let result = [ &#123; id: 1, name: '部门A', parentId: 0, children: [ &#123; id: 3, name: '部门C', parentId: 1, children: [ &#123; id: 6, name: '部门F', parentId: 3 &#125;, &#123; id: 16, name: '部门L', parentId: 3 &#125; ] &#125;, &#123; id: 4, name: '部门D', parentId: 1, children: [ &#123; id: 8, name: '部门H', parentId: 4 &#125; ] &#125; ] &#125;, ···]; 解答：123456789101112131415161718192021222324252627282930function convert(list) &#123; const res = [] //使用map保存id和对象的映射 const map = list.reduce((res, v) =&gt; (res[v.id] = v, res), &#123;&#125;) for (const item of list) &#123; if (item.parentId === 0) &#123; res.push(item) continue &#125; if (item.parentId in map) &#123; const parent = map[item.parentId] parent.children = parent.children || [] parent.children.push(item) &#125; &#125; console.log(res) return res&#125;let list = [ &#123; id: 1, name: '部门A', parentId: 0 &#125;, &#123; id: 2, name: '部门B', parentId: 0 &#125;, &#123; id: 3, name: '部门C', parentId: 1 &#125;, &#123; id: 4, name: '部门D', parentId: 1 &#125;, &#123; id: 5, name: '部门E', parentId: 2 &#125;, &#123; id: 6, name: '部门F', parentId: 3 &#125;, &#123; id: 7, name: '部门G', parentId: 2 &#125;, &#123; id: 8, name: '部门H', parentId: 4 &#125;];convert(list) 用 JavaScript 写一个函数，输入 int 型，返回整数逆序后的字符串。如：输入整型 1234，返回字符串“4321”。要求必须使用递归函数调用，不能用全局变量，输入函数必须只有一个参数传入，必须返回字符串。 解答：12345678910111213function fun(num)&#123; let num1 = num / 10; let num2 = num % 10; if(num1&lt;1)&#123; return num; &#125;else&#123; num1 = Math.floor(num1) return `$&#123;num2&#125;$&#123;fun(num1)&#125;` &#125;&#125;var a = fun(12345)console.log(a)console.log(typeof a) 请写出如下代码的打印结果123456789101112131415161718function Foo() &#123; Foo.a = function() &#123; console.log(1) &#125; this.a = function() &#123; console.log(2) &#125;&#125;Foo.prototype.a = function() &#123; console.log(3)&#125;Foo.a = function() &#123; console.log(4)&#125;Foo.a();let obj = new Foo();obj.a();Foo.a(); 解答：123456789101112131415161718192021222324252627282930313233343536373839//输出顺序是 4 2 1 .function Foo() &#123; Foo.a = function() &#123; console.log(1) &#125; this.a = function() &#123; console.log(2) &#125;&#125;// 以上只是 Foo 的构建方法，没有产生实例，此刻也没有执行Foo.prototype.a = function() &#123; console.log(3)&#125;// 现在在 Foo 上挂载了原型方法 a ，方法输出值为 3Foo.a = function() &#123; console.log(4)&#125;// 现在在 Foo 上挂载了直接方法 a ，输出值为 4Foo.a();// 立刻执行了 Foo 上的 a 方法，也就是刚刚定义的，所以// # 输出 4let obj = new Foo();/* 这里调用了 Foo 的构建方法。Foo 的构建方法主要做了两件事：1. 将全局的 Foo 上的直接方法 a 替换为一个输出 1 的方法。2. 在新对象上挂载直接方法 a ，输出值为 2。*/obj.a();// 因为有直接方法 a ，不需要去访问原型链，所以使用的是构建方法里所定义的 this.a，// # 输出 2Foo.a();// 构建方法里已经替换了全局 Foo 上的 a 方法，所以// # 输出 1 请写一个函数，完成以下功能输入：’1,2,3,5,7,8,10’输出：’1~3,5,7~8,10’ 1234567891011121314151617const nums1 = [1,2,3,5,7,8,10];function simplifyStr(num)&#123; var result = []; var temp = num[0]; num.forEach((value,index) =&gt; &#123; if(value + 1 !== num[index + 1])&#123; if(temp !== value)&#123; result.push(`$&#123;temp&#125;~$&#123;value&#125;`) &#125;else&#123; result.push(`$&#123;value&#125;`) &#125; temp = num[index + 1] &#125; &#125;) return result&#125;console.log(simplifyStr(nums1).join(',')) 考虑到性能问题，如何快速从一个巨大的数组中随机获取部分元素。 比如有个数组有100K个元素，从中不重复随机选取10K个元素。 12345678910111213141516171819/* 洗牌算法： 1.生成一个0 - arr.length 的随机数 2.交换该随机数位置元素和数组的最后一个元素，并把该随机位置的元素放入结果数组 3.生成一个0 - arr.length - 1 的随机数 4.交换该随机数位置元素和数组的倒数第二个元素，并把该随机位置的元素放入结果数组 依次类推，直至取完所需的10k个元素*/function shuffle(arr, size) &#123; let result = [] for (let i = 0; i &lt; size; i++) &#123; const randomIndex = Math.floor(Math.random() * (arr.length - i)) const item = arr[randomIndex] result.push(item) arr[randomIndex] = arr[arr.length - 1 - i] arr[arr.length - 1 - i] = item &#125; return result&#125; 编程题，写个程序把 entry 转换成如下对象1234567891011121314151617181920var entry = &#123; a: &#123; b: &#123; c: &#123; dd: 'abcdd' &#125; &#125;, d: &#123; xx: 'adxx' &#125;, e: 'ae' &#125;&#125;// 要求转换成如下对象var output = &#123; 'a.b.c.dd': 'abcdd', 'a.d.xx': 'adxx', 'a.e': 'ae'&#125; 解答：123456789101112function flatObj(obj, parentKey = "", result = &#123;&#125;) &#123; for (const key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; let keyName = `$&#123;parentKey&#125;$&#123;key&#125;`; if (typeof obj[key] === 'object') flatObj(obj[key], keyName+".", result) else result[keyName] = obj[key]; &#125; &#125; return result;&#125; 编程题，写个程序把 entry 转换成如下对象(跟上个题反着来)1234567891011121314151617181920var entry = &#123; 'a.b.c.dd': 'abcdd', 'a.d.xx': 'adxx', 'a.e': 'ae'&#125;// 要求转换成如下对象var output = &#123; a: &#123; b: &#123; c: &#123; dd: 'abcdd' &#125; &#125;, d: &#123; xx: 'adxx' &#125;, e: 'ae' &#125;&#125; 解答(不懂)：1https://muyiy.vip/question/program/112.html 找出字符串中连续出现最多的字符和个数12'abcaakjbb' =&gt; &#123;'a':2,'b':2&#125;'abbkejsbcccwqaa' =&gt; &#123;'c':3&#125; 解答：12345678910111213141516//先把str连续的分在一起//然后找到最长长度//找到最长长度的字符串 然后根据格式返回出来//let str = 'abbbkeccc'const arr = str.match(/(\w)\1*/g);const maxLen = Math.max(...arr.map(s =&gt; s.length));const result = arr.reduce((pre, curr) =&gt; &#123; if (curr.length === maxLen) &#123; pre[curr[0]] = curr.length; &#125; return pre;&#125;, &#123;&#125;);console.log(result);//array.reduce(function(total,currentValue,currentIndex,arr),initialValue) 解析URL Params为对象12345678910let url = 'http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled'; parseParam(url) 结果: &#123; user: 'anonymous', id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型 city: '北京', // 中⽂需解码 enabled: true, // 未指定值得 key 约定为 true &#125; 解答123456789101112131415161718192021222324252627function parseParam(url) &#123; const paramsStr = /.+\?(.+)$/.exec(url)[1]; // 将 ? 后⾯的字符串取出来 const paramsArr = paramsStr.split('&amp;'); // 将字符串以 &amp; 分割后存到数组中 let paramsObj = &#123;&#125;; // 将 params 存到对象中 paramsArr.forEach(param =&gt; &#123; if(/=/.test(param)) &#123; // 处理有 value 的参数 let [key, val] = param.split('='); // 分割 key 和 value val = decodeURIComponent(val); // 解码 val = /^\d+$/.test(val) ? parseFloat(val) : val; // 判断是否转为数字 if(paramsObj.hasOwnProperty(key)) &#123; // 如果对象有 key，则添加⼀个值 paramsObj[key] = [].concat(paramsObj[key], val); &#125; else &#123; // 如果对象没有这个 key，创建 key 并设置值 paramsObj[key] = val; &#125; &#125; else &#123; // 处理没有 value 的参数 paramsObj[param] = true; &#125; &#125;)return paramsObj; &#125;//$-&gt;以xxx结束//. 除了回车符和换行符之外的所有字符//+ 出现一次或者多次//? 出现零次或一次//如果你想要在正则中重复匹配一个字符串，那么可以用一个 () 号给包起来//exec() 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null。 模板引擎稍实现123456let template = '我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;';let data = &#123; name: '姓名', age: 18&#125;render(template, data); // 我是姓名，年龄18，性别undefined 解答：123456789function render(template, data) &#123; const reg = /\&#123;\&#123;(\w+)\&#125;\&#125;/; // 模板字符串正则 if (reg.test(template)) &#123; // 判断模板里是否有模板字符串 const name = reg.exec(template)[1]; // 查找当前模板里第一个模板字符串的字段 template = template.replace(reg, data[name]); // 将第一个模板字符串渲染 return render(template, data); // 递归的渲染并返回渲染后的结构 &#125; return template; // 如果模板没有模板字符串直接返回&#125; 转化为驼峰命名123var s1 = "get-element-by-id"// 转化为 getElementById 解答：12345var f = function(s) &#123; return s.replace(/-\w/g, function(x) &#123; return x.slice(1).toUpperCase(); &#125;)&#125; 求两个日期中间的有效日期如 2015-2-8 到 2015-3-3，返回[2015-2-8 2015-2-9…]1234567891011121314let getValidDate = (start,end) =&gt; &#123; let oneDay = 1000 * 60 * 60 * 24, dateList = '['; start = +new Date(start); end = +new Date(end); while(start &lt; end)&#123; let curr = new Date(start); dateList += `$&#123;curr.getFullYear()&#125;-$&#123;curr.getMonth() + 1&#125;-$&#123;curr.getDate()&#125; ` start += oneDay &#125; return dateList.slice(0,-1)+']'&#125;let result = getValidDate('2015-2-8','2015-3-3')console.log(result) 在一个字符串数组中有红、黄、蓝三种颜色的球，且个数不相等、顺序不一致，请为该数组排序。使得排序后数组中球的顺序为:黄、红、蓝。例如：红蓝蓝黄红黄蓝红红黄红，排序后为：黄黄黄红红红红红蓝蓝蓝。1234567891011121314151617181920212223242526//1 const strList= '红蓝蓝黄红黄蓝红红黄红' const sortRules = &#123;'黄':0, '红':1, '蓝':2&#125; const list = [[],[],[]] strList.split('').forEach(item =&gt; &#123;list[sortRules[item]].push(item)&#125;) list.reduce((pre,cur) =&gt; pre += cur.join(''),'') console.log(list)//2function sortBalls(str)&#123; let arr = str.split('') arr.sort((a,b) =&gt; &#123; return getNumByType(a) - getNumByType(b) &#125;) return arr.join('')&#125; function getNumByType(type)&#123; switch(type)&#123; case '黄': return 1 case '红': return 2 default: return 3 &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[js-questions]]></title>
    <url>%2F2019%2F07%2F30%2Fjs-questions%2F</url>
    <content type="text"><![CDATA[1.哪一个是无效的？ 12345678910111213const bird = &#123; size: 'small'&#125;const mouse = &#123; name: 'Mickey', small: true&#125;A: mouse.bird.sizeB: mouse[bird.size]C: mouse[bird["size"]]D: All of them are valid 答案: A在 JavaScript 中，所有对象的 keys 都是字符串（除非对象是 Symbol）。尽管我们可能不会定义它们为字符串，但它们在底层总会被转换为字符串。 当我们使用括号语法时（[]），JavaScript 会解释（或者 unboxes）语句。它首先看到第一个开始括号 [ 并继续前进直到找到结束括号 ]。只有这样，它才会计算语句的值。 mouse[bird.size]：首先计算 bird.size，这会得到 small。mouse[“small”] 返回 true。 然后使用点语法的话，上面这一切都不会发生。mouse 没有 bird 这个 key，这也就意味着 mouse.bird 是 undefined。然后当我们使用点语法 mouse.bird.size 时，因为 mouse.bird 是 undefined，这也就变成了 undefined.size。这个行为是无效的，并且会抛出一个错误类似 Cannot read property “size” of undefined。 2.输出是什么？1234567891011121314151617class Chameleon &#123; static colorChange(newColor) &#123; this.newColor = newColor return this.newColor &#125; constructor(&#123; newColor = 'green' &#125; = &#123;&#125;) &#123; this.newColor = newColor &#125;&#125;const freddie = new Chameleon(&#123; newColor: 'purple' &#125;)freddie.colorChange('orange')A: orangeB: purpleC: greenD: TypeError 答案: DcolorChange 是一个静态方法。静态方法被设计为只能被创建它们的构造器使用（也就是 Chameleon），并且不能传递给实例。因为 freddie 是一个实例，静态方法不能被实例使用，因此抛出了 TypeError 错误。 3.当我们这么做时，会发生什么？123456789function bark() &#123; console.log('Woof!')&#125;bark.animal = 'dog'A: 正常运行!B: SyntaxError. 你不能通过这种方式给函数增加属性。C: undefinedD: ReferenceError 答案: A这在 JavaScript 中是可以的，因为函数是对象！（除了基本类型之外其他都是对象） 函数是一个特殊的对象。你写的这个代码其实不是一个实际的函数。函数是一个拥有属性的对象，并且属性也可被调用。 4.输出是什么？123456789101112131415function Person(firstName, lastName) &#123; this.firstName = firstName; this.lastName = lastName;&#125;const member = new Person("Lydia", "Hallie");Person.getFullName = function () &#123; return `$&#123;this.firstName&#125; $&#123;this.lastName&#125;`;&#125;console.log(member.getFullName());A: TypeErrorB: SyntaxErrorC: Lydia HallieD: undefined undefined 答案: ASyntaxError 对象代表尝试解析语法上不合法的代码的错误.TypeError(类型错误) 对象用来表示值的类型非预期类型时发生的错误.你不能像常规对象那样，给构造函数添加属性。如果你想一次性给所有实例添加特性，你应该使用原型。因此本例中，使用如下方式：123Person.prototype.getFullName = function () &#123; return `$&#123;this.firstName&#125; $&#123;this.lastName&#125;`;&#125; 这才会使 member.getFullName() 起作用。为什么这样做有什么优点？假设我们将这个方法添加到构造函数本身里。也许不是每个 Person 实例都需要这个方法。这将浪费大量内存空间，因为它们仍然具有该属性，这将占用每个实例的内存空间。相反，如果我们只将它添加到原型中，那么它只存在于内存中的一个位置，但是所有实例都可以访问它！ 5.输出是什么？123456789101112131415function Person(firstName, lastName) &#123; this.firstName = firstName this.lastName = lastName&#125;const lydia = new Person('Lydia', 'Hallie')const sarah = Person('Sarah', 'Smith')console.log(lydia)console.log(sarah)A: Person &#123;firstName: "Lydia", lastName: "Hallie"&#125; and undefinedB: Person &#123;firstName: "Lydia", lastName: "Hallie"&#125; and Person &#123;firstName: "Sarah", lastName: "Smith"&#125;C: Person &#123;firstName: "Lydia", lastName: "Hallie"&#125; and &#123;&#125;D:Person &#123;firstName: "Lydia", lastName: "Hallie"&#125; and ReferenceError 答案: A对于 sarah，我们没有使用 new 关键字。当使用 new 时，this 引用我们创建的空对象。当未使用 new 时，this 引用的是全局对象（global object）。 我们说 this.firstName 等于 “Sarah”，并且 this.lastName 等于 “Smith”。实际上我们做的是，定义了 global.firstName = ‘Sarah’ 和 global.lastName = ‘Smith’。而 sarah 本身是 undefined。 6.输出是什么？1234567891011121314function getPersonInfo(one, two, three) &#123; console.log(one) console.log(two) console.log(three)&#125;const person = 'Lydia'const age = 21getPersonInfo`$&#123;person&#125; is $&#123;age&#125; years old`A: "Lydia" 21 ["", " is ", " years old"]B: ["", " is ", " years old"] "Lydia" 21C: "Lydia" ["", " is ", " years old"] 21 B如果使用标记模板字面量，第一个参数的值总是包含字符串的数组。其余的参数获取的是传递的表达式的值！ 7.输出是什么？12345678910111213141516function checkAge(data) &#123; if (data === &#123; age: 18 &#125;) &#123; console.log('You are an adult!') &#125; else if (data == &#123; age: 18 &#125;) &#123; console.log('You are still an adult.') &#125; else &#123; console.log(`Hmm.. You don't have an age I guess`) &#125;&#125;checkAge(&#123; age: 18 &#125;)A: You are an adult!B: You are still an adult.C: Hmm.. You dont have an age I guess 答案: C在测试相等性时，基本类型通过它们的值（value）进行比较，而对象通过它们的引用（reference）进行比较。JavaScript 检查对象是否具有对内存中相同位置的引用。 题目中我们正在比较的两个对象不是同一个引用：作为参数传递的对象引用的内存位置，与用于判断相等的对象所引用的内存位置并不同。 这也是 { age: 18 } === { age: 18 } 和 { age: 18 } == { age: 18 } 都返回 false 的原因。 8. 输出是什么？12345678910function getAge(...args) &#123; console.log(typeof args)&#125;getAge(21)A: "number"B: "array"C: "object"D: "NaN" 答案: C扩展运算符（…args）会返回实参组成的数组。而数组是对象，因此 typeof args 返回 “object”。 9.输出是什么？123456789101112const a = &#123;&#125;const b = &#123; key: 'b' &#125;const c = &#123; key: 'c' &#125;a[b] = 123a[c] = 456console.log(a[b])A: 123B: 456C: undefinedD: ReferenceError 答案: B对象的键被自动转换为字符串。我们试图将一个对象 b 设置为对象 a 的键，且相应的值为 123。 然而，当字符串化一个对象时，它会变成 “[object Object]”。因此这里说的是，a[“[object Object]”] = 123。然后，我们再一次做了同样的事情，c 是另外一个对象，这里也有隐式字符串化，于是，a[“[object Object]”] = 456。 然后，我们打印 a[b]，也就是 a[“[object Object]”]。之前刚设置为 456，因此返回的是 456。 10.当您单击该段落时，日志输出是什么？12345678910&lt;div onclick="console.log('div')"&gt; &lt;p onclick="console.log('p')"&gt; Click here! &lt;/p&gt;&lt;/div&gt;A: p divB: div pC: pD: div 答案: A如果我们点击 p，我们会看到两个日志：p 和 div。在事件传播期间，有三个阶段：捕获、目标和冒泡。默认情况下，事件处理程序在冒泡阶段执行（除非将 useCapture 设置为 true）。它从嵌套最深的元素向外传播。 11.输出是什么？123456789101112const person = &#123; name: 'Lydia' &#125;function sayHi(age) &#123; console.log(`$&#123;this.name&#125; is $&#123;age&#125;`)&#125;sayHi.call(person, 21)sayHi.bind(person, 21)A: undefined is 21 Lydia is 21B: function functionC: Lydia is 21 Lydia is 21D: Lydia is 21 function 答案: D使用这两种方法，我们都可以传递我们希望 this 关键字引用的对象。但是，.call 是立即执行的。 .bind 返回函数的副本，但带有绑定上下文！它不是立即执行的。 12.输出是什么？12345678910function sayHi() &#123; return (() =&gt; 0)()&#125;typeof sayHi()A: "object"B: "number"C: "function"D: "undefined" 答案: BsayHi 方法返回的是立即执行函数(IIFE)的返回值.此立即执行函数的返回值是 0， 类型是 number 13. 输出是什么？12345console.log(typeof typeof 1)A: "number"B: "string"C: "object"D: "undefined" 答案: Btypeof 1 返回 “number”|字符串。 typeof “number” 返回 “string”。 14. 输出是什么？12345678const numbers = [1, 2, 3]numbers[10] = 11console.log(numbers)A: [1, 2, 3, 7 x null, 11]B: [1, 2, 3, 11]C: [1, 2, 3, 7 x empty, 11]D: SyntaxError 答案: C当你为数组设置超过数组长度的值的时候， JavaScript 会创建名为 “empty slots” 的东西。它们的值实际上是 undefined。你会看到以下场景：[1, 2, 3, 7 x empty, 11]这取决于你的运行环境（每个浏览器，以及 node 环境，都有可能不同） 15.输出是什么？(不懂)123456789101112131415(() =&gt; &#123; let x, y try &#123; throw new Error() &#125; catch (x) &#123; (x = 1), (y = 2) console.log(x) &#125; console.log(x) console.log(y)&#125;)()A: 1 undefined 2B: undefined undefined undefinedC: 1 1 2D: 1 undefined undefined 答案: Acatch 代码块接收参数 x。当我们传递参数时，这与之前定义的变量 x 不同 。这个 x 是属于 catch 块级作用域的。然后，我们将块级作用域中的变量赋值为 1，同时也设置了变量 y 的值。现在，我们打印块级作用域中的变量 x，值为 1。catch 块之外的变量 x 的值仍为 undefined， y 的值为 2。当我们在 catch 块之外执行 console.log(x) 时，返回 undefined，y 返回 2。 16. 输出是什么？(不懂)1234567891011[[0, 1], [2, 3]].reduce( (acc, cur) =&gt; &#123; return acc.concat(cur) &#125;, [1, 2])A: [0, 1, 2, 3, 1, 2]B: [6, 1, 2]C: [1, 2, 0, 1, 2, 3]D: [1, 2, 6] 答案: C[1, 2]是初始值。初始值将会作为首次调用时第一个参数 acc 的值。在第一次执行时， acc 的值是 [1, 2]， cur 的值是 [0, 1]。合并它们，结果为 [1, 2, 0, 1]。 第二次执行， acc 的值是 [1, 2, 0, 1]， cur 的值是 [2, 3]。合并它们，最终结果为 [1, 2, 0, 1, 2, 3] 17.setInterval 方法的返回值是什么？123456setInterval(() =&gt; console.log('Hi'), 1000)A: 一个唯一的idB: 该方法指定的毫秒数C: 传递的函数D: undefined 答案: AsetInterval 返回一个唯一的 id。此 id 可被用于 clearInterval 函数来取消定时。 18.返回值是什么?123456789const firstPromise = new Promise((res, rej) =&gt; &#123; setTimeout(res, 500, "one");&#125;);const secondPromise = new Promise((res, rej) =&gt; &#123; setTimeout(res, 100, "two");&#125;);Promise.race([firstPromise, secondPromise]).then(res =&gt; console.log(res)); 答案: B当我们向Promise.race方法中传入多个Promise时，会进行 优先 解析。在这个例子中，我们用setTimeout给firstPromise和secondPromise分别设定了500ms和100ms的定时器。这意味着secondPromise会首先解析出字符串two。那么此时res参数即为two，是为输出结果。 19.num的值是什么?123456const num = parseInt("7*6", 10);A: 42B: "42"C: 7D: NaN 答案: C只返回了字符串中第一个字母. 设定了 进制 后 (也就是第二个参数，指定需要解析的数字是什么进制: 十进制、十六机制、八进制、二进制等等……),parseInt 检查字符串中的字符是否合法. 一旦遇到一个在指定进制中不合法的字符后，立即停止解析并且忽略后面所有的字符。 *就是不合法的数字字符。所以只解析到”7”，并将其解析为十进制的7. num的值即为7. 20.输出是什么?123456789[1, 2, 3].map(num =&gt; &#123; if (typeof num === "number") return; return num * 2;&#125;);A: []B: [null, null, null]C: [undefined, undefined, undefined]D: [ 3 x empty ] 答案: C对数组进行映射的时候,num就是当前循环到的元素. 在这个例子中，所有的映射都是number类型，所以if中的判断typeof num === “number”结果都是true.map函数创建了新数组并且将函数的返回值插入数组。 但是，没有任何值返回。当函数没有返回任何值时，即默认返回undefined.对数组中的每一个元素来说，函数块都得到了这个返回值，所以结果中每一个元素都是undefined. 21.输出是什么?1234567891011121314151617181920function greeting() &#123; throw "Hello world!";&#125;function sayHi() &#123; try &#123; const data = greeting(); console.log("It worked!", data); &#125; catch (e) &#123; console.log("Oh no an error!", e); &#125;&#125;sayHi();A: "It worked! Hello world!"B: "Oh no an error: undefined"C: SyntaxError: can only throw Error objectsD: "Oh no an error: Hello world!" 答案: D通过throw语句，我么可以创建自定义错误。 而通过它，我们可以抛出异常。异常可以是一个字符串, 一个 数字, 一个 布尔类型 或者是一个 对象。在本例中，我们的异常是字符串’Hello world’. 通过 catch语句，我们可以设定当try语句块中抛出异常后应该做什么处理。在本例中抛出的异常是字符串’Hello world’. e就是这个字符串，因此被输出。最终结果就是’Oh an error: Hello world’. 22.输出是什么?1234567891011function Car() &#123; this.make = "Lamborghini"; return &#123; make: "Maserati" &#125;;&#125;const myCar = new Car();console.log(myCar.make);A: "Lamborghini"B: "Maserati"C: ReferenceErrorD: TypeError 答案: B返回属性的时候，属性的值等于 返回的 值，而不是构造函数中设定的值。我们返回了字符串 “Maserati”，所以 myCar.make等于”Maserati”. 23.输出是什么?1234567891011121314// counter.jslet counter = 10;export default counter;// index.jsimport myCounter from "./counter";myCounter += 1;console.log(myCounter);A: 10B: 11C: ErrorD: NaN 答案: C引入的模块是 只读 的: 你不能修改引入的模块。只有导出他们的模块才能修改其值。 当我们给myCounter增加一个值的时候会抛出一个异常： myCounter是只读的，不能被修改。 24. 输出是什么?12345678910const name = "Lydia";age = 21;console.log(delete name);console.log(delete age);A: false, trueB: "Lydia", 21C: true, trueD: undefined, undefined 答案: Adelete操作符返回一个布尔值： true指删除成功，否则返回false. 但是通过 var, const 或 let 关键字声明的变量无法用 delete 操作符来删除。 name变量由const关键字声明，所以删除不成功:返回 false. 而我们设定age等于21时,我们实际上添加了一个名为age的属性给全局对象。对象中的属性是可以删除的，全局对象也是如此，所以delete age返回true. 25. 输出是什么?123456789const numbers = [1, 2, 3, 4, 5];const [y] = numbers;console.log(y);A: [[1, 2, 3, 4, 5]]B: [1, 2, 3, 4, 5]C: 1D: [1] 答案：C解构赋值，比如说：[a,b] = [1,2]现在a的值为1，b的值为2题目中是，[y] = [1,2,3,4,5];现在y的值等于数组的第一值即为1]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FastClick原理浅析]]></title>
    <url>%2F2019%2F07%2F29%2FFastClick%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[为什么使用FastClick 在移动端H5开发过程中，关于点触可能会遇到如下两个问题： 手动点击与真正触发click事件会存在300ms的延迟 点击穿透问题(点击行为会穿透元素触发非父子关系元素的事件) 延迟的存在时因为浏览器想知道你是否在进行双击操作，而点击穿透是因为300ms延迟触发时的副作用。而使用fastclick能很好的解决这个问题，增加使用者的体验。 原理过程这里描述一个按钮点击过程的处理。12345678910111213141516171819202122//业务代码var $test = document.getElementById('test')$test.addEventListener('click',function()&#123; console.log('1 click')&#125;)//FastClick简单实现var targetElemet = nulldocument.body.addEventListener('touchstart',function()&#123; //记录点击的元素 targetElement = event.target&#125;)document.body.addEventListener('touchend',functoin(event)&#123; //阻止默认事件(屏蔽之后的click事件) event.preventDefault() var touch = event.changedTouched[0] //合成click事件，并添加可跟踪属性forwardedTouchEvent var clickEvent = document.createEvent('MouseEvents') clickEvent.initMouseEvent('click', true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null) clickEvent.forwardedTouchEvent = true //自定义的 targetElement.dispatchEvent(clickEvent)&#125;) 这里进行过程说明 业务正常使用click绑定事件 在document.body绑定touchstart和touchend stouchstart 用于记录当前点击的元素targetElement; touchend 阻止默认事件(屏蔽之后的click事件) 合成click事件，并添加可跟踪属性forwardedTouchEvent 在targetElement上触发click事件 targetElement上绑定的事件立即执行，完成FastCLick 执行业务自己的click事件 总结touch事件先于mouse事件先于click执行，因此可以在document.body上绑定事件用于监听点触行为，根据需要模拟click触发真正需要响应的元素 转载于]]></content>
  </entry>
  <entry>
    <title><![CDATA[css实现多重边框的5种方式]]></title>
    <url>%2F2019%2F07%2F25%2Fcss%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%87%8D%E8%BE%B9%E6%A1%86%E7%9A%845%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[利用描边(outline)属性 代码12345678910111213141516&lt;style&gt; .borders &#123; border: solid 6px #dd7b40; //here outline: solid 6px #888; //here &#125; .base &#123; background: #222; padding: 4rem 2rem; color:#fff; font-weight: bold; text-align: center; margin: 1rem; &#125;&lt;/style&gt;&lt;div class="base borders"&gt;利用outline实现双重边框&lt;/div&gt; 利用描边(outline)属性结合border属性实现双重边框。此方案实现简单，兼容性好，能兼容除IE6,7以外的浏览器。 说明 只能实现双重边框 边框样式灵活，可以实现虚线等样式的边框 描边在盒模型之外，会与外部元素发生重叠 利用额外的div https://juejin.im/entry/5b7665a6518825332e322d89]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue生命周期函数]]></title>
    <url>%2F2019%2F07%2F25%2Fvue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[上图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;script src="./lib/vue.js"&gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;input type="button" value="Button" @click="msg='No'"&gt; &lt;h3 id='h3'&gt;&#123;&#123;msg&#125;&#125;&lt;/h3&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue( &#123; el: '#app', data:&#123; msg:'ok' &#125;, methods: &#123; show()&#123; console.log('执行了') &#125; &#125;, beforeCreate() &#123; //这是遇到的第一个生命周期函数表示实例完全会被创建出来，会执行 console.log(this.msg) //这时候console会显示undefined this.show() //this.show is not a method //注意在beforeCreate生命周期函数执行的时候，data和methods中的数据都还没有被初始化 &#125;, created() &#123; //这是遇到的第二个生命周期函数 console.log(this.msg) this.show() //在created中，data和methods都已经初始化好了 //如果要调用methods中的方法，最早只能在created中操作 &#125;, beforeMount() &#123; //这是遇到的第3个生命周期函数，表示模板已经编译完成，但是尚未把模板渲染到页面中去 console.log(document.getElementById('h3').innerText)//&#123;&#123;msg&#125;&#125; //在beforeMount执行的时候，页面中的元素没有被真正替换过来，只是之前的一些模板字符串 &#125;, mounted() &#123; //这是遇到的第四个生命周期函数，表示内存中的模板，已经真实的挂载到了浏览器的页面中，用户已经看到了渲染好的页面 console.log(document.getElementById('h3').innerText)//ok //注意：mounted是实例创建中的最后一个生命周期函数，当执行完mounted，实例就完全被创建好了 &#125;, beforeUpdate() &#123; console.log('界面上元素的内容'+document.getElementById('h3').innerText) console.log('data中的msg数据是'+this.msg) //界面上元素的内容ok //data中的msg数据是No &#125;, updated() &#123; console.log('界面上元素的内容' + document.getElementById('h3').innerText) console.log('data中的msg数据是' + this.msg) //界面上元素的内容No //data中的msg数据是No //页面和data数据已经保持一致了 &#125;, &#125; ) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 原文链接]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[requestAnimationFrame]]></title>
    <url>%2F2019%2F07%2F10%2FrequestAnimationFrame%2F</url>
    <content type="text"><![CDATA[引入与setTimeout和setInterval不同，requestAnimationFrame不需要设置时间间隔。大多数电脑显示器的刷新频率是60Hz，大概相当于每秒钟重绘60次。大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升。因此，最平滑动画的最佳循环间隔是l000ms/60，约等于16.6ms 而setTimeout和setInterval的问题是，它们都不精确。它们的内在运行机制决定了时间间隔参数实际上只是指定了把动画代码添加到浏览器UI线程队列中以等待执行的时间。如果队列前面已经加入了其他任务，那动画代码就要等前面的任务完成后再执行 requestAnimationFrame采用系统时间间隔，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间太长，使用动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果 特点 requestAnimationFrame会把每一帧中的所有DOM操作集中起来，在一起重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率 在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就以为着更少的cpu，gpu和内存使用量 requestAnimationFrame是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销 使用requestAnimationFrame的用法与setTimeout很相似，只是不需要设置时间间隔而已。requestAnimationFrame使用一个回调函数作为参数，这个回调函数会在浏览器重绘回流之前调用。它返回一个整数，表示定时器的编号，这个值可以传递cancelAnimationFrame用于取消这个函数的执行 1requestID = requestAnimationFrame(callback)； 12345//控制台输出1和0var timer = requestAnimationFrame(function()&#123; console.log(0);&#125;);console.log(timer);//1 cancelAnimationFrame方法用于取消定时器12345//控制台什么都不输出var timer = requestAnimationFrame(function()&#123; console.log(0);&#125;);cancelAnimationFrame(timer); 也可以直接使用返回值进行取消1234var timer = requestAnimationFrame(function()&#123; console.log(0);&#125;);cancelAnimationFrame(1);]]></content>
      <tags>
        <tag>h5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是防抖和节流？有什么区别？如何实现？]]></title>
    <url>%2F2019%2F07%2F04%2F%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[防抖 触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间 思路 每次触发事件时都取消之前的延时调用方法 12345678910111213141516function debounce(fn)&#123; let timeout = null;//创建一个标记用来存放定时器的返回值 return function()&#123; clearTimeout(timeout);//每当用户输入的时候把前一个setTimeout clear掉 timeout = setTimeout(()=&gt;&#123;//然后又创建一个新的setTimeout，这样就能保证输入字符后的interval间隔内如果还有字符输入的话，就不会执行fn函数 fn.apply(this,arguments); &#125;,500); &#125;;&#125;function sayHi()&#123; console.log('防抖成功')&#125;var inp = document.getElementById('inp');inp.addEventListener('input',debounce(sayHi));//防抖 节流 高频事件触发，但在n秒内指挥执行一次，所以节流会稀释函数的执行频率 思路 每次触发事件时都判断当前是否有等待执行的延时函数,如果没有，就直接执行这个函数，如果有等待执行的延时函数，就在设置的这段时间内不去执行。 12345678910111213141516function throttle(fn)&#123; let canRun = true;//通过闭包保存一个标记 return function()&#123; if(!canRun) return;//在函数开头判断标记是否为true,不为true则return canRun = false;//立即设置为false setTimeout(()=&gt;&#123;//将外部传入的函数的执行放在setTimeout中 fn.apply(this,arguments); //最后在setTimeout执行完毕后再把标记设置为true（关键）表示可以执行下一次循环了。当定时器没有执行的时候标记永远时false，再开头被return掉 canRun = true; &#125;,500) &#125;&#125;function sayHi(e)&#123; console.log(e.target.innerWidth,e.target.innerHeight);&#125;window.addEventListener('resize',throttle(sayHi));]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析比较opacity:0、visibility:hidden、display:none优劣和适用场景]]></title>
    <url>%2F2019%2F07%2F03%2F%E5%88%86%E6%9E%90%E6%AF%94%E8%BE%83opacity-0%E3%80%81visibility-hidden%E3%80%81display-none%E4%BC%98%E5%8A%A3%E5%92%8C%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[结构： display:none; 会让元素完全从渲染树中消失，渲染的时候不占据任何空间，不能点击。visibility:hidden;不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，不能点击。opacity:0;不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击 继承：display: none和opacity: 0：是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示。visibility: hidden：是继承属性，子孙节点会由于继承了hidden而消失，通过设置visibility: visible;可以让子孙节点显示。 性能：display：none; 修改元素会造成文档回流,读屏器不会读取display: none元素内容，性能消耗较大visibility:hidden;修改元素只会造成本元素的重绘,性能消耗较少读屏器读取visibility: hidden元素内容opacity: 0 ;修改元素会造成重绘，性能消耗较少]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[介绍下Promise.all使用、原理实现及错误处理]]></title>
    <url>%2F2019%2F07%2F03%2F%E4%BB%8B%E7%BB%8D%E4%B8%8BPromise-all%E4%BD%BF%E7%94%A8%E3%80%81%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8F%8A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[Promise概念 Promise是JS异步编程中的重要概念，异步抽象处理对象，是目前比较流行Javascript异步编程解决方案之一。Promise.all()接受一个由promise任务组成的数组，可以同时处理多个promise任务，当所有的任务都执行完成时，Promise.all()返回resolve，但当有一个失败(reject)，则返回失败的信息，即使其他promise执行成功，也会返回失败。 Promise.all如何使用对于Promise.all(arr)来说，在参数数组中所有元素都变为决定态后，然后才返回新的promise。12345678910//以下demo，请求两个url,当两个异步请求返回结果后，再请求第三个urlconst p1 = request(`http://some.url.1`)const p2 = request(`http://some.url.2`)Promise.all([p1, p2]) .then((datas) =&gt; &#123; // 此处 datas 为调用 p1, p2 后的结果的数组 return request(`http://some.url.3?a=$&#123;datas[0]&#125;&amp;b=$&#123;datas[1]&#125;`) &#125;) .then((data) =&gt; &#123; console.log(msg)&#125;) Promise.all原理实现1234567function promiseAll(promise)&#123; return new Promise(function(resolve,reject)&#123; if(!Array.isArray(promises))&#123; &#125; &#125;)&#125;]]></content>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3之BFC,IFC,GFC和FFC]]></title>
    <url>%2F2019%2F07%2F03%2Fcss3%E4%B9%8BBFC-IFC-GFC%E5%92%8CFFC%2F</url>
    <content type="text"><![CDATA[css2.1中只有BFC和IFC，css3中才有GFC和FFC 什么是FCFC的全称是：Formatting Contexts,是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且又一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。 BFCBFC(Block Formatting Contexts)直译为”块级格式化上下文”。Block Formatting Contexts就是页面上的一个隔离的渲染区域，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此。如何产生BFC？float的值不为none。overflow的值不为visible。position的值不为relative和static。display的值为table-cell, table-caption, inline-block中的任何一个。那BFC一般有什么用呢？比如常见的多栏布局，结合块级别元素浮动，里面的元素则是在一个相对隔离的环境里运行。 IFCIFC(Inline Formatting Contexts)直译为”内联格式化上下文”，IFC的line box(线框)高度由其包含行内元素中最高的实际高度计算而来(不受到竖直方向的padding/margin影响)IFC中的line box一般左右都贴紧整个IFC，但是会因为float元素而绕乱。float元素会位于IFC与line box之间，使得line box宽度缩短。同个IFC下的多个line box高度不同。IFC中是不可能又块级元素的，当插入块级元素时(如p中插入div)会产生两个匿名块与div分隔开，即产生两个IFC，每个IFC对外表现为块级元素，与div垂直排列。 那么IFC一般有什么用呢？ 水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC,通过text-align则可以使其水平居中。 垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。 GFCGFC(GridLayout Formatting Contexts)直译为”网格布局格式化上下文”，当为一个元素设置display值为grid的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性各在网格项目（grid item）上定义网格行（grid row）和网格列（grid columns）为每一个网格项目（grid item）定义位置和空间。那么GFC有什么用呢，和table又有什么区别呢？首先同样是一个二维的表格，但GridLayout会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染语义和控制。 FFCFFC(Flex Formatting Contexts)直译为”自适应格式化上下文”，display值为flex或者inline-flex的元素将会生成自适应容器（flex container），可惜这个牛逼的属性只有谷歌和火狐支持，不过在移动端也足够了，至少safari和chrome还是OK的，毕竟这俩在移动端才是王道。Flex Box 由伸缩容器和伸缩项目组成。通过设置元素的 display 属性为 flex 或 inline-flex 可以得到一个伸缩容器。设置为 flex 的容器被渲染为一个块级元素，而设置为 inline-flex 的容器则渲染为一个行内元素。伸缩容器中的每一个子元素都是一个伸缩项目。伸缩项目可以是任意数量的。伸缩容器外和伸缩项目内的一切元素都不受影响。简单地说，Flexbox 定义了伸缩容器内伸缩项目该如何布局。]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输出以下代码运行结果]]></title>
    <url>%2F2019%2F07%2F02%2F%E8%BE%93%E5%87%BA%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[//example11234var a = &#123;&#125;,b = '123',c = 123;a[b] = 'b';a[c] = 'c';console.log(a[b]); //example21234var a = &#123;&#125;,b = Symbol('123'),c = Symbol('123');a[b] = 'b';a[c] = 'c';console.log(a[b]); //example31234var a = &#123;&#125;,b = &#123;key : '123'&#125;,c = &#123;key : '456'&#125;;a[b] = 'b';a[c] = 'c';console.log(a[b]); 解析：考察的是对象的键名的转换 对象的键名只能是字符串和Symbol类型 其他类型的键名会被转换成字符串类型 对象转字符串默认会调用toString方法 //example112345678var a = &#123;&#125;, b = '123', c = 123;a[b] = 'b';//c的键名会被转换为字符串'123',这里会把上面的 b 覆盖掉a[c] = 'c';//输出cconsole.log(a[b]); //example212345678910var a = &#123;&#125;,b = Symbol('123'), c = Symbol('123');//b是Symbol类型不需要转换a[b] = 'b';//c是Symbol类型不需要转换，而且每个Symbol类型的值都是不相等的，所以不会覆盖掉ba[c] = 'c';//输出bconsole.log(a[b]); //example3123456789101112var a = &#123;&#125;,b = &#123;key:'123'&#125;, c = &#123;key:'456'&#125;;//b不是字符串也不是Symbol类型，需要转换成字符串//对象类型会调用toString方法转化成字符串[object Object]a[b] = 'b';// c 不是字符串也不是 Symbol 类型，需要转换成字符串。// 对象类型会调用 toString 方法转换成字符串 [object Object]。这里会把 b 覆盖掉。a[c]='c'; // 输出 cconsole.log(a[b]); 123456var a = &#123;n : 1&#125;;var b = a;a.x = a = &#123;n : 2&#125;;console.log(a.x); // --&gt; undefinedconsole.log(b.x); // --&gt; &#123;n: 2&#125; 解析 优先级。 . 的优先级高于 = ，所以先执行a.x，堆内存中的{n: 1}就会变成{n: 1, x: undefined}，改变之后相应的b.x也变化了，因为指向的是同一个对象。 赋值操作是从右到左，所以执行a = {n: 2}，a的引用就被改变了，然后这个返回值又赋值给了a.x，需要注意的是这时候a.x是第一步中的{n: 1, x: undefined}那个对象，其实就是b.x，相当于b.x = {n: 2}]]></content>
      <tags>
        <tag>题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[介绍下HTTPS中间人攻击]]></title>
    <url>%2F2019%2F07%2F02%2F%E4%BB%8B%E7%BB%8D%E4%B8%8BHTTPS%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[中间人攻击过程如下： 服务器向客户端发送公钥 攻击者截获公钥，保留在自己手上 然后攻击者自己生成一个伪造的公钥，发送给客户端 客户端收到伪造的公钥后，生成加密的hash值发给服务器 攻击者获得加密hash值，用自己的私钥解密获得真密钥 同时生成假的加密hash值，发给服务器 服务器用私钥解密获得假私钥 服务器用假私钥加密传输信息 防范方法： 服务端在发送浏览器的公钥中加入CA证书，浏览器可以验证CA证书的有效性]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue知识点or面试题]]></title>
    <url>%2F2019%2F07%2F02%2Fvue%E7%9F%A5%E8%AF%86%E7%82%B9or%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[vue.js的特点 简洁：页面由HTML模板+Json数据+Vue实例自称数据驱动:自动计算属性和追踪依赖的模板表达式组件化：用可复用，解耦的组件来构造页面轻量：代码量小，不依赖其他库快速：精确有效批量DOM更新模板友好：可通过npm,bower等多种方式安装，很容易融入 active-class是哪个组件的属性 vue-router模板的router-link组件 vue-router有哪几种导航钩子 三种。一种是全局导航钩子:router.beforeEach(to,from,next),作用：跳转前进行判断拦截第二种：组件内的钩子第三种：单独路由独享组件（需要补充完整） 请说出vue-cli项目中src目录每个文件夹和文件的用法 assets:静态资源componenets:放组件router：定义路由相关的配置view：视图app.vue:一个应用主组件main.js:入口文件 vue路由传参数 使用query方法传入的参数使用this.$route.query接受使用params方式传入的参数使用this.$route.params接受 delete和Vue.delete删除数组的区别 delete只是被删除的元素变成了empty/undefined其他的元素的键值还是不变。Vue.delete直接删除了数组，改变了数组的键值123456var a = [1,2,3,4]var b = [1,2,3,4]delete a[0]console.log(a) //[empty,2,3,4]this.$delete(b,0)console.log(b) //[2,3,4] vue中的ref是什么 ref被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的$refs对象上。如果在普通的DOM元素上使用，引用指向的就是DOM元素；如果用在子组件上，引用就指向组件实例。 $route和$router的区别 $route是‘路由信息对象’，包括path,params,hash,query,fullPath,mached,name等路由信息参数$router是‘路由实例’对象包括了路由的跳转方法，钩子函数等 vue在v-for时给每项元素绑定事件需要事件代理吗 不需要 但是可以使用 源码没有做事件代理参考 Vue的父组件和子组件生命周期执行顺序是什么 加载渲染过程：父beforeCreate-&gt; 父created -&gt; 父beforeMount -&gt; 子beforeCreate -&gt; 子created -&gt; 子beforeMount -&gt; 子mounted -&gt; 父mounted 子组件更新过程：父beforeUpdate -&gt; 子beforeUpdate -&gt; 子Updated -&gt; 父Updated 父组件更新过程： 父beforeUpdate -&gt; 父Updated 销毁过程： 父beforeDestroy -&gt; 子beforeDestroy -&gt; 子destroyed -&gt;父destroyed v-model]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js添加事件和移除事件:addEventListener与removeEventListener]]></title>
    <url>%2F2019%2F06%2F05%2Fjs%E6%B7%BB%E5%8A%A0%E4%BA%8B%E4%BB%B6%E5%92%8C%E7%A7%BB%E9%99%A4%E4%BA%8B%E4%BB%B6-addEventListener%E4%B8%8EremoveEventListener%2F</url>
    <content type="text"><![CDATA[addEventListener()和removeEventListener()讲解 addEventListener()与removeEventListener()用于处理指定和删除事件处理程序操作 它们都接受3个参数：如addEventListener(“事件名”,”事件处理函数”,”布尔值（可选，默认为false)”); (注：事件名不含”on”,如”click”) 示例：要在body上添加事件处理程序，可以使用下列代码：123document.body.addEventLisener('touchmove',function(event)&#123; event.preventDefault();&#125;,false); 通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除;移除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过addEventListener()添加的匿名函数无法移除 错误用法示例1234567document.body.addEventListener('touchmove',function(event)&#123; event.preventDefault();&#125;,false);document.body.removeEventListener('touchmove',function(event)&#123; event.preventDefault();&#125;,false); 这个例子中，使用addEventListener()添加一个事件处理程序。虽然调用removeEventListener()时看似使用了相同的参数，但实际上，第二个参数与传入addEventListener()中的那一个完全不同的函数。而传入removeEventListener()中的事件处理程序函数必须与传入addEventListener()中的相同 正确用法示例12345function bodyScroll(event)&#123; event.preventDefault();&#125;document.body.addEventListener('touchmove',bodyScroll,false);document.body.removeEventListener('touchmove',bodyScroll,false); 重写后的这个例子在addEventListener()和removeEventListener()中用的是相同的函数。 共用函数不能带参数，错误用法示例：12345function bodyScroll(event)&#123; event.preventDefault();&#125;document.body.addEventListener('touchmove',bodyScroll(),false);document.body.removeEventListener('touchmove',bodyScroll(),false); 总结：1：相同事件绑定和解除，需要使用共用函数；绑定和解除事件时 事件没有”on” 即onclick写成click 2：共用函数不能带参数; addEventListener()与removeEventListener()的第三个参数详解布尔值参数是true，表示在捕获阶段调用事件处理程序；就是最不具体的节点先接收事件，最具体的节点最后接收事件 如果是false，在冒泡阶段调用事件处理程序;则是先寻找指定的位置，由最具体的元素接收，然后逐级向上传播至最不具体的元素的节点（文档） 示例：123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;添加事件&amp;&amp;解绑事件&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="out"&gt; &lt;p&gt;最外面&lt;/p&gt; &lt;div id="middle"&gt; &lt;div id="inner"&gt;最里面&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 12345678910&lt;script&gt; var out = document.getElementById('out'); var middle = document.getElementById('middle'); var inner = document.getElementById('inner'); //点击inner时，触发顺序为：out------inner-------middle out.addEventListener('click',function()&#123;alert("我是最外面的");&#125;,true); middle.addEventListener('click',function()&#123;alert("我是中间的");&#125;,false); inner.addEventListener('click',function()&#123;alert("我是最里面的");&#125;,false);&lt;/script&gt; 12345678910&lt;script&gt; var out = document.getElementById('out'); var middle = document.getElementById('middle'); var inner = document.getElementById('inner'); //点击inner时，触发顺序为：out-------middle------inner out.addEventListener('click',function()&#123;alert("我是最外面的");&#125;,true); middle.addEventListener('click',function()&#123;alert("我是中间的");&#125;,true); inner.addEventListener('click',function()&#123;alert("我是最里面的");&#125;,false);&lt;/script&gt; 结论：1.true的触发顺序总是在false前面2.如果多个均为true 则外层触发先于内层3.如果多个均为false 则内层触发先于外层 转载于：js添加事件和移除事件:addEventListener()与removeEventListener()]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CORS 简单请求+预检请求]]></title>
    <url>%2F2019%2F06%2F04%2FCORS%2F</url>
    <content type="text"><![CDATA[概述 当一个资源从与该资源本身所在的服务器不同的域，协议，端口请求一个资源时，资源会发起一个跨域HTTP请求。 出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求，XMLHttpRequest和Fetch API，只能从加载应用程序的同一个域请求HTTP资源，除非使用CORS头文件 对于浏览器限制这个词，要着重解释一下：不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了 CORS概述跨域资源共享标准新增了一组HTTP首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。 另外，规范要求，对那些可能对服务器数据产生副作用的HTTP请求方法（特别是GET以外的HTTP请求，或者搭配某些MIME类型的POST请求），浏览器必须首先使用OPTIONS方法发起一个预检请求(preflight request),从而获知服务端是否允许该跨域请求 服务器确认允许之后，才发起实际的HTTP请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括Cookies和HTTP认证相关数据）。 简单请求不会触发CORS预检的请求成为简单请求，满足以下所有条件的才会被视为简单请求，基本上我们日常开发只会关注前面两点 使用GET,POST,HEAD其中一种方法 只使用了如下的安全首部字段，不得人为设置其他首部字段 Accept Accept-Language Content-Type仅限以下三种 text/plain multipart/form-data application/x-www-form-urlencoded HTML头部header field字段：DPR,Download,Save-Data,Viewport-Width,Width 请求中的任意XMLHttpRequestUpload对象均没有注册任何事件监听器；XMLHttpRequestUpload对象可以使用XMLHttpRequest.upload属性访问 请求中没有使用ReadableStream对象 预检请求需预检的请求要求必须首先使用OPTIONS方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。“预检请求”的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响 下面的请求会触发预检请求，其实非简单请求之外的就会触发预检，就不用记那么多了 使用了PUT、DELETE、CONNECT、OPTIONS、TRACE、PATCH方法 人为设置了非规定内的其他首部字段，参考上面简单请求的安全字段集合，还要特别注意Content-Type的类型 XMLHttpRequestUpload 对象注册了任何事件监听器 请求中使用了ReadableStream对象 一下是一个发起预检请求的例子发起请求的origin与请求的服务器的host不同，而且根据上面的条件判断，触发了预检 请求附带身份凭证 -&gt; cookie如果发起请求时设置withCredentials标志设置为true,从而向服务器发送cookie,但是如果服务器端的响应中未携带Access-Control-Allow-Credentials:true,浏览器将不会把响应内容返回给请求的发送者 对于附带身份凭证的请求，服务器不能设置Access-Control-Allow-Origin的值为*,必须是某个具体的域名 注意，简单GET请求不会被预检，如果对此类带有身份凭证请求的响应中不包含该字段，这个响应将被忽略掉，并且浏览器也不会将相应内容返回给网页 完整请求流程 转载于：CORS 简单请求+预检请求（彻底理解跨域）]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie,Session,Token]]></title>
    <url>%2F2019%2F06%2F03%2FCookie-Session-Token%2F</url>
    <content type="text"><![CDATA[发展史 1、很久很久以前，Web 基本上就是文档的浏览而已， 既然是浏览，作为服务器， 不需要记录谁在某一段时间里都浏览了什么文档，每次请求都是一个新的HTTP协议， 就是请求加响应， 尤其是我不用记住是谁刚刚发了HTTP请求， 每个请求对我来说都是全新的。这段时间很嗨皮 2、但是随着交互式Web应用的兴起，像在线购物网站，需要登录的网站等等，马上就面临一个问题，那就是要管理会话，必须记住哪些人登录系统， 哪些人往自己的购物车中放商品， 也就是说我必须把每个人区分开，这就是一个不小的挑战，因为HTTP请求是无状态的，所以想出的办法就是给大家发一个会话标识(session id), 说白了就是一个随机的字串，每个人收到的都不一样， 每次大家向我发起HTTP请求的时候，把这个字符串给一并捎过来， 这样我就能区分开谁是谁了 3、这样大家很嗨皮了，可是服务器就不嗨皮了，每个人只需要保存自己的session id，而服务器要保存所有人的session id ！ 如果访问服务器多了， 就得由成千上万，甚至几十万个。 这对服务器说是一个巨大的开销 ， 严重的限制了服务器扩展能力， 比如说我用两个机器组成了一个集群， 小F通过机器A登录了系统， 那session id会保存在机器A上， 假设小F的下一次请求被转发到机器B怎么办？ 机器B可没有小F的 session id啊。 有时候会采用一点小伎俩： session sticky ， 就是让小F的请求一直粘连在机器A上， 但是这也不管用， 要是机器A挂掉了， 还得转到机器B去。 那只好做session 的复制了， 把session id 在两个机器之间搬来搬去， 快累死了。 后来有个叫Memcached的支了招： 把session id 集中存储到一个地方， 所有的机器都来访问这个地方的数据， 这样一来，就不用复制了， 但是增加了单点失败的可能性， 要是那个负责session 的机器挂了， 所有人都得重新登录一遍， 估计得被人骂死。 4 于是有人就一直在思考， 我为什么要保存这可恶的session呢， 只让每个客户端去保存该多好？ 可是如果不保存这些session id , 怎么验证客户端发给我的session id 的确是我生成的呢？ 如果不去验证，我们都不知道他们是不是合法登录的用户， 那些不怀好意的家伙们就可以伪造session id , 为所欲为了。 嗯，对了，关键点就是验证 ！ 比如说， 小F已经登录了系统， 我给他发一个令牌(token)， 里边包含了小F的 user id， 下一次小F 再次通过Http 请求访问我的时候， 把这个token 通过Http header 带过来不就可以了。 不过这和session id没有本质区别啊， 任何人都可以可以伪造， 所以我得想点儿办法， 让别人伪造不了。 那就对数据做一个签名吧， 比如说我用HMAC-SHA256 算法，加上一个只有我才知道的密钥， 对数据做一个签名， 把这个签名和数据一起作为token ， 由于密钥别人不知道， 就无法伪造token了。 这个token 我不保存， 当小F把这个token 给我发过来的时候，我再用同样的HMAC-SHA256 算法和同样的密钥，对数据再计算一次签名， 和token 中的签名做个比较， 如果相同， 我就知道小F已经登录过了，并且可以直接取到小F的user id , 如果不相同， 数据部分肯定被人篡改过， 我就告诉发送者： 对不起，没有认证。 Token 中的数据是明文保存的（虽然我会用Base64做下编码， 但那不是加密）， 还是可以被别人看到的， 所以我不能在其中保存像密码这样的敏感信息。 当然， 如果一个人的token 被别人偷走了， 那我也没办法， 我也会认为小偷就是合法用户， 这其实和一个人的session id 被别人偷走是一样的。 这样一来， 我就不保存session id 了， 我只是生成token , 然后验证token ， 我用我的CPU计算时间获取了我的session 存储空间 ！ 解除了session id这个负担， 可以说是无事一身轻， 我的机器集群现在可以轻松地做水平扩展， 用户访问量增大， 直接加机器就行。 这种无状态的感觉实在是太好了！ 什么是CookieHTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它还会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie使基于无状态的HTTP状态记录稳定的状态信息成为了可能。 Cookie主要用于一下三个方面： 会话状态管理（如用户登录状态，购物车，游戏分数或其他需要记录的信息） 个性化设置（如用户自定义设置，主题等） 浏览器行为跟踪（如跟踪分析用户行为等） 什么是SessionSession代表着服务器和客户端一次会话的过程。Session对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者Session超时失效会话结束。 Cookie和Session有什么不同？ 作用范围不同，Cookie保存在客户端（浏览器），Session保存在服务器端 存取方式的不同，Cookie只能保存ASCII，Session可以存任意数据类型，一般情况下我们可以在Session中保持一些常用变量信息，比如说UserId等。 有效期不同，Cookie可设置为长时间保持，比如我们经常使用的默认登录功能，Session一般失效时间较短，客户端关闭或者Session超时都会失效 隐私策略不同，Cookie存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在Cookie中导致信息被窃取；Session存储在服务端，安全性相对Cookie要好一些。 存储大小不同，单个Cookie保存的数据不能超过4K，Session可存储数据远高于Cookie 为什么需要Cookie和Session，他们有什么关联？说起来为什么需要Cookie，这就需要从浏览器开始说起，我们都知道浏览器是没有状态的（HTTP协议无协议），这意味着浏览器并不知道是张三还是李四在和服务器打交道。这个时候就需要有一个机制来告诉服务器，本次操作用户是否登录，是哪个用户在执行的操作，那这套机制的实现就需要Cookie和Session的配合 那么Cookie和Session是如何配合的呢？用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的Session，请求返回时将此Session的唯一标识信息SessionID返回给浏览器，浏览器接收到服务器返回的SessionID信息后，会将此信息存入到Cookie中，同时Cookie记录此SessionID属于哪个域名。 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在Cookie信息，如果存在自动将Cookie信息也发送给服务端，服务端会从Cookie中获取SessionID，再根据SessionID查找对应的Session信息，如果没有找到说明用户没有登录或者登录失效，如果找到Session证明用户已经登录可执行后面操作。 根据以上流程可知，SessionID是连接Cookie和Session的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。 既然服务端是根据Cookie中的信息判断用户是否登录，那么如果浏览器中禁止了Cookie，如何保障整个机制的正常运转 第一种方案，每次请求中都携带一个SessionID的参数，也可以Post的方式提交，也可以在请求的地址后面拼接xxx?SessionID=12345… 第二种方案，Token机制。Token机制多用于App客户端和服务器交互的模式，也可以用于Web端做用户状态管理。 Token的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token机制和Cookie和Session的使用机制比较类似。 当用户第一次登录后，服务器根据提交的用户信息生成一个Token，响应式将Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次登录验证。 如何考虑分布式Session问题？在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在A服务器登录了，第二次请求跑到服务B就会出现登录失效问题。 分布式Session一般会有以下几种解决方案： Nginx ip_hash策略，服务端使用Nginx代理，每个请求按访问IP的hash分配，这样来自同一IP固定访问一个后台服务器，避免了在服务器A创建Session，第二次分发到服务器B的现象。 Session复制，任何一个服务器上的Session发生改变（增删改），该节点会把这个Session的所有内容序列化，然后广播给所有其他节点。 共享Session，服务端无状态话，将用户的Session等信息使用缓存中间件来统一管理，保障分发到每一个服务器的响应结果都一致。 Token在Web领域基于Token的身份验证随处可见。在大多数使用Web API的互联网公司中，token是多用户下处理认证的最佳方式。以下几点特性会让你在程序中使用基于Token的身份验证 1.无状态、可扩展 2.支持移动设备 3.跨程序调用 4.安全(请求中发送token而不再是发送cookie能够防止CSRF(跨站请求伪造)。即使在客户端使用cookie存储token，cookie也仅仅是一个存储机制而不是用于认证。不将信息存储在Session中，让我们少了对session操作。token是有时效的，一段时间之后用户需要重新验证。我们也不一定需要等到token自动失效，token有撤回的操作，通过token revocataion可以使一个特定的token或是一组有相同认证的token无效。) 基于服务器验证方式暴露的一些问题1.Seesion：每次认证用户发起请求时，服务器需要去创建一个记录来存储信息。当越来越多的用户发请求时，内存的开销也会不断增加。 2.可扩展性：在服务端的内存中使用Seesion存储登录信息，伴随而来的是可扩展性问题。 3.CORS(跨域资源共享)：当我们需要让数据跨多台移动设备上使用时，跨域资源的共享会是一个让人头疼的问题。在使用Ajax抓取另一个域的资源，就可以会出现禁止请求的情况。 4.CSRF(跨站请求伪造)：用户在访问银行网站时，他们很容易受到跨站请求伪造的攻击，并且能够被利用其访问其他的网站。 使用基于 Token 的身份验证方法，（基于Token的身份验证是无状态的，我们不将用户信息存在服务器或Session中。这种概念解决了在服务端存储信息时的许多问题，NoSession意味着你的程序可以根据需要去增减机器，而不用去担心用户是否登录。）在服务端不需要存储用户的登录记录。大概的流程是这样的： 客户端使用用户名跟密码请求登录 服务端收到请求，去验证用户名与密码 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据 基于Token的身份验证：JSON Web Token实施 Token 验证的方法挺多的，还有一些标准方法，比如 JWT，读作：jot ，表示：JSON Web Tokens 。JWT 标准的 Token 有三个部分： header（头部）payload（数据）signature（签名）中间用点分隔开，并且都会使用 Base64 编码，所以真正的 Token 看起来像这样： 12eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ.SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc//header.payload.signature Header每个 JWT token 里面都有一个 header，也就是头部数据。里面包含了使用的算法，这个 JWT 是不是带签名的或者加密的。主要就是说明一下怎么处理这个 JWT token 。 头部里包含的东西可能会根据 JWT 的类型有所变化，比如一个加密的 JWT 里面要包含使用的加密的算法。唯一在头部里面要包含的是 alg 这个属性，如果是加密的 JWT，这个属性的值就是使用的签名或者解密用的算法。如果是未加密的 JWT，这个属性的值要设置成 none。123&#123; "alg": "HS256"&#125; 意思是这个 JWT 用的算法是 HS256。上面的内容得用 base64url 的形式编码一下，所以就变成这样：1eyJhbGciOiJIUzI1NiJ9 PayloadPayload 里面是 Token 的具体内容，这些内容里面有一些是标准字段，你也可以添加其它需要的内容。下面是标准字段： iss：Issuer，发行者 sub：Subject，主题 aud：Audience，观众 exp：Expiration time，过期时间 nbf：Not before iat：Issued at，发行时间 jti：JWT ID比如下面这个 Payload ，用到了 iss 发行人，还有 exp 过期时间这两个标准字段。另外还有两个自定义的字段，一个是 name ，还有一个是 admin 。 123456&#123; "iss": "ninghao.net", "exp": "1438955445", "name": "wanghao", "admin": true&#125; 使用 base64url 编码以后就变成了这个样子：1eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ SignatureJWT 的最后一部分是 Signature ，这部分内容有三个部分，先是用 Base64 编码的header.payload，再用加密算法加密一下，加密的时候要放进去一个 Secret，这个相当于是一个密码，这个密码秘密地存储在服务端。不能泄露给用户。然后，使用 Header里面指定的签名算法（默认是 HMACSHA256），按照下面的公式产生签名。1234HMACSHA256( base64UrlEncode(header) + "." + base64UrlEncode(payload), secret) 算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户 JWT的使用方式客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。 此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。1Authorization: Bearer &lt;token&gt; 另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里 JWT 的几个特点（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。 （2）JWT 不加密的情况下，不能将秘密数据写入 JWT。 （3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。 （4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。 （5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。 （6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。 参考:1234]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端数据操作总结]]></title>
    <url>%2F2019%2F05%2F29%2F%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[src转img 123456789101112function srctoimg(src)&#123; return new Promise((reslove,reject) =&gt; &#123; let img = new Image() img.onload = function()&#123; resolve(img) &#125; img.onerror = function(err)&#123; reject(err) &#125; img.src = src &#125;)&#125; img转canvas12345678function imgtocanvas(img)&#123; let canvas = document.createElement("canvas") let ctx = canvas.getContext('2d') canvas.width = img.width canvas.height = img.height ctx.drawImage(img,0,0,canvas.width,canvas.height) return canvas&#125; ImageData转canvas12345678function ImageDatetocanvas(imgData)&#123; let canvas = document.createElement("canvas") let ctx = canvas.getContext('2d') canvas.width = imgData.width canvas.height = imgData.height ctx.putImageData(imgData,canvas.width,canvas.height) return canvas&#125; canvas转ImageData1234function canvastoImageDate(canvas)&#123; let ctx = canvas.getContext('2d') return ctx.createImageData(canvas.width,canvas.height)&#125; canvas像素操作123456789function canvaspixel(canvas,deal)&#123; let ctx = canvas.getContext('2d') var imgData = ctx.createImageData(canvas.width,canvas.height) for(var i = 0; i &lt; imgData.data.length; i += 4)&#123; deal(r,g,b,a) &#125; ctx.putImageData(imgData,canvas.width,canvas.height) return canvas&#125; canvas转DataURL(base64)1canvas.toDataURL() DataURL(base64)转blob(，二进制大对象，是一个可以存储二进制文件的“容器”。 在计算机中，BLOB常常是数据库中用来存储二进制文件的字段类型。) file转arrayBuffer123456789function filetoblob(file)&#123; return new Promise((resolve,reject) =&gt; &#123; var reader = new FileReader(); reader.readAsArrayBuffer(file); reader.onload = function(e)&#123; resolve(reader.result) &#125; &#125;)&#125; file转blob(二进制大对象，是一个可以存储二进制文件的“容器”。 在计算机中，BLOB常常是数据库中用来存储二进制文件的字段类型。) 转载于]]></content>
  </entry>
  <entry>
    <title><![CDATA[一些常用流程]]></title>
    <url>%2F2019%2F05%2F28%2F%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[创建vue-cli项目 npm install vue-cli -g vue init webpack projectName 把本地项目与github相连 在github新建一个仓库,复制git链接 在本地 git clone 链接 cd 到项目位置 git init git commit -m ‘…’ git remote add origin git@github(git地址) git pull origin master git push origin master]]></content>
  </entry>
  <entry>
    <title><![CDATA[译axios文档]]></title>
    <url>%2F2019%2F05%2F24%2F%E8%AF%91axios%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[axios简介axios是一个基于Promise用于浏览器和nodejs的HTTP客户端，它本身具有以下特征： 从浏览器中创建XMLHttpRequest 从nodejs发出http请求 支持Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转化JSON数据 客户端支持防止CSRF/XSRF 浏览器兼容性 安装使用 npm:1$ npm install axios 使用 bower:1$ bower install axios 使用 yarn:1$ yarn add axios 使用 cdn:1&lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt; axios例子执行GET请求1234567891011121314151617181920//向具有指定ID的用户发出请求axios.get('/user?ID=12345') .then(function(response)&#123; console.log(response);&#125;).catch(function(error)&#123; console.log(error);&#125;);//也可以通过params对象传递参数axios.get('/user',&#123; params:&#123; ID:12345 &#125;&#125;).then(function(response)&#123; console.log(reponse);&#125;).catch(function(error)&#123; console.log(error)&#125;) 执行POST请求12345678910axios.post('/user',&#123; firstName:'Fred', lastName:'Flintstone'&#125;).then(function(response)&#123; console.log(response)&#125;).catch(function(error)&#123; console.log(error)&#125;) 执行多个并发请求12345678910function getUserAccount()&#123; return axios.get('/user/12345');&#125;function getUserPermissions()&#123; return axios.get('/user/12345/permissions');&#125;axios.all([getUserAccount(),getUserPermissions()]).then(axios.spread(function(acct,perms)&#123;//两个请求现已完成&#125;)) axios API可以通过将相关配置传递给axios来进行请求。 axios(config)123456789//发送一个POST请求axios(&#123; method:'post', url:'/user/12345', data:&#123; firstName:'Fred', lastName:'Flintstone' &#125;&#125;); axios(url[,config])12//发送一个GEt请求（GET请求时默认请求模式）axios('/user/12345') 请求方法别名为了方便起见，已经为所有支持的请求方法提供了别名 axios.request(config) axios.get(url[,config]) axios.delete(url[,config]) axios.head(url[,/config]) axios.options(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]])注意当使用方法别名时，url,method和data属性不需要在config中被指定。 并发性帮助函数处理并发请求 axios.all(iterable) axios.spread(callback) 创建axios实例您可以通过使用自定义配置创建一个新的axios实例 axios.create([config])12345const instance = axios.create(&#123; baseURL:'https://some-domain.com/api/', timeout:1000, header:&#123;'X-Custom-Header':'foobar'&#125;&#125;) 实例方法可用的实例方法如下所示。指定的配置将与实例配置合并。 axios#request(config) axios#get(url[, config]) axios#delete(url[, config]) axios#head(url[, config]) axios#options(url[, config]) axios#post(url[, data[, config]]) axios#put(url[, data[, config]]) axios#patch(url[, data[, config]]) axios#getUri([config]) 请求配置这些是用于发出请求的可用配置选项。只有url是必需的，如果请求方法没有特定，默认为GET方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136&#123; //`url` 是将用于请求的服务器URL url:'/user', //`method` 是当发送请求时的请求方式 method:'get', //默认 //`baseURL` 将被添加到'url'前面，除非'url'是绝对的 //可以方便地为axios的实例设置'baseURL'，以便将相对URL传递给该实例的方法 baseURL:'https://some-domain.com/api', //`transformRequest`允许在请求数据发送到服务器之前对其进行更改 //这只适用于PUT POST和PATCH请求方法 //数组中的最后一个函数必须返回一个字符串或一个Buffer实例,ArrayBuffer,FormData,Stream //您可能修改对象头部 transformRequest:[function(data,headers)&#123; //做任何你想要的数据转换 return data; &#125;], //`transformResponse` 允许在 then/catch 之前对响应数据进行更改 transformResponse: [function(data)&#123; //做任何你想要的数据转换 return data; &#125;], //`headers` 是要发送的自定义headers headers:&#123;'X-Requested-With': 'XMLHttpRequest'&#125;, //`params`是要与请求一起发送的url参数 //必须是纯对象或URLSearchParams对象 params:&#123; ID:12345 &#125;, //`paramsSerialize`是一个可选函数，负责序列化`params` // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: 'brackets'&#125;) &#125;, //`data` 是作为请求体发送的数据 //只适用于 PUT POST PATCH请求方法 //当`transformRequest`没有设置时，必须是以下类型之一： //- string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - Browser only: FormData, File, Blob // - Node only: Stream, Buffer data:&#123; firstName:'Fred' &#125;, //`timeout` 指定请求超时之前的毫秒数 //如果请求的时间超过`timeout`,请求将被中断 timeout:1000,//默认为 0（没有timeout) //`withCredentials` 指示是否是跨站点访问控制请求 //要使用证书吗 withCredentials:false //默认 //`adapter` 允许自定义处理请求，这使得测试更容易 //返回一个promise并提供一个有效的响应 （见lib/adapters/README.md） adapter:function(config)&#123; /*...*/ &#125;, //`auth`表示应该使用HTTP基本认证，并提供证书。 //这将设置一个`Authorization'头，覆盖任何现有的`Authorization'自定义头，使用`headers`设置。 auth: &#123; username:'janedoe', password: 's00pers3cret' &#125;, //`responseType`表示服务器将响应的数据类型 //类型包括：'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' responseType: 'json',//默认 //`responseEncoding`表示用于解码响应的编码 //注意：忽略“stream”或客户端请求的responseType responseEncoding: 'utf8', //默认 //`xsrfCookieName` 是要用作 xsrf 令牌的值的cookie的名称 xsrfCookieName: 'XSRF-TOKEN', // default // `xsrfHeaderName`是携带xsrf令牌值的http头的名称 xsrfHeaderName: 'X-XSRF-TOKEN', // default // `onUploadProgress`允许处理上传的进度事件 onUploadProgress: function (progressEvent) &#123; // 使用本地 progress 事件做任何你想要做的 &#125;, // `onDownloadProgress`允许处理下载的进度事件 onDownloadProgress: function (progressEvent) &#123; // Do whatever you want with the native progress event &#125;, // `maxContentLength`定义允许的http响应内容的最大大小 maxContentLength: 2000, // `validateStatus`定义是否解析或拒绝给定的promise // HTTP响应状态码。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被 // 拒绝。 validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // default &#125;, // `maxRedirects`定义在node.js中要遵循的重定向的最大数量。 // 如果设置为0，则不会遵循重定向。 maxRedirects: 5, // 默认 // `httpAgent`和`httpsAgent`用于定义在node.js中分别执行http和https请求时使用的自定义代理。 // 允许配置类似`keepAlive`的选项， // 默认情况下不启用。 httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // 'proxy'定义代理服务器的主机名和端口 // `auth`表示HTTP Basic auth应该用于连接到代理，并提供credentials。 // 这将设置一个`Proxy-Authorization` header，覆盖任何使用`headers`设置的现有的`Proxy-Authorization` 自定义 headers。 proxy: &#123; host: '127.0.0.1', port: 9000, auth: : &#123; username: 'mikeymike', password: 'rapunz3l' &#125; &#125;, // “cancelToken”指定可用于取消请求的取消令牌 // (see Cancellation section below for details) cancelToken: new CancelToken(function (cancel) &#123; &#125;) &#125;&#125; 响应模式请求的响应包含如下信息：12345678910111213141516171819//`data`是服务器提供的响应数据data:&#123;&#125;,//`status`是服务器响应的HTTP状态码status:200,//`statusText`是服务器响应的HTTP状态信息statusText:'OK',//`headers`服务器响应的所有头的名称都是小写的headers:&#123;&#125;,//`config`是为请求提供给`axios`的配置config:&#123;&#125;,//`request`是生成此响应的请求//它是node.js(重定向)中的最后一个ClientRequest实例而且是浏览器中的一个XMLHttpRequest实例request:&#123;&#125;&#125; 当使用then时，你将收到如下响应：12345678axios.get('/user/12345') .then(function (response) &#123; console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config); &#125;); 当使用catch或将rejection回调作为then的第二个参数传递时，响应将通过error对象传递，如处理错误部分所述。 配置默认值您可以指定将应用于每个请求的配置默认值。 全局axios默认值123axios.defaults.baseURL = 'https://api.example.com';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 自定义实例默认值1234567// 当生成实例时设置默认值const instance = axios.create(&#123; baseURL: 'https://api.example.com'&#125;);// 在实例创建后改变默认值instance.defaults.headers.common['Authorization'] = AUTH_TOKEN; 配置优先级顺序配置将与优先顺序合并。 顺序是lib / defaults.js中的库默认值，然后是实例的defaults属性，最后是请求的config参数。 后者将优先于前者。 这里有一个例子。123456789101112//使用库提供的配置默认值创建实例//此时，超时配置值为`0`，这是库的默认值var instance = axios.create（）; //覆盖库的超时默认值//现在所有请求将在超时前等待2.5秒instance.defaults.timeout = 2500; //覆盖此请求的超时，因为它知道需要很长时间instance.get（'/ longRequest'，&#123; timeout：5000&#125;）; 拦截器你可以截取请求或响应在被 then 或者 catch 处理之前1234567891011121314151617//添加请求拦截器axios.interceptors.request.use（function（config）&#123; //在发送请求之前做某事 return config; &#125;，function（error）&#123; //请求错误时做些事 return Promise.reject（error）; &#125;）; //添加响应拦截器axios.interceptors.response.use（function（response）&#123; //对响应数据做些事 return response; &#125;，function（error）&#123; //请求错误时做些事 return Promise.reject（error）; &#125;）; 如果你以后可能需要删除拦截器。12var myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor); 你可以将拦截器添加到axios的自定义实例。12var instance = axios.create();instance.interceptors.request.use(function () &#123;/*...*/&#125;); 处理错误1234567891011121314axios.get（'/ user / 12345'） .catch（function（error）&#123; if（error.response）&#123; //请求已发出，但服务器使用状态代码进行响应 //落在2xx的范围之外 console.log（error.response.data）; console.log（error.response.status）; console.log（error.response.headers）; &#125; else &#123; //在设置触发错误的请求时发生了错误 console.log（'Error'，error.message）; &#125;&#125; console.log（error.config）; &#125;）; 您可以使用validateStatus配置选项定义自定义HTTP状态码错误范围。12345axios.get（'/ user / 12345'，&#123; validateStatus：function（status）&#123; return status &lt; 500; //仅当状态代码大于或等于500时拒绝 &#125;&#125;&#125;） 消除您可以使用取消令牌取消请求。 axios cancel token API基于可取消的promise提议，目前处于阶段1。 您可以使用CancelToken.source工厂创建一个取消令牌，如下所示：12345678910111213var CancelToken = axios.CancelToken;var source = CancelToken.source（）;axios.get('/user/12345', &#123; cancelToken: source.token&#125;).catch(function(thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log('Request canceled', thrown.message); &#125; else &#123; // 处理错误 &#125;&#125;);//取消请求（消息参数是可选的）source.cancel（'操作被用户取消。'）; 您还可以通过将执行器函数传递给CancelToken构造函数来创建取消令牌：123456789101112var CancelToken = axios.CancelToken;var cancel; axios.get（'/ user / 12345'，&#123; cancelToken：new CancelToken（function executor（c）&#123; //一个执行器函数接收一个取消函数作为参数 cancel = c; &#125;）&#125;）; // 取消请求clear(); 注意：您可以使用相同的取消令牌取消几个请求。 使用application / x-www-form-urlencoded格式默认情况下，axios将JavaScript对象序列化为JSON。 要以应用程序/ x-www-form-urlencoded格式发送数据，您可以使用以下选项之一。 浏览器在浏览器中，您可以使用URLSearchParams API，如下所示：1234var params = new URLSearchParams();params.append('param1', 'value1');params.append('param2', 'value2');axios.post('/foo', params); 请注意，所有浏览器都不支持URLSearchParams，但是有一个polyfill可用（确保polyfill全局环境）。 或者，您可以使用qs库对数据进行编码：12var qs = require('qs');axios.post('/foo', qs.stringify(&#123; 'bar': 123 &#125;); Node.js在node.js中，可以使用querystring模块，如下所示：12var querystring = require('querystring');axios.post('http://something.com/', querystring.stringify(&#123; foo: 'bar' &#125;); 你也可以使用qs库。 Promiseaxios 依赖本机要支持ES6 Promise实现。 如果您的环境不支持ES6 Promises，您可以使用polyfill。 TypeScriptaxios包括TypeScript定义。12import axios from 'axios';axios.get('/user?ID=12345'); axios在很大程度上受到Angular提供的$http服务的启发。 最终，axios努力提供一个在Angular外使用的独立的$http-like服务。]]></content>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TODOLists]]></title>
    <url>%2F2019%2F05%2F21%2FTODOLists%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[剖析Vue原理--实现双向绑定MVVM]]></title>
    <url>%2F2019%2F05%2F15%2F%E5%89%96%E6%9E%90Vue%E5%8E%9F%E7%90%86-%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9AMVVM%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[收藏的一些网站]]></title>
    <url>%2F2019%2F05%2F15%2F%E5%91%A8%E6%9F%90%E6%94%B6%E8%97%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[简历在线制作：http://www.jiaobu365.com/]]></content>
      <tags>
        <tag>收藏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么call比apply快？]]></title>
    <url>%2F2019%2F05%2F14%2F%E4%B8%BA%E4%BB%80%E4%B9%88call%E6%AF%94apply%E5%BF%AB%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[在看源码的过程中，总会遇到这样的写法：12345678910var triggerEvents = function(events, args) &#123; var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2]; switch (args.length) &#123; case 0: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx); return; case 1: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1); return; case 2: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return; case 3: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return; default: while (++i &lt; l) (ev = events[i]).callback.apply(ev.ctx, args); return; &#125;&#125;; 作者会在参数为3个（包含3）以内时，优先使用 call 方法进行事件的处理。而当参数过多（多余3个）时，才考虑使用 apply 方法。这个就是因为 call 比 apply 快。 为什么call比apply快？Function.prototype.apply(thisArg,argArray) 如果 IsCallable（Function）为false，即 Function 不可以被调用，则抛出一个 TypeError 异常。 如果 argArray 为 null 或未定义，则返回调用 Function 的 [[Call]] 内部方法的结果，提供thisArg 和一个空数组作为参数。 如果 Type（argArray）不是 Object，则抛出 TypeError 异常。 获取 argArray 的长度。调用 argArray 的 [[Get]] 内部方法，找到属性 length。 赋值给 len。 定义 n 为 ToUint32（len）。 初始化 argList 为一个空列表。 初始化 index 为 0。 循环迭代取出 argArray。重复循环 while（index &lt; n） 将下标转换成String类型。初始化 indexName 为 ToString(index). 定义 nextArg 为 使用 indexName 作为参数调用argArray的[[Get]]内部方法的结果。 将 nextArg 添加到 argList 中，作为最后一个元素。 设置 index ＝ index＋1 返回调用 Function 的 [[Call]] 内部方法的结果，提供 thisArg 作为该值，argList 作为参数列表。 Function.prototype.call(thisArg[,arg1[,arg2,…]]) 如果 IsCallable（Function）为 false，即 Function 不可以被调用，则抛出一个 TypeError 异常。 定义 argList 为一个空列表。如果使用超过一个参数调用此方法，则以从arg1开始的从左到右的顺序将每个参数附加为 argList 的最后一个元素 返回调用func的[[Call]]内部方法的结果，提供 thisArg 作为该值，argList 作为参数列表。 我们可以看到，明显 apply 比 call 的步骤多很多。由于 apply 中定义的参数格式（数组），使得被调用之后需要做更多的事，需要将给定的参数格式改变（步骤8）。 同时也有一些对参数的检查（步骤2），在 call 中却是不必要的。另外一个很重要的点：在 apply 中不管有多少个参数，都会执行循环，也就是步骤 6-8，在 call 中也就是对应步骤3 ，是有需要才会被执行。 综上，call 方法比 apply 快的原因是 call 方法的参数格式正是内部方法所需要的格式。 转自:为什么call比apply快？]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法]]></title>
    <url>%2F2019%2F05%2F09%2F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[时间复杂度 通常使用最差的时间复杂度来衡量一个算法的好坏。常数时间O(1)代表这个操作和数据量没有关系，是一个固定时间的操作，比如四则运算。 对于一个算法来说，可能会计算出如下操作次数aN + 1,N代表数据量。那么该算法的时间复杂度就是O(N)。因为我们在计算时间复杂度的时候，数据量通常是非常大的，这时候低阶项和常数项可以忽略不计。 当然可能会出现两个算法都是O(N)的时间复杂度，那么对比两个算法的好坏就要通过对比低阶项和常数项了。 位运算 位运算在算法中很有用，速度可以比四则运算快很多。 在学习位运算之前应该知道十进制如何转二进制，二进制如何转十进制。这里说明下简单的计算方式 十进制33可以看成是32+1，并且33应该是六位二进制的（因为33近似32，而32是2的五次方，所以是六位），那么十进制33就是100001，只要是2的次方，那么就是1否则都为0 那么二进制100001同理，首位是2^5,末位是2^0,相加得出33 左移&lt;&lt;110 &lt;&lt; 1 // -&gt; 20 左移就是将二进制全部往左移动，10在二进制中表示为1010，左移一位后变成10100，转换为十进制也就是20，所以基本可以把左移看成以下公式 a*(2^b)。在此处 a为10 b为1。 右移&gt;&gt;110 &gt;&gt; 1 //-5 右移就是将二进制全部往右移动并去除多余的右边，10在二进制中表示为1010，右移一位后变成101,转换为十进制也就是5，所以基本可以把右移看成int v = a / (2^b)在此处 a为10，b为1右移很好用，比如可以用在二分算法中取出中间值113 &gt;&gt; 1 // -&gt; 6 按位操作按位与每一位都是1，结果才是112348 &amp; 7 // -&gt; 0//1000 &amp; 0111 -&gt; 0000 -&gt; 08 &amp; 8 // -&gt; 8//1000 &amp; 1000 -&gt; 1000 -&gt; 8 按位或其中一位为1，结果就是1128 | 7 // -&gt; 15// 1000 | 0111 -&gt; 1111 -&gt;15 按位异或每一位都不同，结果才为112348 ^ 7 // -&gt; 15// 1000 ^ 0111 -&gt; 1111 -&gt; 158 ^ 8 // -&gt; 0// 1000 ^ 1000 -&gt; 0000 -&gt; 0 从以上代码中可以发现按位异或就是不进位加法 面试题 ：两个数不使用四则运算得出和这道题中可以按位异或，以为按位异或就是不进位加法，8^8 = 0,如果进位了，就是16了，所以我们只需要将两个数进行异或操作，然后进位。那么也就是说两个二进制都是1的位置，左边应该有一个进位1，所以可以得出一下公式 a + b =(a ^ b) + ((a &amp; b) &lt;&lt; 1),然后通过迭代的方式模拟加法。1234567function sum(a,b)&#123; if(a == 0) return b if(b == 0) return a let newA = a ^ b let newB = (a &amp; b) &lt;&lt; 1 return sum(newA,newB)&#125; 排序 以下两个函数是排序中会用到的通用函数，就不一一写了123456789function checkArray(array)&#123; if(!array || array.length &lt;= 2) return&#125;function swap(array,left,right)&#123; let rightValue = array[right] array[right] = array[left] array[left] = rightValue&#125; 冒泡排序冒泡排序的原理如下，从第一个元素开始，把当前元素和下一个索引元素进行比较。如果当前元素大，那么就交换位置，重复操作直到比较到最后一个元素，那么此时最后一个元素就是该数组中最大的数。下一轮重复以上操作，但是此时最后一个元素已经是最大数了，所以不需要再比较最后一个元素，只需要比较到length-1的位置。12345678910function bubble(array)&#123; checkArray(array) for(let i = array.length - 1; i &gt; 0; i--)&#123; for(let j = 0; j &lt; i; j++)&#123; if(array[j] &gt; array[j+1]) swap(array,j,j + 1) &#125; &#125; return array&#125; 该算法的操作次数是一个等差数列 n + (n - 1) + (n - 2) + 1 ，去掉常数项以后得出时间复杂度是 O(n * n) 插入排序插入排序的原理如下。第一个元素默认是已排序元素，取出下一个元素和当前元素比较，如果当前元素大就交换位置。那么此时第一个元素就是当前的最小数，所以下次取出操作从第三个元素开始，向前对比，重复之前的操作。12345678function insertion(array)&#123; checkArray() for (let i = 1; i &lt; array.length; i++)&#123; for(let j = i - 1; j &gt;= 0 &amp;&amp; array[j] &gt; array[j + 1]; j--) swap(array, j, j+1) &#125; return array&#125; 该算法的操作次数是一个等差数列 n + (n - 1) + (n - 2) + 1 ，去掉常数项以后得出时间复杂度是 O(n * n) 选择排序选择排序的原理如下。遍历数组，设置最小值的索引为0，如果取出的值比当前最小值小，就替换最小值索引，遍历完成后，将第一个元素和最小值索引上的值交换。如果操作后，第一个元素就是数组中的最小值，下次遍历就可以从索引1开始重复上述操作。1234567891011function selection(array)&#123; checkArray(array) for(let i = 0; i &lt; array.length-1; i++)&#123; let minIndex = i for(let j = i + 1;j &lt; array.length; j++)&#123; minIndex = array[j] &lt; array[minIndex] ? j : minIndex &#125; swap(array, i, minIndex) &#125; return array&#125; 该算法的操作次数是一个等差数列 n + (n - 1) + (n - 2) + 1 ，去掉常数项以后得出时间复杂度是 O(n * n) 归并排序归并排序的原理如下。递归的将数组两两分开直到最多包含两个元素，然后将数组排序合并，最终合并为排序好的数组。假设我有一组数组 [3, 1, 2, 8, 9, 7, 6]，中间数索引是 3，先排序数组 [3, 1, 2, 8] 。在这个左边数组上，继续拆分直到变成数组包含两个元素（如果数组长度是奇数的话，会有一个拆分数组只包含一个元素）。然后排序数组 [3, 1] 和 [2, 8] ，然后再排序数组 [1, 3, 2, 8] ，这样左边数组就排序完成，然后按照以上思路排序右边数组，最后将数组 [1, 2, 3, 8] 和 [6, 7, 9] 排序。123456789101112131415161718192021222324252627function mergeSort(arr)&#123; var len = arr.length; if(len&lt;2)&#123; return arr; &#125; var middle = Math.floor(len/2), left = arr.slice(0,middle), right = arr.slice(middle); return merge(mergeSort(left),mergeSort(right));&#125;function merge(left,right)&#123; var result = []; while(left.length &amp;&amp; right.length)&#123; if(left[0]&lt;=right[0]&#123; result.push(left.shift()); &#125;else&#123; result.push(right.shift()); &#125; &#125; while(left.length)&#123; result.push(left.shift()); &#125; while(right.length)&#123; result.push(right.shift()); &#125; return result;&#125; 该算法的操作次数是可以这样计算：递归了两次，每次数据量是数组的一半，并且最后把整个数组迭代了一次，所以得出表达式 2T(N / 2) + T(N) （T 代表时间，N 代表数据量）。根据该表达式可得出时间复杂度为 O(N * logN) 快排原理： .从数列中挑出一个元素，称为 “基准”（pivot）； .重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； .递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。123456789101112131415161718var quickSort2 = function(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort2(left).concat([pivot], quickSort2(right));&#125;; var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(quickSort2(arr)); 堆排序堆排序利用二叉堆的特性来做，二叉堆通常用数组表示，并且二叉堆是一颗完全二叉树（所有叶节点（最底层的节点）都是从左往右顺序排序，并且其他层的节点都是满的）。二叉堆又分为大根堆与小根堆 大根堆是某个节点的所有子节点的值都比他小 小根堆是某个节点的所有子节点的值都比他大堆排序的原理就是组成一个大根堆或者小根堆。以小根堆为例，某个节点的左边子节点索引是 i2+1,右边是 i2+2，父节点是 (i-1)/2。 首先遍历数组，判断该节点的父节点是否比他小，如果小就交换位置并继续判断，直到他的父节点比他大 重新以上操作1，直到数组首位是最大值 然后将首位与末尾交换位置并将数组长度减一，表示数组末尾已是最大值，不需要再比较大小 对比左右节点哪个大，然后记住大的节点的索引并且和父节点对比大小，如果子节点大就交换位置 重复以上操作 3 - 4 直到整个数组都是大根堆。]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2019%2F05%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[栈 概念 栈式一个线性结构，在计算机中是一个相当常见的数据结构。特点是只能在某一端添加或删除数据，遵循先进后出的原则 实现每种数据结构都可以用很多种方式来实现，其实可以把栈看成是数组的一个子集，所以这里使用数组来实现1234567891011121314151617181920class Stack &#123; constructor() &#123; this.stack = [] &#125; push(item) &#123; this.stack.push(item) &#125; pop() &#123; this.stack.pop() &#125; peek() &#123; return this.stack[this.getCount() - 1] &#125; getCount() &#123; return this.stack.length &#125; isEmpty() &#123; return this.getCount() === 0 &#125;&#125; 应用匹配括号1234567891011121314151617181920212223var isValid = function(s)&#123; let map = &#123; '(': -1, ')': 1, '[': -2, ']': 2, '&#123;': -3, '&#125;': 3 &#125; let stack = [] for(let i = 0; i &lt; s.length; i++)&#123; if(map[s[i]] &lt; 0)&#123; stack.push(s[i]) &#125;else&#123; let last = stack.pop() if(map[last] + map[s[i]] != 0) return false &#125; &#125; if(stack.length &gt; 0) return false return true&#125; 队列 概念队列一个线性结构，特点是在某一端添加数据，在另一端删除数据，遵循先进先出的原则。 实现这里会讲解两种实现队列的方法，分别是单链队列和循环队列。 单链队列1234567891011121314151617181920class Queue &#123; constructor() &#123; this.queue = [] &#125; enQueue(item) &#123; this.queue.push(item) &#125; deQueue() &#123; return this.queue.shift() &#125; getHeader() &#123; return this.queue[0] &#125; getLength() &#123; return this.queue.length &#125; isEmpty() &#123; return this.getLength() === 0 &#125;&#125; 因为单链队列在出队操作的时候需要O(n)的时间复杂度，所以引入了循环队列。循环队列的出队操作平均是O(1)的时间复杂度。 循环队列`javascriptclass sqQueue { constructor(length){ this.queue = new Array(length + 1) //队头 this.first = 0 //队尾 this.last = 0 //当前队列大小 this.size = 0 } enQueue(item) { //判断队尾+1是否为队头 //如果是就代表需要扩容数组 // % this.queue.length是为了防止数组越界 if(this.first === (this.last + 1) % this.queue.length) { this.resize(this.getLength() *2 + 1) } thisqueue[this.last] = item this.size++ this.last = (this.last + 1) % this.queue.length } deQueue() { if(this.isEmpty()){ throw Error(‘Queue is empty’) } let r = this.queue[this.first] this.queue[this.first] = null //菜鸡看不懂写不下去辽 }}]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写代码]]></title>
    <url>%2F2019%2F05%2F09%2F%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[实现new操作符 new操作符做了什么？ 它创建了一个全新的对象。 它会被执行[[Prototype]]（也就是proto）链接。 它使this指向新创建的对象。 通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。 如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用。 实现：12345678function myNew(func)&#123; let res = &#123;&#125; res.__proto__ = func.prototype let ret = func.apply(res,Array.prototype.slice.call(arguments,1)); return ret instanceof Object ? ret : res &#125;slice(start,end) ==&gt; 返回一个从[start（从0开始） ,end)的新数组 实现一个instanceofinstanceof的原理？instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。 实现：1234567891011function myInstanceof(left, right) &#123; let prototype = right.prototype left = left.__proto__ while (true) &#123; if (left === null || left === undefined) return false if (prototype === left) return true left = left.__proto__ &#125;&#125; 分析： 首先获取类型的原型 然后获得对象的原型 然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null 实现一个call &amp; applycall123456789101112实现：Function.prototype.myCall = function(context)&#123; if(typeof this !== 'function')&#123; throw new TypeError('Error') &#125;context = context || windowcontext.fn = thisconst args = [...arguments].slice(1)const result = context.fn(...args)delete context.fnreturn result&#125; 以下是对实现的分析： 首先 context 为可选参数，如果不传的话默认上下文为 window接下来给 context 创建一个 fn 属性，并将值设置为需要调用的函数因为 call 可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来然后调用函数并将对象上的函数删除 apply12345678910111213141516Function.prototype.myApply = function(context) &#123;if (typeof this !== 'function') &#123;throw new TypeError('Error')&#125;context = context || windowcontext.fn = thislet result// 处理参数和 call 有区别if (arguments[1]) &#123;result = context.fn(...arguments[1])&#125; else &#123;result = context.fn()&#125;delete context.fnreturn result&#125; 实现一个bind123456789101112131415Function.prototype.myBind = function (context) &#123;if (typeof this !== 'function') &#123;throw new TypeError('Error')&#125;const _this = thisconst args = [...arguments].slice(1)// 返回一个函数return function F() &#123;// 因为返回了一个函数，我们可以 new F()，所以需要判断if (this instanceof F) &#123;return new _this(...args, ...arguments)&#125;return _this.apply(context, args.concat(...arguments))&#125;&#125; 以下是对实现的分析： 前几步和之前的实现差不多，就不赘述了bind 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 new 的方式，我们先来说直接调用的方式对于直接调用来说，这里选择了 apply 的方式实现，但是对于参数需要注意以下情况：因为 bind 可以实现类似这样的代码 f.bind(obj, 1)(2)，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 args.concat(…arguments)最后来说通过 new 的方式，在之前的章节中我们学习过如何判断 this，对于 new 的情况来说，不会被任何方式改变 this，所以对于这种情况我们需要忽略传入的 this 实现一个简易版的promise12345678910111213const PENDING = 'pending'const RESOLVED = 'resolved'const REJECTED = 'rejected'function MyPromise(fn) &#123; const that = this that.state = PENDING that.value = null that.resolvedCallbacks = [] that.rejectedCallbacks = [] // 待完善 resolve 和 reject 函数 // 待完善执行 fn 函数&#125; 首先我们创建了三个常量用于表示状态，对于经常使用的一些值都应该通过常量来管理，便于开发及后期维护 在函数体内部首先创建了常量 that，因为代码可能会异步执行，用于获取正确的 this 对象 一开始 Promise 的状态应该是 pendingvalue 变量用于保存 resolve 或者 reject 中传入的值 resolvedCallbacks 和 rejectedCallbacks 用于保存 then 中的回调，因为当执行完 Promise 时状态可能还是等待中，这时候应该把 then 中的回调保存起来用于状态改变时使用 接下来我们来完善 resolve 和 reject 函数，添加在 MyPromise 函数体内部123456789101112131415function resolve(value) &#123; if (that.state === PENDING) &#123; that.state = RESOLVED that.value = value that.resolvedCallbacks.map(cb =&gt; cb(that.value)) &#125;&#125;function reject(value) &#123; if (that.state === PENDING) &#123; that.state = REJECTED that.value = value that.rejectedCallbacks.map(cb =&gt; cb(that.value)) &#125;&#125; 这两个函数代码类似，就一起解析了 首先两个函数都得判断当前状态是否为等待中，因为规范规定只有等待态才可以改变状态 将当前状态更改为对应状态，并且将传入的值赋值给 value 遍历回调数组并执行 完成以上两个函数以后，我们就该实现如何执行 Promise 中传入的函数了12345try &#123; fn(resolve, reject)&#125; catch (e) &#123; reject(e)&#125; 实现很简单，执行传入的参数并且将之前两个函数当做参数传进去 要注意的是，可能执行函数过程中会遇到错误，需要捕获错误并且执行 reject 函数 最后我们来实现较为复杂的 then 函数1234567891011121314151617181920MyPromise.prototype.then = function(onFulfilled, onRejected) &#123; const that = this onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v =&gt; v onRejected = typeof onRejected === 'function' ? onRejected : r =&gt; &#123; throw r &#125; if (that.state === PENDING) &#123; that.resolvedCallbacks.push(onFulfilled) that.rejectedCallbacks.push(onRejected) &#125; if (that.state === RESOLVED) &#123; onFulfilled(that.value) &#125; if (that.state === REJECTED) &#123; onRejected(that.value) &#125;&#125; 首先判断两个参数是否为函数类型，因为这两个参数是可选参数 当参数不是函数类型时，需要创建一个函数赋值给对应的参数，同时也实现了透传，比如如下代码 123// 该代码目前在简单版中会报错// 只是作为一个透传的例子Promise.resolve(4).then().then((value) =&gt; console.log(value)) 接下来就是一系列判断状态的逻辑，当状态不是等待态时，就去执行相对应的函数。如果状态是等待态的话，就往回调函数中 push 函数，比如如下代码就会进入等待态的逻辑 1234567new MyPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1) &#125;, 0)&#125;).then(value =&gt; &#123; console.log(value)&#125;) 放在一起：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const PENDING = 'pending'const RESOLVED = 'resolved'const REJECTED = 'rejected'function Mypromise(fn)&#123; const that = this that.state = PENDING that.value = null that.resolvedCallbacks = [] that.rejectedCallbacks = [] function resolve(value)&#123; if(that.state === PENDING)&#123; that.state = RESOLVED that.value = value that.resolvedCallbacks.map(cb =&gt; cb(that.value)) &#125; &#125; function reject(value)&#123; if(that.state === PENDING)&#123; that.state = REJECTED that.value = value that.rejectedCallbacks.map(cb =&gt; cb(that.value)) &#125; &#125;&#125;try&#123; fn(resolve,reject)&#125;catch(e)&#123; reject(e)&#125;Mypromise.prototype.then = function(onFulfilled,onRejected)&#123; const that = this onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v =&gt; v onRejected = typeof onRejected ==='function' ? onRejected : r =&gt; &#123; throw r &#125; if(that.state === PENDING)&#123; that.resolvedCallbacks.push(onFulfilled) that.rejectedCallbacks.push(onRejected) &#125; if(that.state === RESOLVED)&#123; onFulfilled(that.value) &#125; if(that.state === REJECTED)&#123; onRejected(that.value) &#125;&#125;new MyPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1) &#125;, 0)&#125;).then(value =&gt; &#123; console.log(value)&#125;) 实现防抖123456789101112131415161718function debounce(fn)&#123; let timeout = null;//创建一个标记用来存放定时器的返回值 return function()&#123; clearTimeout(timeout); //每当用户输入的时候把前一个setTimeout clear掉 timeout = setTimeout(()=&gt;&#123; //然后又创建一个新的setTimeout，这样就能保证输入字符后的interval间隔内如果还有字符输入的话，就不会执行fn函数 fn.apply(this,arguments); &#125;,500); &#125;;&#125;function sayHi()&#123; console.log('防抖成功')&#125;var inp = document.getElementById('inp');inp.addEventListener('input',debounce(sayHi));//防抖 实现节流12345678910111213141516171819function throttle(fn)&#123; let canRun = true;//通过闭包保存一个标记 return function()&#123; if(!canRun) return; //在函数开头判断标记是否为true,不为true则return canRun = false; //立即设置为false setTimeout(()=&gt;&#123; //将外部传入的函数的执行放在setTimeout中 fn.apply(this,arguments); //最后在setTimeout执行完毕后再把标记设置为true（关键）表示可以执行下一次循环了。当定时器没有执行的时候标记永远时false，再开头被return掉 canRun = true; &#125;,500) &#125;&#125;function sayHi(e)&#123; console.log(e.target.innerWidth,e.target.innerHeight);&#125;window.addEventListener('resize',throttle(sayHi)); 继承原型链继承123456789101112function Parent()&#123; this.name = "Dad"&#125;Parent.prototype.getName = function()&#123; console.log(this.name);&#125;function Child()&#123;&#125;## Child.prototype = new Parent();var child1 = new Child();console.log(child.getName()) 问题：1.引用类型的属性被所有实例共享，如果在实例1中修改了属性的值，实例2也会被修改2.在创建Child的实例时，不能向Parent传参 借用构造函数继承1234567891011function Parent()&#123; this.name = ['kevin','daisy'];&#125;function Child()&#123; ## Parent.call(this)&#125;## var child1 = new Child();child1.name.push('yayu');console.log(child1.names);//['kevin','daisy','yayu']var child2 = new Child();console.log(child2.names);//['kevin','daisy'] 缺点：方法都在构造函数中定义，每次创建实例都会创建一遍方法 组合继承|经典继承(最常用)123456789101112131415161718192021function Parent(name)&#123; this.name = name; this.colors = ['red','blue','green'];&#125;Parent.prototype.getName = function()&#123; console.log(this.name)&#125;function Child(name,age)&#123; ## Parent.call(this,name) this.age = age;&#125;## Child.prototype = new Parent();var child1 = new Child('kevin','18')child1.colors.push('black');console.log(child1.name);//kevinconsole.log(child1.age);//18console.log(child1.colors);//['red','blue','green','black']var child2 = new Child('daisy','20');console.log(child2.name)//daisyconsole.log(child2.age)//20console.log(child2.colors)//['red','blue','green'] 缺点是会调用两次构造函数1.设置子类型实例的原型的时候 Child.prototype = new Parent();2.一次是在创建子类型实例的时候 var child1 = new Child(‘kevin’,’18’); 原型式继承123456789101112131415function createObj(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;var person = &#123; name:'kevin', friends:['daisy','kelly']&#125;var person1 = createObj(person);var person2 = createObj(person);person1.name = 'person';console.log(person2.name); // kevinperson1.firends.push('taylor');console.log(person2.friends); // ["daisy", "kelly", "taylor"] 缺点：包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样 寄生组合式继承1234567891011121314151617function Parent(name)&#123; this.name = name; this.color = ['red','blue','green'];&#125;Parent.prototype.getName = function()&#123; console.log(this.name);&#125;function Child(name,age)&#123; Parent.call(this,name); this.age = age;&#125;//关键的三步var F = function()&#123;&#125;;F.prototype = Parent.prototype;Child.prototype = new F();var child1 = new Child('kevin','18');console.log(child1); class继承1234567891011121314151617class Parent&#123; constructor(value)&#123; this.val = value &#125; getValue()&#123; console.log(this.val) &#125;&#125;class Child extend Parent&#123; constructor(value)&#123; super(value) this.val = value &#125;&#125;let child = new Child(1)child.getValue()//1child instanceof Parent //true 说明：class 实现继承的核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super，因为这段代码可以看成 Parent.call(this, value)。 经典闭包123456789101112131415161718192021222324252627282930313233//问题for (var i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i) &#125;, i * 1000)&#125;//解决1-使用闭包for (var i = 1; i &lt;= 5; i++) &#123; (function(j) &#123; setTimeout(function timer() &#123; console.log(j) &#125;, j * 1000) &#125;)(i)&#125;//解决2-使用setTimeout的第三个参数for (var i = 1; i &lt;= 5; i++) &#123; setTimeout( function timer(j) &#123; console.log(j) &#125;, i * 1000, i )&#125;//解决3-letfor (let i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i) &#125;, i * 1000)&#125; Promise-all1234567891011121314151617Promise.all = function(promises)&#123; return new Promise((resolve,reject) =&gt; &#123; let results = []; let count = 0; for(let i = 0, len = promises.length; i &lt; len; i++)&#123; promises[i].then((res) =&gt; &#123; results[i] = res; count++; if(count === len)&#123; resolve(results); &#125; &#125;,(err) =&gt; &#123; return reject(err); &#125;); &#125; &#125;)&#125; Promise-race1234567Promise.race = function(promises)&#123; return new Promise((resolve,reject) =&gt; &#123; for(let i = 0; i &lt; promises.length; i++)&#123; promises[i].then(resolve,reject); &#125; &#125;)&#125; 实现一个基本的Event Bus12345678910111213141516171819202122232425class EventEmitter&#123; constructor()&#123; //存储事件 this.events = this.events || new Map() &#125; //监听事件 addListener(type,fn)&#123; if(!this.events.get(type))&#123; this.events.set(type,fn) &#125; &#125; //触发事件 emit(type)&#123; let handle = this.events.get(type) handle.apply(this,[...arguments].slice(1)) &#125;&#125;//测试let emitter = new EventEmitter()//监听事件emitter.addListener('ages',age =&gt; &#123; console.log(age)&#125;)//触发事件emitter.emit('ages',18)//18 简单实现一个双向数据绑定1234567891011121314151617181920let obj = &#123;&#125;let input = document.getElementById('input')let span = document.getElementById('span')//数据劫持Object.defineProperty(obj,'text',&#123; configurable:true, enumerable:true, get()&#123; console.log('获取数据了') &#125;, set(newVal)&#123; console.log("数据更新了") input.value = newVal span.innerHTML = newVal &#125;&#125;)//输入监听input.addEventListener('keyup',function(e)&#123; obj.text = e.target.value&#125;) 实现一个简单的路由1234567891011121314151617181920212223//hash路由class Route&#123; constructor()&#123; //路由存储对象 this.routes = &#123;&#125; //当前hash this.currentHash = '' //绑定this，避免监听时this指向改变 this.freshRoute = this.freshRoute.bind(this) //监听 window.addEventListener('load',this.freshRoute,false) window.addEventListener('hashchange',this.freshRoute,false) &#125; //存储 storeRoute(path,cb)&#123; this.routes[path] = cb || function ()&#123;&#125; &#125; //更新 freshRoute()&#123; this.currentHash = location.hash.slice(1) || '/' this.routes[this.currentHash]() &#125;&#125; 实现懒加载12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Lazyload&lt;/title&gt; &lt;style&gt; .image-item &#123; display: block; margin-bottom: 50px; height: 200px;//一定记得设置图片高度 &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/1.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/2.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/3.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/4.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/5.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/6.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/7.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/8.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/9.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/10.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/11.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/12.png"/&gt;&lt;script&gt;var viewHeight =document.documentElement.clientHeight//获取可视区高度function lazyload()&#123;var eles=document.querySelectorAll（'img[data-original][lazyload]'）Array.prototype.forEach.call(eles,function(item,index)&#123;var rectif(item.dataset.original==="") returnrect=item.getBoundingClientRect()// 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置if(rect.bottom&gt;=0 &amp;&amp; rect.top &lt; viewHeight)&#123;!function()&#123; var img=new Image() img.src=item.dataset.original img.onload=function()&#123; item.src=img.src &#125;item.removeAttribute（"data-original"）//移除属性，下次不再遍历item.removeAttribute（"lazyload"） &#125;() &#125; &#125;)&#125;lazyload()//刚开始还没滚动屏幕时，要先触发一次函数，初始化首页的页面图片document.addEventListener（"scroll"，lazyload)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; rem实现原理123456789//原始配置function setRem()&#123; let doc = document.documentElement let width = doc.getBoundingClientRect().width let rem = width / 75 doc.style.fontSize = rem + 'px'&#125;//监听窗口变化addEventListener("resize",setRem) 手写AJAX123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 1. 简单流程// 实例化let xhr = new XMLHttpRequest()// 初始化xhr.open(method, url, async)// 发送请求xhr.send(data)// 设置状态变化回调处理请求结果xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyStatus === 4 &amp;&amp; xhr.status === 200) &#123; console.log(xhr.responseText) &#125;&#125;// 2. 基于promise实现 function ajax (options) &#123; // 请求地址 const url = options.url // 请求方法 const method = options.method.toLocaleLowerCase() || 'get' // 默认为异步true const async = options.async // 请求参数 const data = options.data // 实例化 const xhr = new XMLHttpRequest() // 请求超时 if (options.timeout &amp;&amp; options.timeout &gt; 0) &#123; xhr.timeout = options.timeout &#125; // 返回一个Promise实例 return new Promise ((resolve, reject) =&gt; &#123; xhr.ontimeout = () =&gt; reject &amp;&amp; reject('请求超时') // 监听状态变化回调 xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState == 4) &#123; // 200-300 之间表示请求成功，304资源未变，取缓存 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) &#123; resolve &amp;&amp; resolve(xhr.responseText) &#125; else &#123; reject &amp;&amp; reject() &#125; &#125; &#125; // 错误回调 xhr.onerror = err =&gt; reject &amp;&amp; reject(err) let paramArr = [] let encodeData // 处理请求参数 if (data instanceof Object) &#123; for (let key in data) &#123; // 参数拼接需要通过 encodeURIComponent 进行编码 paramArr.push(encodeURIComponent(key) + '=' + encodeURIComponent(data[key])) &#125; encodeData = paramArr.join('&amp;') &#125; // get请求拼接参数 if (method === 'get') &#123; // 检测url中是否已存在 ? 及其位置 const index = url.indexOf('?') if (index === -1) url += '?' else if (index !== url.length -1) url += '&amp;' // 拼接url url += encodeData &#125; // 初始化 xhr.open(method, url, async) // 发送请求 if (method === 'get') xhr.send(null) else &#123; // post 方式需要设置请求头 xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded;charset=UTF-8') xhr.send(encodeData) &#125; &#125;)&#125; 实现拖拽1234567891011121314151617181920212223242526272829303132window.onload = function () &#123; // drag处于绝对定位状态 let drag = document.getElementById('box') drag.onmousedown = function(e) &#123; var e = e || window.event // 鼠标与拖拽元素边界的距离 = 鼠标与可视区边界的距离 - 拖拽元素与边界的距离 let diffX = e.clientX - drag.offsetLeft let diffY = e.clientY - drag.offsetTop drag.onmousemove = function (e) &#123; // 拖拽元素移动的距离 = 鼠标与可视区边界的距离 - 鼠标与拖拽元素边界的距离 let left = e.clientX - diffX let top = e.clientY - diffY // 避免拖拽出可视区 if (left &lt; 0) &#123; left = 0 &#125; else if (left &gt; window.innerWidth - drag.offsetWidth) &#123; left = window.innerWidth - drag.offsetWidth &#125; if (top &lt; 0) &#123; top = 0 &#125; else if (top &gt; window.innerHeight - drag.offsetHeight) &#123; top = window.innerHeight - drag.offsetHeight &#125; drag.style.left = left + 'px' drag.style.top = top + 'px' &#125; drag.onmouseup = function (e) &#123; this.onmousemove = null this.onmouseup = null &#125; &#125;&#125; 实现Event(event bus)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class EventEmitter&#123; constructor()&#123; this._events = this._events || new Map();//存储事件/回调键值对 this._maxListeners = this._maxListeners || 10;//设立监听上限 &#125;&#125;//触发名为type的事件EventEmitter.prototype.emit = function(type,...args)&#123; let handler; handler = this._events.get(type); if(Array.isArray(handler))&#123; //如果是一个数组说明有多个监听者，需要依次触发里面的函数 for(let i = 0; i &lt; handler.length; i++)&#123; if(args.length &gt; 0)&#123; handler[i].apply(this,args); &#125;else&#123; handler[i].call(this); &#125; &#125; &#125;else&#123; //单个函数的情况我们直接触发即可 if(args.length &gt; 0)&#123; handler.apply(this,args); &#125;else&#123; handler.call(this); &#125; &#125; return true;&#125;;//监听名为type的事件EventEmitter.prototype.addListener = function (type,fn)&#123; const handler = this._events.get(type);//获取对应事件名称的函数清单 if(!handler)&#123; this._events.set(type,fn); &#125;else if(handler &amp;&amp; typeof handler === 'function')&#123; //如果handler是函数说明只有一个监听者 this._events.set(type,[handler,fn]);//多个监听者我们需要用数组存储 &#125;else&#123; handler.push(fn);//已经有多个监听者，那么直接往数组里push函数即可 &#125;&#125;;EventEmitter.prototype.removeListener = function(type,fn)&#123; const handler = this._events.get(type);//获取对应事件名称的函数清单 //如果是函数，说明只被监听了一次 if(handler &amp;&amp; typeof handler === 'function')&#123; this._events.delete(type,fn); &#125;else&#123; let postion; //如果handler是数组，说明被监听多次要找到对应的函数 for(let i = 0; i &lt; handler.length; i++)&#123; if(handler[i] === fn)&#123; postion = i; &#125;else&#123; postion = -i; &#125; &#125; //如果找到匹配的函数，从数组中清除 if(postion !== -1)&#123; //找到数组对应的位置，直接清除此回调 handler.splice(postion,1); //如果清除后只有一个函数,那么取消数组，以函数形式保存 if(handler.length === 1)&#123; this._events.set(type,handler[0]); &#125; &#125;else&#123; return this; &#125; &#125;&#125;; 模拟Object.createObject.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。123456function create(proto)&#123; function F()&#123;&#125; F.prototype = proto; return new F();&#125; 模拟一个map12345678Array.prototype.myMap = function( fn )&#123; let _arr = this, len = _arr.length, param2 = arguments[1] || window, newArr = []; for( let i = 0; i &lt; len; i ++ )&#123; newArr[i] = fn.apply( param2, [ _arr[i], i, _arr ] ) &#125;return newArr;&#125;]]></content>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件通信]]></title>
    <url>%2F2019%2F04%2F17%2Fvue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[组件 组件是可以复用的Vue实例 在Vue中，根据注册方式的不同，可以分为： 局部组件（局部注册） 全局组件（全局注册） 顾名思义，全局注册的组件，可以用在 Vue 实例的任意模板中。但是带来的隐患是，在 webpack 模块化构建时，即便你没有在项目中使用这个组件，依然会打包到最终的项目代码中。而局部组件，则需要在使用到的实例中注册该组件。1234567891011121314151617181920212223// 全局注册// install.jsimport Icon from './Icon.vue';const install = &#123; install:function(Vue)&#123; Vue.component('VIcon', Icon); &#125;&#125;;export default install;// main.jsimport install from './install.js'; // 引入全局插件Vue.use(install); // 注册// 局部注册import VIcon from './Icon.vue';export default&#123; components: &#123; VIcon &#125;&#125;// 使用&lt;v-icon&gt; &lt;/v-icon&gt; 根据应用场景的不同，又可以分为： 页面组件：我们使用 Vue 时，每个路由代表的页面，都可以称之为组件。 基础组件：就像上面栗子中的 Icon 组件，就是一个典型的基础组件。基本上不掺杂业务逻辑，在项目中可能被大量使用，易于移植。类似的基础组件还有 Button、Input 等，常见于各类 UI 组件库。 业务组件：业务组件和项目具体的业务逻辑有大量耦合，一般抽离于当前项目。 以上就是组件的简单介绍，那我们到底为什么要推崇组件化？组件化有什么好处？复用？我个人认为组件化最大的好处，便是解耦，易于项目管理。所以在大型项目管理中，组件化是非常有必要的。当然，这并不是今天学习的重点，以后有机会再聊。正因为在 Vue 中处处都是组件，而我们也偏向于组件化、模块化。那我们在一堆组件中，便需要解决一个问题 — 组件间通信。下面，我们就进入今天的主题，Vue 的组件间通信。 组件间通信 PropsVue 中，最基本的通信方式就是 Props，它是父子组件通信中父组件传值给子组件的一种方式。它允许以数组形式接收，但是更推荐你开启类型检查的形式1234567891011121314151617181920212223242526//communication.vue&lt;communication-sub v-bind="dataProps"&gt;&lt;/communication-sub&gt;//v-bind="dataProps"等同于:title="title"，适用于多个参数一起传递...data()&#123; return &#123; dataProps:&#123; title:'我是父组件的值' &#125; &#125;&#125;//communication-sub.vue&lt;div class="communication-sub"&gt; &#123;&#123;title&#125;&#125;&lt;/div&gt;...props:['title']//更推荐开启类型检查props:&#123; title:&#123; type:String, required:true, default:''//允许指定默认值，引用类型需要函数返回 &#125;&#125;... 我们都知道，Props 是单向数据流，这是 Vue 为了避免子组件意外改变父组件的状态，从而导致数据流向难以理解而做出的限制。所以 Vue 推荐需要改动的时候，通过改变父组件的值从而触发 Props 的响应。或者，我们可以在接收非引用类型的值时，使用子组件自身的 data 做一次接收。123456props: ['title'],data: function () &#123; return &#123; text: this.title &#125;;&#125; 为什么是非引用类型呢，因为在 JavaScript 中，引用类型的赋值，实际是内存地址的传递。所以上面栗子中的简单赋值，显然会指向同一个内存地址，所以如果是数组或是对象，你可能需要一次深拷贝。1let obj = JSON.parse(JSON.stringify(obj)); 上面这个操作有一些缺陷，不能序列化函数、undefined、循环引用等.事实上，在 Props 是引用类型时，单独修改对象、数组的某个属性或下标，Vue 并不会抛出错误。当然，前提是你要非常清楚自己在做什么，并写好注释，防止你的小伙伴们疑惑。有的同学可能知道，在组件上绑定的属性，如果没有在组件内部用 Props 声明，会默认绑定到组件的根元素上去。还是之前的栗子：1&lt;communication-sub v-bind="dataProps" class="one" type="div"&gt;&lt;/communication-sub&gt; 这是 Vue 默认处理的，而且，除了 class 和 style 采用合并策略，其它特性（如上栗 type）会替换掉原来根元素上的属性值。当然，我们也可以显示的在组件内部关闭掉这个特性：123...inheritAttrs: false,props: ['title'] 利用 inheritAttrs，我们还可以方便的把组件绑定的其它特性，转移到我们指定的元素上。这就需要用到下一个我们要讲的 $attrs 了。 attrs,listeners我们在使用组件库的时候经常会这么写：1&lt;el-input v-model="input" placeholder="请输入内容"&gt;&lt;/el-input&gt; 实际渲染后：可以看到我们指定的的 placeholder 是渲染在 input 上的，但是 input 并不是根元素。难道都用 Props 声明后，再赋值给 input？这种情况就可以用到 $attrs 了，改造一下我们之前那个栗子。123456789101112131415161718192021222324252627282930313233// communication.vue&lt;template&gt; &lt;div class="communication"&gt; &lt;communication-sub v-bind="dataProps" class="input" type="text" placeholder="请输入内容"&gt; &lt;/communication-sub&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import communicationSub from './communication-sub.vue';export default&#123; name: 'communication', data() &#123; return &#123; dataProps: &#123; title: '我是 communication 的值', &#125; &#125; &#125;, components: &#123; communicationSub &#125;&#125;&lt;/script&gt;// communication-sub.vue···&lt;div class="communication-sub"&gt; &lt;input v-bind="$attrs" v-model="title"&gt;&lt;/input&gt;&lt;/div&gt;··· export default &#123; inheritAttrs: false&#125; 可以看到，type 已经转移到了子元素 input 标签上，但是 class 没有。这是因为 inheritAttrs: false选项不会影响 style 和 class 的绑定。可以看出 $attrs则是将没有被组件内部 Props 声明的传值（也叫非 Props 特性）收集起来的一个对象，再通过 v-bind 将其绑定在指定元素上。这也是 Element 等组件库采用的策略。这里需要注意一点，通过 $attrs 指定给元素的属性，不会与该元素原有属性发生合并或替换，而是以原有属性为准。举个例子，假如我将上述 input 的 type 默认设置为 password。1&lt;input v-bind="$attrs" v-model="title" type="password"&gt;&lt;/input&gt; 则不会采用 $attrs 中的 type: ‘text’，将以 password 为准，所以如果需要默认值的属性，建议不要用这种方式。 $listeners同$attrs类似，可以看作是一个包含了组件上所有事件监听器(包括自定义事件，不包括.native修饰的事件)的对象。它也支持上述的写法，适用于将事件安放于组件内指定元素上。123456789101112131415// communication.vue&lt;communication-sub v-bind="dataProps"class="input"type="text"placeholder="请输入内容"@focus="onFocus" &gt;&lt;/communication-sub&gt;···methods: &#123; onFocus() &#123; console.log('onFocus'); &#125;&#125;// communication-sub.vue&lt;input v-bind="$attrs" v-model="title" v-on="$listeners"&gt;&lt;/input&gt; 给之前的栗子绑定一个聚焦事件，在子组件中通过 $listeners 绑定给 input，则会在 input 聚焦时触发。那么除了用在这种给组件内指定元素绑定特性和事件的情况，还有哪些场景可以用到呢？官方说明：在创建更高层次的组件时非常有用。比如在祖孙组件中传递数据，在孙子组件中触发事件后要在祖辈中做相应更新。我们继续之前的栗子：在孙辈组件触发点击事件，然后在祖辈中修改相应的 data。123456789101112131415161718192021222324252627// communication.vue&lt;communication-sub v-bind="dataProps" @click="onCommunicationClick"&gt;&lt;/communication-sub&gt;···methods: &#123; onCommunicationClick() &#123; this.dataProps.title = '我是点击之后的值'; &#125;&#125;;// communication-sub.vue&lt;communication-min-sub v-on="$listeners"&gt;&lt;/communication-min-sub&gt; // 子组件中将事件透传到孙辈// communication-min-sub.vue&lt;template&gt; &lt;div class="communication-min-sub"&gt; &lt;p&gt;我是 communication-min-sub&lt;/p&gt; &lt;button v-on="$listeners"&gt;click&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123; name: 'communication-min-sub', inheritAttrs: false&#125;&lt;/script&gt; 这样就能很方便的在多级组件的子级组件中，快速访问到父组件的数据和方法。正如在刚才的例子中，button 点击时，是直接调用的 communication.vue 中定义的方法。 依赖注入provide.inject上面的方法，在大多数多级组件嵌套的场景很有用，但有时我们遇到的并不一定是有父子关系的组件。比如基础组件中的 Select 下拉选择器。12345678&lt;el-select v-model="value" placeholder="请选择"&gt; &lt;el-option v-for="item in options" :key="item.value" :label="item.label" :value="item.value"&gt; &lt;/el-option&gt;&lt;/el-select&gt; 相信大家都使用过上栗或者类似于上栗的基础组件，它们借助 vue 插槽 实现。所以这个时候，el-select 和 el-option 之间的数据通信，我们之前的 $attrs、$listeners就没有用武之地了。有同学可能不太理解上面的代码为什么要通信，我简单介绍一下 Element 的处理方式： 我们可以简单的认为（Element 源码比这个要稍复杂，为了方便理解，简化一下，如有需要，可直接前往源码阅读），在 el-select 中有一个 input 元素，el-option 中是一列渲染好的 li。根据需求，我们在选中某个 li 的时候，要通知 input 展示相应的数据。而且我们在实际使用的时候，一般还伴随 el-form、el-form-item等组件，所以迫切需要一种方式: 可以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。 有同学可能会想到，这种多级的可以用 Vuex、EventBus等方式，当然可以。只不过我们现在的前提是基础组件，一般第三方组件库是不会增加一些额外的依赖的。事实上 Vue 本身并不推荐直接在业务中使用 provide、inject，一般在组件、插件库用到的比较多。但是在项目比较小、业务逻辑比较简单的时候，我们完全不必特意引入 Vuex。只要使用得当，provide、inject 确实不失为一种好办法。说了这么多，我们来看一下具体用法，我们将之前的栗子，改为用 provide、inject 来实现。123456789101112131415161718192021222324252627282930313233343536// communication.vue&lt;communication-sub v-bind="dataProps" &gt;&lt;/communication-sub&gt;// @click="onCommunicationClick" 移除之前绑定的时间···// 在 provide 添加子代需要接收的方法 onCommunicationClick，// 也可以直接指定为 this，子代便能访问父代所有的数据和方法。provide: function () &#123; return &#123; onCommunicationClick: this.onCommunicationClick &#125;&#125;,methods: &#123; onCommunicationClick() &#123; this.dataProps.title = '我是点击之后的值'; &#125;&#125;;// communication-sub.vue&lt;communication-min-sub&gt;&lt;/communication-min-sub&gt;// 移除之前的 v-on="$listeners"，因为在这个组件中不需要用到父组件的方法，所以不用做其它处理// communication-min-sub.vue&lt;template&gt; &lt;div class="communication-min-sub"&gt; ··· &lt;button @click="onCommunicationClick"&gt;click&lt;/button&gt; // 移除 v-on="$listeners"，然后绑定 inject 接收到的方法 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123; name: 'communication-min-sub', inject: ['onCommunicationClick'] // inject 接收父组件的方法&#125;&lt;/script&gt; 这种写法和之前的 $listeners 得到的效果是一样的.思考：有些同学可能会想到，如果我在根实例，app.vue 中如此设置：123456789101112131415&lt;script&gt; export default &#123; provide () &#123; return &#123; app: this // 设置app为this &#125; &#125;, data () &#123; return &#123; userInfo: null, otherState: null &#125; &#125; &#125;&lt;/script&gt; 那这样把所有的状态管理都放在 app.data 中，所有的子代中不就可以共享了吗？是不是就不需要 Vuex 了呢？实际上，Vue 本身就提供了一个方法来访问根实例 $root，所以即使没有 provide 也是可以做到的。那为什么不这么用呢？还是前面提到的原因，不利于追踪维护，也失去了所谓状态管理的意义。不过，如果你的项目足够小的话，依然可以这么使用。 ref,parent,children我们前面一直说的都是子组件如何触达父组件，那么父组件能不能访问到子组件呢？当然是可以的。 ref简单来说就是获取元素的 Dom 对象和子组件实例。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例。获取 Dom 元素就是为了进行一些 Dom 操作，需要注意的一点就是，要在 Dom 加载完成后使用，否则可能获取不到。比如我要将之前 input 的字体颜色改成红色：12345678&lt;input type="text" v-model="dataProps.title" ref="input"&gt;...mounted() &#123; this.$nextTick(_ =&gt; &#123; // 确保 Dom 更新完成 this.$refs['input'].style.color = 'red'; &#125;);&#125;// 这里只是举一个栗子，实际项目中的需求，最好通过 class 的方式，尽量减少 Dom 操作。 那什么情况下需要获取组件实例呢？比如父元素的某个状态改变，需要子组件进行 http 请求更新数据。通常情况下，我们会选择通过 Props 将状态传递给子组件，然后子组件进行 Watch 监测，如果有变更，则进行相应操作。这个时候，我们便可以选择使用 ref。1234567891011&lt;child ref="child"&gt;&lt;/child&gt;···&lt;script&gt; export default &#123; methods () &#123; onStateChange() &#123; // 变更状态后直接调用子组件方法进行更新 this.$refs['child'].updateData(); &#125; &#125; &#125;&lt;/script&gt; $children,$parent无独有偶，$children 同样可以完成上面的任务。$children 和 $parent，顾名思义，一个会找到当前组件的子组件，一个会找到当前组件的父组件。如果有多个子组件，需要依赖组件实例的 name 属性。改写一下上面的方法：123456789&lt;script&gt; export default &#123; methods () &#123; onStateChange() &#123; // 子组件返回的是一个数组，多个子组件用 $options.name 区分。 this.$children[0].updateData(); &#125; &#125; &#125;&lt;/script&gt; $parent 和 $children 用法一样，不过 $parent 返回的父组件实例，不是数组，因为父组件肯定只有一个。ref、parent、children 它们几个的一个缺点就是无法处理跨级组件和兄弟组件，后续我们会介绍 dispatch 和 broadcast 方法，实现跨级通信。 emit,on,off$emit，想必大家都非常熟悉，我们通常用作父子组件间通信，我们也叫它自定义事件。$emit 和 $on都是组件自身的方法，$on 可以监听 $emit 派发的事件，$off 则用来取消事件监听。这也是我们下一个要讲的通信方式 EventBus 所依赖的原理。12345678910111213141516171819202122232425262728293031// 父组件&lt;template&gt; &lt;button-component @clickButton="clickButton"&gt;&lt;/button-component&gt; // 在父组件利用 v-on 监听&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; clickButton () &#123; ··· &#125; &#125;&#125;&lt;/script&gt;// 子组件&lt;template&gt; &lt;button @click="handleClick"&gt;&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; handleClick () &#123; // 触发 $emit this.$emit('clickButton'); &#125; &#125;, mounted() &#123; this.$on('clickButton', (...arr) =&gt; &#123; // 也可以自己监听 $emit，虽然没什么用··· console.log(...arr); &#125;) &#125;&#125;&lt;/script&gt; EventBus$emit的痛点依然是支持跨级和兄弟组件，Vue 官方推荐我们使用一个新的 Vue 实例来做一个全局的事件通信（或者叫中央事件总线···），也就是我们要讲的 EventBus。了解过的同学都知道，正常的 bus，我们一般会挂载到 Vue 的 prototype 上，方便全局调用。12// main.jsVue.prototype.$bus = new Vue(); 依旧改写之前的栗子：1234567891011121314151617181920212223242526272829&lt;!--communication.vue--&gt;&lt;communication-sub v-bind="dataProps" &gt;&lt;/communication-sub&gt;···beforeDestroy() &#123; &lt;!-- 实例销毁时，需要卸载监听事件 --&gt; this.$bus.$off('busClick');&#125;,created() &#123; &lt;!-- 监听子组件触发的 Bus 事件--&gt; this.$bus.$on('busClick', (data) =&gt; &#123; this.dataProps.title = data; &#125;);&#125;&lt;!--communication-min-sub.vue--&gt;&lt;template&gt; &lt;div class="communication-min-sub"&gt; &lt;button @click="busClick"&gt;click bus&lt;/button&gt; &lt;!--子组件触发点击事件--&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123; methods: &#123; busClick() &#123; this.$bus.$emit('busClick', 'bus 触发了'); &#125; &#125;&#125;&lt;/script&gt; 这是一个基础的 EventBus 的实现。现在我们设想一下，类似于 userInfo 这样的信息，在很多页面都需要用到，那我们需要在许多页面都做 $on 监听的操作。那能否将这些操作整合到一起呢？我们一起来看：1234567891011121314151617181920212223242526 // 新建一个 eventBus.jsimport Vue from 'vue';const bus = new Vue(&#123; data () &#123; return &#123; userInfo: &#123;&#125; &#125; &#125;, created () &#123; this.$on('getUserInfo', val =&gt; &#123; this.userInfo = val; &#125;) &#125;&#125;);export default bus;// main.jsimport bus from './eventBus';Vue.prototype.$bus = bus;// app.vuemethods: &#123; getUserInfo() &#123; ajax.post(***).then(data =&gt; &#123; this.$bus.$emit('getUserInfo', data); // 通知 EventBus 更新 userInfo &#125;) &#125;&#125; 这样在其他页面用到 userInfo 的时候，只需要 this.$bus.userInfo 就可以了。注意刚刚其实没有用 off 卸载掉监听，因为其实 userInfo 这种全局信息，并没有一个准确的说要销毁的时机，浏览器关闭的时候，也用不着我们处理了。但是，如果只是某个页面组件用到的，建议还是用最开始的方法，在页面销毁的时候卸载掉。 派发与广播:dispath与broadcast在 Vue 1.x 的实现中，有 $dispatch 和 $broadcast 方法，但是在 2.x 被废弃了。$dispatch 的主要作用是向上级组件派发事件，$broadcast 则是向下级广播。它们的优点是都支持跨级，再看一下官方废弃这两个方法的理由： 因为基于组件树结构的事件流方式实在是让人难以理解，并且在组件结构扩展的过程中会变得越来越脆弱。并且 $dispatch 和 $broadcast 也没有解决兄弟组件间的通信问题。 可以看到，主要原因是在组件结构扩展后不易理解，以及没有解决兄弟组件通信的问题。但是对于组件库来说，这依旧是十分有用的，所以它们大多自己实现了这两个方法。对我们来讲，也许在项目中用不到，但学习这种解决问题的思路，是十分必要的。派发和广播，依赖于组件的 name（最怕此处有人说：如果不写 name，这方法不就没用了？2333···），以此来逐级查找对应的组件实例。Element 的实现中，给所有的组件都加了一个 componentName 属性，所以它是根据 componentName 来查找的。我们在实现的时候还是直接用 name。我们先来看一下 $dispatch 的简单用法，再来分析思路。123456789101112131415&lt;!--communication-min-sub.vue--&gt;&lt;template&gt; &lt;button @click="handleDispatch"&gt;dispatch&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import Emitter from '../../utils/emitter';export default &#123; mixins: [Emitter], // 混入，方便直接调用 methods: &#123; handleDispatch () &#123; this.dispatch('communication', 'onMessage', '触发了dispatch'); &#125; &#125;&#125;&lt;/script&gt; 12345678910111213&lt;!--communication.vue--&gt;&lt;script&gt; export default &#123; beforeDestroy() &#123; // 销毁 this.$off('onMessage'); &#125;, mounted () &#123; this.$on('onMessage', (data) =&gt; &#123; // 监听 this.dataProps.title = data; &#125;) &#125; &#125;&lt;/script&gt; 现在明确一下目标，dispatch 方法接收三个参数，组件 name、事件名称、基础数据（可不传）。要做到向上跨级派发事件，需要向上找到指定 name 的组件实例，利用我们前文提到的 $emit方法做派送，所以在指定组件就可以用 $on 来监听了。所以 dispatch 本质上就是向上查找到指定组件并触发其自身的 $emit，以此来做响应，broadcast 则相反。那么如何做到跨级查找呢？12345678910111213141516171819202122232425262728293031function broadcast(componentName, eventName, params) &#123; this.$children.forEach(child =&gt; &#123; // 遍历所有的 $children var name = child.$options.name; // 拿到实例的name，Element 此处用的 componentName if (name === componentName) &#123; // 如果是想要的那个，进行广播 child.$emit.apply(child, [eventName].concat(params)); &#125; else &#123; // 不是则递归查找 直到 $children 为 [] broadcast.apply(child, [componentName, eventName].concat([params])); &#125; &#125;);&#125;export default &#123; methods: &#123; dispatch(componentName, eventName, params) &#123; var parent = this.$parent || this.$root; var name = parent.$options.name; while (parent &amp;&amp; (!name || name !== componentName)) &#123; // 存在 parent 且 (不存在 name 或 name 和 指定参数不一样) 则继续查找 parent = parent.$parent; // 不存在继续取上级 if (parent) &#123; name = parent.$options.name; // 存在上级 再次赋值并再次循环，进行判断 &#125; &#125; if (parent) &#123; // 找到以后 如果有 进行事件派发 parent.$emit.apply(parent, [eventName].concat(params)); &#125; &#125;, broadcast(componentName, eventName, params) &#123; broadcast.call(this, componentName, eventName, params); &#125; &#125;&#125;; 以上是详细的 emitter.js，可以看见，这和我们之前讲到的 $parent、$children、$emit、$on都密切相关。这也是为什么把它放到后面讲的原因。之前说过，派发和广播并没有解决兄弟组件通信的问题，所以这里大家也可以拓展思考一下，如何支持兄弟组件间通信。依然是依赖于$parent、$children，可以找到任意指定组件。 总结本期文章内容到这里就讲完了，我们来总结回顾一下： 子组件触达父组件的方式：Props、$parent、$attrs、$listeners、provide 和 inject、$dispatch 父组件触达子组件的方式：$emit 和 $on、$children、$ref、broadcast 全局通信：EventBus、Vuex 转载：Vue 组件间通信方式完整版]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[async/await]]></title>
    <url>%2F2019%2F04%2F13%2Fasync-await%2F</url>
    <content type="text"><![CDATA[关于async/await执行顺序首先是因为一个关于事件循环的面试题 1234567891011121314151617181920212223242526272829303132333435async function async1() &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125;async function async2() &#123; console.log('async2');&#125;console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0)async1();new Promise(function(resolve) &#123; console.log('promise1'); resolve();&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end');/*script startasync1 startasync2promise1script endasync1 endpromise2setTimeout*/ 说一下宏任务可以理解是每次执行栈执行的代码就是一个宏任务。浏览器为了能够使得js内部宏任务与DOM任务能够有序的执行，会在一个(macro)task执行结束后，在下一个(macro)task 执行开始前，对页面进行重新渲染，流程为：(macro)task -&gt; 渲染 -&gt;(macro)task-&gt;... (macro)task主要包含：script(整体代码)、setTimeout、setInterval、I/O、UI交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境) 说一下微任务microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前task任务后，下一个task之前，在渲染之前。 所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染。也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）。 microtask主要包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境) 执行（每个）宏任务之前都会检查有没有微任务需要执行，如果有就会把微任务执行了再执行。 Promise和async中的立即执行Promise中的异步体现在then和catch中，所以写在Promise中的代码是被当做同步任务立即执行的。而在async/await中，在出现await出现之前，其中的代码也是立即执行的。 await做了什么从字面意思上看await就是等待，await 等待的是一个表达式，这个表达式的返回值可以是一个promise对象也可以是其他值。 很多人以为await会一直等待之后的表达式执行完之后才会继续执行后面的代码，实际上await是一个让出线程的标志。await后面的表达式会先执行一遍，将await后面的代码加入到microtask中(因为async await本身就是promise+generator的语法糖)，然后就会跳出整个async函数来执行后面的代码。所以题中12345async function async1() &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125; 等价于123456async function async1() &#123; console.log('async1 start'); Promise.resolve(async2()).then(() =&gt; &#123; console.log('async1 end'); &#125;)&#125; 所以本题的执行顺序为：执行script start-&gt;遇到setTimeout,将它放入宏任务队列中-&gt;遇到async1(),执行它的同步代码,async1 start以及跟在await屁股后面的代码，这里是个函数async2(),执行async2,后面那句console.log(‘async1 end’)则被让出线程放入微任务队列中-&gt;继续执行promise中的同步代码promise1,.then后的代码放出微任务队列中-&gt;继续执行script end-&gt;同步代码执行完毕，再执行异步代码，先微任务队列中的async1 end再promise2,最后宏任务队列中的setTimeout。即为：script start -- async1 start -- async2 --promise1 -- script end -- aync1 end -- promise2 -- setTimeout 再做几个题:1234567891011121314151617181920212223242526272829async function async1() &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125;async function async2() &#123; //async2做出如下更改： new Promise(function(resolve) &#123; console.log('promise1'); resolve();&#125;).then(function() &#123; console.log('promise2'); &#125;);&#125;console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0)async1();new Promise(function(resolve) &#123; console.log('promise3'); resolve();&#125;).then(function() &#123; console.log('promise4');&#125;);console.log('script end'); 根据以上的分析很容易得出：123456789script startasync1 startpromise1promise3script endpromise2async1 endpromise4setTimeout 12345678910111213141516171819202122232425262728async function async1() &#123; console.log('async1 start'); await async2(); //更改如下： setTimeout(function() &#123; console.log('setTimeout1') &#125;,0)&#125;async function async2() &#123; //更改如下： setTimeout(function() &#123; console.log('setTimeout2') &#125;,0)&#125;console.log('script start');setTimeout(function() &#123; console.log('setTimeout3');&#125;, 0)async1();new Promise(function(resolve) &#123; console.log('promise1'); resolve();&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end'); 结果：12345678script startasync1 startpromise1script endpromise2setTimeout3setTimeout2setTimeout1 123456789101112131415161718192021222324252627282930313233async function a1 () &#123; console.log('a1 start') await a2() console.log('a1 end')&#125;async function a2 () &#123; console.log('a2')&#125;console.log('script start')setTimeout(() =&gt; &#123; console.log('setTimeout')&#125;, 0)Promise.resolve().then(() =&gt; &#123; console.log('promise1')&#125;)a1()let promise2 = new Promise((resolve) =&gt; &#123; resolve('promise2.then') console.log('promise2')&#125;)promise2.then((res) =&gt; &#123; console.log(res) Promise.resolve().then(() =&gt; &#123; console.log('promise3') &#125;)&#125;)console.log('script end') 结果：12345678910script starta1 starta2promise2script endpromise1a1 endpromise2.thenpromise3setTimeout 主要内容 async做了一件什么事情？ await在等什么？ await等到之后，做了一件什么事情？ async/await比promise有哪些优势？ async做了一件什么事情？ 一句话概括：带 async 关键字的函数，它使得你的函数的返回值必定是 promise 对象也就是 如果async关键字函数返回的不是promise，会自动用Promise.resolve()包装 如果async关键字函数显式地返回promise，那就以你返回的promise为准 这是一个简单的例子，可以看到 async 关键字函数和普通函数的返回值的区别1234567891011121314async function fn1()&#123; return 123&#125;function fn2()&#123; return 123&#125;console.log(fn1())console.log(fn2())Promise &#123;&lt;resolved&gt;: 123&#125;123 所以你看，async 函数也没啥了不起的，以后看到带有 async 关键字的函数也不用慌张，你就想它无非就是把return值包装了一下，其他就跟普通函数一样。关于async关键字还有那些要注意的？ 在语义上要理解，async表示函数内部有异步操作 另外注意，一般 await 关键字要在 async 关键字函数的内部，await 写在外面会报错。 await在等什么？ 一句话概括： await等的是右侧「表达式」的结果也就是说， 右侧如果是函数，那么函数的return值就是「表达式的结果」 右侧如果是一个 ‘hello’ 或者什么值，那表达式的结果就是 ‘hello’12345678910async function async1() &#123; console.log( 'async1 start' ) await async2() console.log( 'async1 end' )&#125;async function async2() &#123; console.log( 'async2' )&#125;async1()console.log( 'script start' ) await会让出线程，阻塞后面的代码，那么是怎么让出线程呢？‘async2’和’script start’谁会先打印呢？语句 await async2()是怎么执行呢？实践结论是，从右往左执行，先执行async2后，发现有await关键字，于是让出线程，阻塞代码 await等到之后，做了一件什么事情？ 那么await右侧表达式的结果就是它要等的东西。等到之后，对于await来说，分2个情况 不是promise对象 是promise对象 如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。 看到上面的阻塞一词，心慌了吧……放心，这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。 async/await比promise有哪些优势？ async/await 的优势在于处理 then 链。单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 传入参数 n，表示这个函数执行的时间（毫秒） * 执行的结果是 n + 200，这个值将用于下一步骤 */function takeLongTime(n) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(n + 200), n); &#125;);&#125;function step1(n) &#123; console.log(`step1 with $&#123;n&#125;`); return takeLongTime(n);&#125;function step2(n) &#123; console.log(`step2 with $&#123;n&#125;`); return takeLongTime(n);&#125;function step3(n) &#123; console.log(`step3 with $&#123;n&#125;`); return takeLongTime(n);&#125;现在用 Promise 方式来实现这三个步骤的处理function doIt() &#123; console.time("doIt"); const time1 = 300; step1(time1) .then(time2 =&gt; step2(time2)) .then(time3 =&gt; step3(time3)) .then(result =&gt; &#123; console.log(`result is $&#123;result&#125;`); console.timeEnd("doIt"); &#125;);&#125;doIt();// step1 with 300// step2 with 500// step3 with 700// result is 900// doIt: 1507.251ms输出结果 result 是 step3() 的参数 700 + 200 = 900。doIt() 顺序执行了三个步骤，一共用了 300 + 500 + 700 = 1500 毫秒，和 console.time()/console.timeEnd() 计算的结果一致。如果用 async/await 来实现呢，会是这样async function doIt() &#123; console.time("doIt"); const time1 = 300; const time2 = await step1(time1); const time3 = await step2(time2); const result = await step3(time3); console.log(`result is $&#123;result&#125;`); console.timeEnd("doIt");&#125;doIt();结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样 参考：理解 JavaScript 的 async/await关于第10题的一些见解]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>
