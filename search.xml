<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[async/await]]></title>
    <url>%2F2019%2F04%2F13%2Fasync-await%2F</url>
    <content type="text"><![CDATA[关于async/await执行顺序首先是因为一个关于事件循环的面试题 1234567891011121314151617181920212223242526272829303132333435async function async1() &#123; console.log(&apos;async1 start&apos;); await async2(); console.log(&apos;async1 end&apos;);&#125;async function async2() &#123; console.log(&apos;async2&apos;);&#125;console.log(&apos;script start&apos;);setTimeout(function() &#123; console.log(&apos;setTimeout&apos;);&#125;, 0)async1();new Promise(function(resolve) &#123; console.log(&apos;promise1&apos;); resolve();&#125;).then(function() &#123; console.log(&apos;promise2&apos;);&#125;);console.log(&apos;script end&apos;);/*script startasync1 startasync2promise1script endasync1 endpromise2setTimeout*/ 说一下宏任务可以理解是每次执行栈执行的代码就是一个宏任务。浏览器为了能够使得js内部宏任务与DOM任务能够有序的执行，会在一个(macro)task执行结束后，在下一个(macro)task 执行开始前，对页面进行重新渲染，流程为：(macro)task -&gt; 渲染 -&gt;(macro)task-&gt;... (macro)task主要包含：script(整体代码)、setTimeout、setInterval、I/O、UI交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境) 说一下微任务microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前task任务后，下一个task之前，在渲染之前。 所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染。也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）。 microtask主要包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境) 执行（每个）宏任务之前都会检查有没有微任务需要执行，如果有就会把微任务执行了再执行。 Promise和async中的立即执行Promise中的异步体现在then和catch中，所以写在Promise中的代码是被当做同步任务立即执行的。而在async/await中，在出现await出现之前，其中的代码也是立即执行的。 await做了什么从字面意思上看await就是等待，await 等待的是一个表达式，这个表达式的返回值可以是一个promise对象也可以是其他值。 很多人以为await会一直等待之后的表达式执行完之后才会继续执行后面的代码，实际上await是一个让出线程的标志。await后面的表达式会先执行一遍，将await后面的代码加入到microtask中(因为async await本身就是promise+generator的语法糖)，然后就会跳出整个async函数来执行后面的代码。所以题中12345async function async1() &#123; console.log(&apos;async1 start&apos;); await async2(); console.log(&apos;async1 end&apos;);&#125; 等价于123456async function async1() &#123; console.log(&apos;async1 start&apos;); Promise.resolve(async2()).then(() =&gt; &#123; console.log(&apos;async1 end&apos;); &#125;)&#125; 所以本题的执行顺序为：执行script start-&gt;遇到setTimeout,将它放入宏任务队列中-&gt;遇到async1(),执行它的同步代码,async1 start以及跟在await屁股后面的代码，这里是个函数async2(),执行async2,后面那句console.log(‘async1 end’)则被让出线程放入微任务队列中-&gt;继续执行promise中的同步代码promise1,.then后的代码放出微任务队列中-&gt;继续执行script end-&gt;同步代码执行完毕，再执行异步代码，先微任务队列中的async1 end再promise2,最后宏任务队列中的setTimeout。即为：script start -- async1 start -- async2 --promise1 -- script end -- aync1 end -- promise2 -- setTimeout 再做几个题:1234567891011121314151617181920212223242526272829async function async1() &#123; console.log(&apos;async1 start&apos;); await async2(); console.log(&apos;async1 end&apos;);&#125;async function async2() &#123; //async2做出如下更改： new Promise(function(resolve) &#123; console.log(&apos;promise1&apos;); resolve();&#125;).then(function() &#123; console.log(&apos;promise2&apos;); &#125;);&#125;console.log(&apos;script start&apos;);setTimeout(function() &#123; console.log(&apos;setTimeout&apos;);&#125;, 0)async1();new Promise(function(resolve) &#123; console.log(&apos;promise3&apos;); resolve();&#125;).then(function() &#123; console.log(&apos;promise4&apos;);&#125;);console.log(&apos;script end&apos;); 根据以上的分析很容易得出：123456789script startasync1 startpromise1promise3script endpromise2async1 endpromise4setTimeout 12345678910111213141516171819202122232425262728async function async1() &#123; console.log(&apos;async1 start&apos;); await async2(); //更改如下： setTimeout(function() &#123; console.log(&apos;setTimeout1&apos;) &#125;,0)&#125;async function async2() &#123; //更改如下： setTimeout(function() &#123; console.log(&apos;setTimeout2&apos;) &#125;,0)&#125;console.log(&apos;script start&apos;);setTimeout(function() &#123; console.log(&apos;setTimeout3&apos;);&#125;, 0)async1();new Promise(function(resolve) &#123; console.log(&apos;promise1&apos;); resolve();&#125;).then(function() &#123; console.log(&apos;promise2&apos;);&#125;);console.log(&apos;script end&apos;); 结果：12345678script startasync1 startpromise1script endpromise2setTimeout3setTimeout2setTimeout1 123456789101112131415161718192021222324252627282930313233async function a1 () &#123; console.log(&apos;a1 start&apos;) await a2() console.log(&apos;a1 end&apos;)&#125;async function a2 () &#123; console.log(&apos;a2&apos;)&#125;console.log(&apos;script start&apos;)setTimeout(() =&gt; &#123; console.log(&apos;setTimeout&apos;)&#125;, 0)Promise.resolve().then(() =&gt; &#123; console.log(&apos;promise1&apos;)&#125;)a1()let promise2 = new Promise((resolve) =&gt; &#123; resolve(&apos;promise2.then&apos;) console.log(&apos;promise2&apos;)&#125;)promise2.then((res) =&gt; &#123; console.log(res) Promise.resolve().then(() =&gt; &#123; console.log(&apos;promise3&apos;) &#125;)&#125;)console.log(&apos;script end&apos;) 结果：12345678910script starta1 starta2promise2script endpromise1a1 endpromise2.thenpromise3setTimeout 主要内容 async做了一件什么事情？ await在等什么？ await等到之后，做了一件什么事情？ async/await比promise有哪些优势？ async做了一件什么事情？ 一句话概括：带 async 关键字的函数，它使得你的函数的返回值必定是 promise 对象也就是 如果async关键字函数返回的不是promise，会自动用Promise.resolve()包装 如果async关键字函数显式地返回promise，那就以你返回的promise为准 这是一个简单的例子，可以看到 async 关键字函数和普通函数的返回值的区别1234567891011121314async function fn1()&#123; return 123&#125;function fn2()&#123; return 123&#125;console.log(fn1())console.log(fn2())Promise &#123;&lt;resolved&gt;: 123&#125;123 所以你看，async 函数也没啥了不起的，以后看到带有 async 关键字的函数也不用慌张，你就想它无非就是把return值包装了一下，其他就跟普通函数一样。关于async关键字还有那些要注意的？ 在语义上要理解，async表示函数内部有异步操作 另外注意，一般 await 关键字要在 async 关键字函数的内部，await 写在外面会报错。 await在等什么？ 一句话概括： await等的是右侧「表达式」的结果也就是说， 右侧如果是函数，那么函数的return值就是「表达式的结果」 右侧如果是一个 ‘hello’ 或者什么值，那表达式的结果就是 ‘hello’12345678910async function async1() &#123; console.log( &apos;async1 start&apos; ) await async2() console.log( &apos;async1 end&apos; )&#125;async function async2() &#123; console.log( &apos;async2&apos; )&#125;async1()console.log( &apos;script start&apos; ) await会让出线程，阻塞后面的代码，那么是怎么让出线程呢？‘async2’和’script start’谁会先打印呢？语句 await async2()是怎么执行呢？实践结论是，从右往左执行，先执行async2后，发现有await关键字，于是让出线程，阻塞代码 await等到之后，做了一件什么事情？ 那么await右侧表达式的结果就是它要等的东西。等到之后，对于await来说，分2个情况 不是promise对象 是promise对象 如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。 看到上面的阻塞一词，心慌了吧……放心，这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。 async/await比promise有哪些优势？ async/await 的优势在于处理 then 链。单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 传入参数 n，表示这个函数执行的时间（毫秒） * 执行的结果是 n + 200，这个值将用于下一步骤 */function takeLongTime(n) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(n + 200), n); &#125;);&#125;function step1(n) &#123; console.log(`step1 with $&#123;n&#125;`); return takeLongTime(n);&#125;function step2(n) &#123; console.log(`step2 with $&#123;n&#125;`); return takeLongTime(n);&#125;function step3(n) &#123; console.log(`step3 with $&#123;n&#125;`); return takeLongTime(n);&#125;现在用 Promise 方式来实现这三个步骤的处理function doIt() &#123; console.time(&quot;doIt&quot;); const time1 = 300; step1(time1) .then(time2 =&gt; step2(time2)) .then(time3 =&gt; step3(time3)) .then(result =&gt; &#123; console.log(`result is $&#123;result&#125;`); console.timeEnd(&quot;doIt&quot;); &#125;);&#125;doIt();// step1 with 300// step2 with 500// step3 with 700// result is 900// doIt: 1507.251ms输出结果 result 是 step3() 的参数 700 + 200 = 900。doIt() 顺序执行了三个步骤，一共用了 300 + 500 + 700 = 1500 毫秒，和 console.time()/console.timeEnd() 计算的结果一致。如果用 async/await 来实现呢，会是这样async function doIt() &#123; console.time(&quot;doIt&quot;); const time1 = 300; const time2 = await step1(time1); const time3 = await step2(time2); const result = await step3(time3); console.log(`result is $&#123;result&#125;`); console.timeEnd(&quot;doIt&quot;);&#125;doIt();结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样]]></content>
  </entry>
  <entry>
    <title><![CDATA[foot]]></title>
    <url>%2F2019%2F04%2F10%2Ffoot%2F</url>
    <content type="text"><![CDATA[hello你好]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
