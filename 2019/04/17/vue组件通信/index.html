<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    vue组件通信 |
    
    Now you can see me</title>
  
    <link rel="shortcut icon" href="/cat.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="outer">
  <article id="post-vue组件通信" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      vue组件通信
    </h1>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/04/17/vue组件通信/" class="article-date">
  <time datetime="2019-04-17T04:35:28.000Z" itemprop="datePublished">2019-04-17</time>
</a>
        
        <!-- <span class="article-time">读完需要大约 -->
        <!-- 22</span> -->
        <!-- <span>分钟</span> -->
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><blockquote>
<p>组件是可以复用的Vue实例</p>
</blockquote>
<p>在Vue中，根据注册方式的不同，可以分为：</p>
<ul>
<li>局部组件（局部注册）</li>
<li>全局组件（全局注册）</li>
</ul>
<a id="more"></a>
<p>顾名思义，全局注册的组件，可以用在 Vue 实例的任意模板中。但是带来的隐患是，在 webpack 模块化构建时，即便你没有在项目中使用这个组件，依然会打包到最终的项目代码中。而局部组件，则需要在使用到的实例中注册该组件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 全局注册</span><br><span class="line">// install.js</span><br><span class="line">import Icon from &apos;./Icon.vue&apos;;</span><br><span class="line">const install = &#123;</span><br><span class="line">    install:function(Vue)&#123;</span><br><span class="line">        Vue.component(&apos;VIcon&apos;, Icon);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">export default install;</span><br><span class="line">// main.js</span><br><span class="line">import install from &apos;./install.js&apos;; // 引入全局插件</span><br><span class="line">Vue.use(install); // 注册</span><br><span class="line"></span><br><span class="line">// 局部注册</span><br><span class="line">import VIcon from &apos;./Icon.vue&apos;;</span><br><span class="line">export default&#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">        VIcon</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">&lt;v-icon&gt; &lt;/v-icon&gt;</span><br></pre></td></tr></table></figure></p>
<p>根据应用场景的不同，又可以分为：</p>
<ul>
<li>页面组件：我们使用 Vue 时，每个路由代表的页面，都可以称之为组件。</li>
<li>基础组件：就像上面栗子中的 Icon 组件，就是一个典型的基础组件。基本上不掺杂业务逻辑，在项目中可能被大量使用，易于移植。类似的基础组件还有 Button、Input 等，常见于各类 UI 组件库。</li>
<li>业务组件：业务组件和项目具体的业务逻辑有大量耦合，一般抽离于当前项目。</li>
</ul>
<p>以上就是组件的简单介绍，那我们到底为什么要推崇组件化？组件化有什么好处？复用？我个人认为组件化最大的好处，便是解耦，易于项目管理。所以在大型项目管理中，组件化是非常有必要的。当然，这并不是今天学习的重点，以后有机会再聊。<br>正因为在 Vue 中处处都是组件，而我们也偏向于组件化、模块化。那我们在一堆组件中，便需要解决一个问题 — 组件间通信。下面，我们就进入今天的主题，Vue 的组件间通信。</p>
<hr>
<h3 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h3><hr>
<h4 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h4><p>Vue 中，最基本的通信方式就是 Props，它是父子组件通信中父组件传值给子组件的一种方式。它允许以数组形式接收，但是更推荐你开启类型检查的形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//communication.vue</span><br><span class="line">&lt;communication-sub v-bind=&quot;dataProps&quot;&gt;&lt;/communication-sub&gt;</span><br><span class="line">//v-bind=&quot;dataProps&quot;等同于:title=&quot;title&quot;，适用于多个参数一起传递</span><br><span class="line">...</span><br><span class="line">data()&#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		dataProps:&#123;</span><br><span class="line">			title:&apos;我是父组件的值&apos;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//communication-sub.vue</span><br><span class="line">&lt;div class=&quot;communication-sub&quot;&gt;</span><br><span class="line">	&#123;&#123;title&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">...</span><br><span class="line">props:[&apos;title&apos;]</span><br><span class="line">//更推荐开启类型检查</span><br><span class="line">props:&#123;</span><br><span class="line">	title:&#123;</span><br><span class="line">		type:String,</span><br><span class="line">		required:true,</span><br><span class="line">		default:&apos;&apos;//允许指定默认值，引用类型需要函数返回</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>我们都知道，Props 是单向数据流，这是 Vue 为了避免子组件意外改变父组件的状态，从而导致数据流向难以理解而做出的限制。所以 Vue 推荐需要改动的时候，通过改变父组件的值从而触发 Props 的响应。或者，我们可以在接收非引用类型的值时，使用子组件自身的 data 做一次接收。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [&apos;title&apos;],</span><br><span class="line">data: function () &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    text: this.title</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为什么是非引用类型呢，因为在 JavaScript 中，引用类型的赋值，实际是内存地址的传递。所以上面栗子中的简单赋值，显然会指向同一个内存地址，所以如果是数组或是对象，你可能需要一次深拷贝。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let obj = JSON.parse(JSON.stringify(obj));</span><br></pre></td></tr></table></figure></p>
<p>上面这个操作有一些缺陷，不能序列化函数、undefined、循环引用等.<br>事实上，在 Props 是引用类型时，单独修改对象、数组的某个属性或下标，Vue 并不会抛出错误。当然，前提是你要非常清楚自己在做什么，并写好注释，防止你的小伙伴们疑惑。<br>有的同学可能知道，在组件上绑定的属性，如果没有在组件内部用 Props 声明，会默认绑定到组件的根元素上去。还是之前的栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;communication-sub v-bind=&quot;dataProps&quot; class=&quot;one&quot; type=&quot;div&quot;&gt;&lt;/communication-sub&gt;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/3/23/169aac7ab36950d2?imageslim" alt><br>这是 Vue 默认处理的，而且，除了 class 和 style 采用合并策略，其它特性（如上栗 type）会替换掉原来根元素上的属性值。当然，我们也可以显示的在组件内部关闭掉这个特性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">inheritAttrs: false,</span><br><span class="line">props: [&apos;title&apos;]</span><br></pre></td></tr></table></figure></p>
<p>利用 inheritAttrs，我们还可以方便的把组件绑定的其它特性，转移到我们指定的元素上。这就需要用到下一个我们要讲的 $attrs 了。</p>
<h4 id="attrs-listeners"><a href="#attrs-listeners" class="headerlink" title="attrs,listeners"></a>attrs,listeners</h4><p>我们在使用组件库的时候经常会这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-input v-model=&quot;input&quot; placeholder=&quot;请输入内容&quot;&gt;&lt;/el-input&gt;</span><br></pre></td></tr></table></figure></p>
<p>实际渲染后：<br><img src="https://user-gold-cdn.xitu.io/2019/3/23/169aad7bc51ca555?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt><br>可以看到我们指定的的 placeholder 是渲染在 input 上的，但是 input 并不是根元素。难道都用 Props 声明后，再赋值给 input？这种情况就可以用到 $attrs 了，改造一下我们之前那个栗子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// communication.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;communication&quot;&gt;</span><br><span class="line">        &lt;communication-sub v-bind=&quot;dataProps&quot; class=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;请输入内容&quot;&gt;</span><br><span class="line">        &lt;/communication-sub&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import communicationSub from &apos;./communication-sub.vue&apos;;</span><br><span class="line">export default&#123;</span><br><span class="line">    name: &apos;communication&apos;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            dataProps: &#123;</span><br><span class="line">                title: &apos;我是 communication 的值&apos;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        communicationSub</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// communication-sub.vue</span><br><span class="line">···</span><br><span class="line">&lt;div class=&quot;communication-sub&quot;&gt;</span><br><span class="line">    &lt;input v-bind=&quot;$attrs&quot; v-model=&quot;title&quot;&gt;&lt;/input&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">···</span><br><span class="line"> export default &#123;</span><br><span class="line">    inheritAttrs: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/3/23/169ab45f5907f85a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt><br>可以看到，type 已经转移到了子元素 input 标签上，但是 class 没有。这是因为 <code>inheritAttrs: false</code>选项不会影响 style 和 class 的绑定。<strong>可以看出 <code>$attrs</code>则是将没有被组件内部 Props 声明的传值（也叫非 Props 特性）收集起来的一个对象，</strong>再通过 v-bind 将其绑定在指定元素上。这也是 Element 等组件库采用的策略。<br><strong>这里需要注意一点，通过 $attrs 指定给元素的属性，不会与该元素原有属性发生合并或替换，而是以原有属性为准。</strong>举个例子，假如我将上述 input 的 type 默认设置为 password。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-bind=&quot;$attrs&quot; v-model=&quot;title&quot; type=&quot;password&quot;&gt;&lt;/input&gt;</span><br></pre></td></tr></table></figure></p>
<p>则不会采用 $attrs 中的 type: ‘text’，将以 password 为准，所以如果需要默认值的属性，建议不要用这种方式。</p>
<p>$listeners同$attrs类似，<strong>可以看作是一个包含了组件上所有事件监听器(包括自定义事件，不包括.native修饰的事件)的对象。</strong>它也支持上述的写法，适用于将事件安放于组件内指定元素上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// communication.vue</span><br><span class="line">&lt;communication-sub v-bind=&quot;dataProps&quot;</span><br><span class="line">class=&quot;input&quot;</span><br><span class="line">type=&quot;text&quot;</span><br><span class="line">placeholder=&quot;请输入内容&quot;</span><br><span class="line">@focus=&quot;onFocus&quot; &gt;</span><br><span class="line">&lt;/communication-sub&gt;</span><br><span class="line">···</span><br><span class="line">methods: &#123;</span><br><span class="line">    onFocus() &#123;</span><br><span class="line">        console.log(&apos;onFocus&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// communication-sub.vue</span><br><span class="line">&lt;input v-bind=&quot;$attrs&quot; v-model=&quot;title&quot; v-on=&quot;$listeners&quot;&gt;&lt;/input&gt;</span><br></pre></td></tr></table></figure></p>
<p>给之前的栗子绑定一个聚焦事件，在子组件中通过 $listeners 绑定给 input，则会在 input 聚焦时触发。<br>那么除了用在这种给组件内指定元素绑定特性和事件的情况，还有哪些场景可以用到呢？官方说明：在创建更高层次的组件时非常有用。比如在祖孙组件中传递数据，在孙子组件中触发事件后要在祖辈中做相应更新。我们继续之前的栗子：在孙辈组件触发点击事件，然后在祖辈中修改相应的 data。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// communication.vue</span><br><span class="line">&lt;communication-sub v-bind=&quot;dataProps&quot;</span><br><span class="line">                @click=&quot;onCommunicationClick&quot;&gt;</span><br><span class="line">&lt;/communication-sub&gt;</span><br><span class="line">···</span><br><span class="line">methods: &#123;</span><br><span class="line">    onCommunicationClick() &#123;</span><br><span class="line">        this.dataProps.title = &apos;我是点击之后的值&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// communication-sub.vue</span><br><span class="line">&lt;communication-min-sub v-on=&quot;$listeners&quot;&gt;&lt;/communication-min-sub&gt; // 子组件中将事件透传到孙辈</span><br><span class="line"></span><br><span class="line">// communication-min-sub.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;communication-min-sub&quot;&gt;</span><br><span class="line">        &lt;p&gt;我是 communication-min-sub&lt;/p&gt;</span><br><span class="line">        &lt;button v-on=&quot;$listeners&quot;&gt;click&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">    name: &apos;communication-min-sub&apos;,</span><br><span class="line">    inheritAttrs: false</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>这样就能很方便的在多级组件的子级组件中，快速访问到父组件的数据和方法。正如在刚才的例子中，button 点击时，是直接调用的 communication.vue 中定义的方法。</p>
<h4 id="依赖注入provide-inject"><a href="#依赖注入provide-inject" class="headerlink" title="依赖注入provide.inject"></a>依赖注入provide.inject</h4><p>上面的方法，在大多数多级组件嵌套的场景很有用，但有时我们遇到的并不一定是有父子关系的组件。比如基础组件中的 Select 下拉选择器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-select v-model=&quot;value&quot; placeholder=&quot;请选择&quot;&gt;</span><br><span class="line">    &lt;el-option</span><br><span class="line">      v-for=&quot;item in options&quot;</span><br><span class="line">      :key=&quot;item.value&quot;</span><br><span class="line">      :label=&quot;item.label&quot;</span><br><span class="line">      :value=&quot;item.value&quot;&gt;</span><br><span class="line">    &lt;/el-option&gt;</span><br><span class="line">&lt;/el-select&gt;</span><br></pre></td></tr></table></figure></p>
<p>相信大家都使用过上栗或者类似于上栗的基础组件，它们借助 vue 插槽 实现。所以这个时候，el-select 和 el-option 之间的数据通信，我们之前的 $attrs、$listeners就没有用武之地了。有同学可能不太理解上面的代码为什么要通信，我简单介绍一下 Element 的处理方式：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/3/24/169ad1c7a633c1f1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>我们可以简单的认为（Element 源码比这个要稍复杂，为了方便理解，简化一下，如有需要，可直接前往源码阅读），在 el-select 中有一个 input 元素，el-option 中是一列渲染好的 li。根据需求，我们在选中某个 li 的时候，要通知 input 展示相应的数据。而且我们在实际使用的时候，一般还伴随 el-form、el-form-item等组件，所以迫切需要一种方式:</p>
<blockquote>
<p>可以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。</p>
</blockquote>
<p>有同学可能会想到，这种多级的可以用 Vuex、EventBus等方式，当然可以。只不过我们现在的前提是基础组件，一般第三方组件库是不会增加一些额外的依赖的。事实上 Vue 本身并不推荐直接在业务中使用 provide、inject，一般在组件、插件库用到的比较多。<br>但是在项目比较小、业务逻辑比较简单的时候，我们完全不必特意引入 Vuex。只要使用得当，provide、inject 确实不失为一种好办法。说了这么多，我们来看一下具体用法，我们将之前的栗子，改为用 provide、inject 来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// communication.vue</span><br><span class="line">&lt;communication-sub v-bind=&quot;dataProps&quot; &gt;</span><br><span class="line">&lt;/communication-sub&gt;</span><br><span class="line">// @click=&quot;onCommunicationClick&quot; 移除之前绑定的时间</span><br><span class="line">···</span><br><span class="line">// 在 provide 添加子代需要接收的方法 onCommunicationClick，</span><br><span class="line">// 也可以直接指定为 this，子代便能访问父代所有的数据和方法。</span><br><span class="line">provide: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        onCommunicationClick: this.onCommunicationClick</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    onCommunicationClick() &#123;</span><br><span class="line">        this.dataProps.title = &apos;我是点击之后的值&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// communication-sub.vue</span><br><span class="line">&lt;communication-min-sub&gt;&lt;/communication-min-sub&gt;</span><br><span class="line">// 移除之前的 v-on=&quot;$listeners&quot;，因为在这个组件中不需要用到父组件的方法，所以不用做其它处理</span><br><span class="line"></span><br><span class="line">// communication-min-sub.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;communication-min-sub&quot;&gt;</span><br><span class="line">        ···</span><br><span class="line">        &lt;button @click=&quot;onCommunicationClick&quot;&gt;click&lt;/button&gt;</span><br><span class="line">        // 移除 v-on=&quot;$listeners&quot;，然后绑定 inject 接收到的方法</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">    name: &apos;communication-min-sub&apos;,</span><br><span class="line">    inject: [&apos;onCommunicationClick&apos;] // inject 接收父组件的方法</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>这种写法和之前的 $listeners 得到的效果是一样的.<br>思考：有些同学可能会想到，如果我在根实例，app.vue 中如此设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    provide () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        app: this // 设置app为this</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        userInfo: null,</span><br><span class="line">        otherState: null</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>那这样把所有的状态管理都放在 app.data 中，所有的子代中不就可以共享了吗？是不是就不需要 Vuex 了呢？实际上，Vue 本身就提供了一个方法来访问根实例 $root，所以即使没有 provide 也是可以做到的。那为什么不这么用呢？还是前面提到的原因，不利于追踪维护，也失去了所谓状态管理的意义。不过，如果你的项目足够小的话，依然可以这么使用。</p>
<h4 id="ref-parent-children"><a href="#ref-parent-children" class="headerlink" title="ref,parent,children"></a>ref,parent,children</h4><p>我们前面一直说的都是子组件如何触达父组件，那么父组件能不能访问到子组件呢？当然是可以的。</p>
<ul>
<li>ref<br>简单来说就是获取元素的 Dom 对象和子组件实例。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例。获取 Dom 元素就是为了进行一些 Dom 操作，需要注意的一点就是，<strong>要在 Dom 加载完成后使用</strong>，否则可能获取不到。比如我要将之前 input 的字体颜色改成红色：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;dataProps.title&quot; ref=&quot;input&quot;&gt;</span><br><span class="line">...</span><br><span class="line">mounted() &#123;</span><br><span class="line">    this.$nextTick(_ =&gt; &#123; // 确保 Dom 更新完成</span><br><span class="line">        this.$refs[&apos;input&apos;].style.color = &apos;red&apos;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">// 这里只是举一个栗子，实际项目中的需求，最好通过 class 的方式，尽量减少 Dom 操作。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>那什么情况下需要获取组件实例呢？比如父元素的某个状态改变，需要子组件进行 http 请求更新数据。通常情况下，我们会选择通过 Props 将状态传递给子组件，然后子组件进行 Watch 监测，如果有变更，则进行相应操作。这个时候，我们便可以选择使用 ref。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;child ref=&quot;child&quot;&gt;&lt;/child&gt;</span><br><span class="line">···</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    methods () &#123;</span><br><span class="line">      onStateChange() &#123; // 变更状态后直接调用子组件方法进行更新</span><br><span class="line">          this.$refs[&apos;child&apos;].updateData();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>$children,$parent<br>无独有偶，$children 同样可以完成上面的任务。$children 和 $parent，顾名思义，一个会找到当前组件的子组件，一个会找到当前组件的父组件。如果有多个子组件，需要依赖组件实例的 name 属性。改写一下上面的方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    methods () &#123;</span><br><span class="line">      onStateChange() &#123; // 子组件返回的是一个数组，多个子组件用 $options.name 区分。</span><br><span class="line">          this.$children[0].updateData();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$parent 和 $children 用法一样，不过 $parent 返回的父组件实例，不是数组，因为父组件肯定只有一个。ref、parent、children 它们几个的一个缺点就是无法处理跨级组件和兄弟组件，后续我们会介绍 dispatch 和 broadcast 方法，实现跨级通信。</p>
<h4 id="emit-on-off"><a href="#emit-on-off" class="headerlink" title="emit,on,off"></a>emit,on,off</h4><p>$emit，想必大家都非常熟悉，我们通常用作父子组件间通信，我们也叫它自定义事件。$emit 和 $on都是组件自身的方法，$on 可以监听 $emit 派发的事件，$off 则用来取消事件监听。这也是我们下一个要讲的通信方式 EventBus 所依赖的原理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;button-component @clickButton=&quot;clickButton&quot;&gt;&lt;/button-component&gt;</span><br><span class="line">    // 在父组件利用 v-on 监听</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">      clickButton () &#123; ··· &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;button @click=&quot;handleClick&quot;&gt;&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleClick () &#123; // 触发 $emit</span><br><span class="line">        this.$emit(&apos;clickButton&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        this.$on(&apos;clickButton&apos;, (...arr) =&gt; &#123; // 也可以自己监听 $emit，虽然没什么用···</span><br><span class="line">            console.log(...arr);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h4><p>$emit的痛点依然是支持跨级和兄弟组件，Vue 官方推荐我们使用一个新的 Vue 实例来做一个全局的事件通信（或者叫中央事件总线···），也就是我们要讲的 EventBus。了解过的同学都知道，正常的 bus，我们一般会挂载到 Vue 的 prototype 上，方便全局调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">Vue.prototype.$bus = new Vue();</span><br></pre></td></tr></table></figure></p>
<p>依旧改写之前的栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--communication.vue--&gt;</span><br><span class="line">&lt;communication-sub v-bind=&quot;dataProps&quot; &gt;</span><br><span class="line">&lt;/communication-sub&gt;</span><br><span class="line">···</span><br><span class="line">beforeDestroy() &#123; &lt;!-- 实例销毁时，需要卸载监听事件 --&gt;</span><br><span class="line">    this.$bus.$off(&apos;busClick&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">created() &#123;  &lt;!-- 监听子组件触发的 Bus 事件--&gt;</span><br><span class="line">    this.$bus.$on(&apos;busClick&apos;, (data) =&gt; &#123;</span><br><span class="line">        this.dataProps.title = data;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!--communication-min-sub.vue--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;communication-min-sub&quot;&gt;</span><br><span class="line">        &lt;button @click=&quot;busClick&quot;&gt;click bus&lt;/button&gt;</span><br><span class="line">        &lt;!--子组件触发点击事件--&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        busClick() &#123;</span><br><span class="line">            this.$bus.$emit(&apos;busClick&apos;, &apos;bus 触发了&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>这是一个基础的 EventBus 的实现。现在我们设想一下，类似于 userInfo 这样的信息，在很多页面都需要用到，那我们需要在许多页面都做 $on 监听的操作。那能否将这些操作整合到一起呢？我们一起来看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> // 新建一个 eventBus.js</span><br><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">const bus = new Vue(&#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            userInfo: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created () &#123;</span><br><span class="line">        this.$on(&apos;getUserInfo&apos;, val =&gt; &#123;</span><br><span class="line">            this.userInfo = val;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">export default bus;</span><br><span class="line">// main.js</span><br><span class="line">import bus from &apos;./eventBus&apos;;</span><br><span class="line">Vue.prototype.$bus = bus;</span><br><span class="line">// app.vue</span><br><span class="line">methods: &#123;</span><br><span class="line">    getUserInfo() &#123;</span><br><span class="line">        ajax.post(***).then(data =&gt; &#123;</span><br><span class="line">            this.$bus.$emit(&apos;getUserInfo&apos;, data); // 通知 EventBus 更新 userInfo</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样在其他页面用到 userInfo 的时候，只需要 this.$bus.userInfo 就可以了。注意刚刚其实没有用 off 卸载掉监听，因为其实 userInfo 这种全局信息，并没有一个准确的说要销毁的时机，浏览器关闭的时候，也用不着我们处理了。但是，如果只是某个页面组件用到的，建议还是用最开始的方法，在页面销毁的时候卸载掉。</p>
<h4 id="派发与广播-dispath与broadcast"><a href="#派发与广播-dispath与broadcast" class="headerlink" title="派发与广播:dispath与broadcast"></a>派发与广播:dispath与broadcast</h4><p>在 Vue 1.x 的实现中，有 $dispatch 和 $broadcast 方法，但是在 2.x 被废弃了。$dispatch 的主要作用是向上级组件派发事件，$broadcast 则是向下级广播。它们的优点是都支持跨级，再看一下官方废弃这两个方法的理由：</p>
<blockquote>
<p>因为基于组件树结构的事件流方式实在是让人难以理解，并且在组件结构扩展的过程中会变得越来越脆弱。并且 $dispatch 和 $broadcast 也没有解决兄弟组件间的通信问题。</p>
</blockquote>
<p>可以看到，主要原因是在组件结构扩展后不易理解，以及没有解决兄弟组件通信的问题。但是对于组件库来说，这依旧是十分有用的，所以它们大多自己实现了这两个方法。对我们来讲，也许在项目中用不到，但学习这种解决问题的思路，是十分必要的。<br>派发和广播，依赖于组件的 name（最怕此处有人说：如果不写 name，这方法不就没用了？2333···），以此来逐级查找对应的组件实例。Element 的实现中，给所有的组件都加了一个 componentName 属性，所以它是根据 componentName 来查找的。我们在实现的时候还是直接用 name。<br>我们先来看一下 $dispatch 的简单用法，再来分析思路。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--communication-min-sub.vue--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;handleDispatch&quot;&gt;dispatch&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Emitter from &apos;../../utils/emitter&apos;;</span><br><span class="line">export default &#123;</span><br><span class="line">  mixins: [Emitter], // 混入，方便直接调用</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleDispatch () &#123;</span><br><span class="line">      this.dispatch(&apos;communication&apos;, &apos;onMessage&apos;, &apos;触发了dispatch&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--communication.vue--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    beforeDestroy() &#123; // 销毁</span><br><span class="line">        this.$off(&apos;onMessage&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">        this.$on(&apos;onMessage&apos;, (data) =&gt; &#123; // 监听</span><br><span class="line">            this.dataProps.title = data;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>现在明确一下目标，dispatch 方法接收三个参数，组件 name、事件名称、基础数据（可不传）。要做到向上跨级派发事件，需要向上找到指定 name 的组件实例，利用我们前文提到的 $emit方法做派送，所以在指定组件就可以用 $on 来监听了。所以 dispatch 本质上就是向上查找到指定组件并触发其自身的 $emit，以此来做响应，broadcast 则相反。那么如何做到跨级查找呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function broadcast(componentName, eventName, params) &#123;</span><br><span class="line">  this.$children.forEach(child =&gt; &#123; // 遍历所有的 $children</span><br><span class="line">    var name = child.$options.name; // 拿到实例的name，Element 此处用的 componentName</span><br><span class="line">    if (name === componentName) &#123; // 如果是想要的那个，进行广播</span><br><span class="line">      child.$emit.apply(child, [eventName].concat(params));</span><br><span class="line">    &#125; else &#123; // 不是则递归查找 直到 $children 为 []</span><br><span class="line">      broadcast.apply(child, [componentName, eventName].concat([params]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    dispatch(componentName, eventName, params) &#123;</span><br><span class="line">      var parent = this.$parent || this.$root;</span><br><span class="line">      var name = parent.$options.name;</span><br><span class="line">      while (parent &amp;&amp; (!name || name !== componentName)) &#123;</span><br><span class="line">      // 存在 parent 且 (不存在 name 或 name 和 指定参数不一样) 则继续查找</span><br><span class="line">        parent = parent.$parent; // 不存在继续取上级</span><br><span class="line">        if (parent) &#123;</span><br><span class="line">          name = parent.$options.name; // 存在上级 再次赋值并再次循环，进行判断</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (parent) &#123; // 找到以后 如果有 进行事件派发</span><br><span class="line">        parent.$emit.apply(parent, [eventName].concat(params));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    broadcast(componentName, eventName, params) &#123;</span><br><span class="line">      broadcast.call(this, componentName, eventName, params);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以上是详细的 emitter.js，可以看见，这和我们之前讲到的 $parent、$children、$emit、$on都密切相关。这也是为什么把它放到后面讲的原因。之前说过，派发和广播并没有解决兄弟组件通信的问题，所以这里大家也可以拓展思考一下，如何支持兄弟组件间通信。依然是依赖于$parent、$children，可以找到任意指定组件。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本期文章内容到这里就讲完了，我们来总结回顾一下：</p>
<ul>
<li>子组件触达父组件的方式：Props、$parent、$attrs、$listeners、provide 和 inject、$dispatch</li>
<li>父组件触达子组件的方式：$emit 和 $on、$children、$ref、broadcast</li>
<li>全局通信：EventBus、Vuex</li>
</ul>
<blockquote>
<p>转载：<br><a href="https://juejin.im/post/5c776ee4f265da2da53edfad" target="_blank" rel="noopener">Vue 组件间通信方式完整版</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/17/vue组件通信/" data-id="cjwgem1l8000w5wtjku45vrxf" class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/">vue</a></li></ul>

    </footer>

  </div>

  
    
  <nav class="article-nav">
    
      <a href="/2019/05/09/手写代码/" class="article-nav-link">
        <strong class="article-nav-caption">上篇</strong>
        <div class="article-nav-title">
          
            手写代码
          
        </div>
      </a>
    
    
      <a href="/2019/04/13/async-await/" class="article-nav-link">
        <strong class="article-nav-caption">下篇</strong>
        <div class="article-nav-title">async/await</div>
      </a>
    
  </nav>


  

  
    
  

</article>



</section>
  <footer class="footer">
  
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <!-- <ul class="list-inline">
      <li>&copy; 2019 Now you can see me</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul> -->
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>

<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/cat.svg" alt="Now you can see me"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">首页</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">归档</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">相册</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">关于</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>

<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>

<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>
<script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>



  <script src="/js/search.js"></script>


<script src="/js/ocean.js"></script>

</body>
</html>