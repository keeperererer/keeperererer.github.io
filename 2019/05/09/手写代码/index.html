<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    手写代码 |
    
    Now you can see me</title>
  
    <link rel="shortcut icon" href="/cat.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="outer">
  <article id="post-手写代码" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      手写代码
    </h1>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/05/09/手写代码/" class="article-date">
  <time datetime="2019-05-09T10:32:53.000Z" itemprop="datePublished">2019-05-09</time>
</a>
        
        <!-- <span class="article-time">读完需要大约 -->
        <!-- 9</span> -->
        <!-- <span>分钟</span> -->
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <h3 id="实现new操作符"><a href="#实现new操作符" class="headerlink" title="实现new操作符"></a>实现new操作符</h3><a id="more"></a>
<h4 id="new操作符做了什么？"><a href="#new操作符做了什么？" class="headerlink" title="new操作符做了什么？"></a>new操作符做了什么？</h4><ul>
<li>它创建了一个全新的对象。</li>
<li>它会被执行[[Prototype]]（也就是<strong>proto</strong>）链接。</li>
<li>它使this指向新创建的对象。</li>
<li>通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。</li>
<li>如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用。</li>
</ul>
<p>实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">func</span>)</span>&#123;</span><br><span class="line"> 	<span class="keyword">let</span> res = &#123;&#125;</span><br><span class="line"> 	res.__proto__ = func.prototype</span><br><span class="line"> 	<span class="keyword">let</span> ret = func.apply(res,<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>));</span><br><span class="line"> 	<span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? ret : res</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">slice(start,end) ==&gt; 返回一个从[start（从<span class="number">0</span>开始） ,end)的新数组</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="实现一个instanceof"><a href="#实现一个instanceof" class="headerlink" title="实现一个instanceof"></a>实现一个instanceof</h3><h4 id="instanceof的原理？"><a href="#instanceof的原理？" class="headerlink" title="instanceof的原理？"></a>instanceof的原理？</h4><p>instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。</p>
<p>实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prototype = right.prototype</span><br><span class="line">  left = left.__proto__</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left === <span class="literal">null</span> || left === <span class="literal">undefined</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (prototype === left)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    left = left.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分析：</p>
<ul>
<li>首先获取类型的原型</li>
<li>然后获得对象的原型</li>
<li>然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null</li>
</ul>
<hr>
<h3 id="实现一个call-amp-apply"><a href="#实现一个call-amp-apply" class="headerlink" title="实现一个call &amp; apply"></a>实现一个call &amp; apply</h3><h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">实现：</span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error")</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">context = context || window</span></span><br><span class="line"><span class="string">context.fn = this</span></span><br><span class="line"><span class="string">const args = [...arguments].slice(1)</span></span><br><span class="line"><span class="string">const result = context.fn(...args)</span></span><br><span class="line"><span class="string">delete context.fn</span></span><br><span class="line"><span class="string">return result</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>以下是对实现的分析：</p>
<p>首先 context 为可选参数，如果不传的话默认上下文为 window<br>接下来给 context 创建一个 fn 属性，并将值设置为需要调用的函数<br>因为 call 可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来<br>然后调用函数并将对象上的函数删除</p>
<h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">&#125;</span><br><span class="line">context = context || <span class="built_in">window</span></span><br><span class="line">context.fn = <span class="keyword">this</span></span><br><span class="line"><span class="keyword">let</span> result</span><br><span class="line"><span class="comment">// 处理参数和 call 有区别</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">result = context.fn(...arguments[<span class="number">1</span>])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result = context.fn()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> context.fn</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="实现一个bind"><a href="#实现一个bind" class="headerlink" title="实现一个bind"></a>实现一个bind</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> _this = <span class="keyword">this</span></span><br><span class="line"><span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 返回一个函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> _this(...args, ...arguments)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _this.apply(context, args.concat(...arguments))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是对实现的分析：</p>
<p>前几步和之前的实现差不多，就不赘述了<br>bind 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 new 的方式，我们先来说直接调用的方式<br>对于直接调用来说，这里选择了 apply 的方式实现，但是对于参数需要注意以下情况：因为 bind 可以实现类似这样的代码 f.bind(obj, 1)(2)，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 args.concat(…arguments)<br>最后来说通过 new 的方式，在之前的章节中我们学习过如何判断 this，对于 new 的情况来说，不会被任何方式改变 this，所以对于这种情况我们需要忽略传入的 this</p>
<hr>
<h3 id="实现一个简易版的promise"><a href="#实现一个简易版的promise" class="headerlink" title="实现一个简易版的promise"></a>实现一个简易版的promise</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">'resolved'</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> that = <span class="keyword">this</span></span><br><span class="line">  that.state = PENDING</span><br><span class="line">  that.value = <span class="literal">null</span></span><br><span class="line">  that.resolvedCallbacks = []</span><br><span class="line">  that.rejectedCallbacks = []</span><br><span class="line">  <span class="comment">// 待完善 resolve 和 reject 函数</span></span><br><span class="line">  <span class="comment">// 待完善执行 fn 函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先我们创建了三个常量用于表示状态，对于经常使用的一些值都应该通过常量来管理，便于开发及后期维护</li>
<li>在函数体内部首先创建了常量 that，因为代码可能会异步执行，用于获取正确的 this 对象</li>
<li>一开始 Promise 的状态应该是 pending<br>value 变量用于保存 resolve 或者 reject 中传入的值</li>
<li>resolvedCallbacks 和 rejectedCallbacks 用于保存 then 中的回调，因为当执行完 Promise 时状态可能还是等待中，这时候应该把 then 中的回调保存起来用于状态改变时使用</li>
</ul>
<p>接下来我们来完善 resolve 和 reject 函数，添加在 MyPromise 函数体内部<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (that.state === PENDING) &#123;</span><br><span class="line">    that.state = RESOLVED</span><br><span class="line">    that.value = value</span><br><span class="line">    that.resolvedCallbacks.map(<span class="function"><span class="params">cb</span> =&gt;</span> cb(that.value))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (that.state === PENDING) &#123;</span><br><span class="line">    that.state = REJECTED</span><br><span class="line">    that.value = value</span><br><span class="line">    that.rejectedCallbacks.map(<span class="function"><span class="params">cb</span> =&gt;</span> cb(that.value))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两个函数代码类似，就一起解析了</p>
<ul>
<li>首先两个函数都得判断当前状态是否为等待中，因为规范规定只有等待态才可以改变状态</li>
<li>将当前状态更改为对应状态，并且将传入的值赋值给 value</li>
<li>遍历回调数组并执行</li>
</ul>
<p>完成以上两个函数以后，我们就该实现如何执行 Promise 中传入的函数了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  fn(resolve, reject)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  reject(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>实现很简单，执行传入的参数并且将之前两个函数当做参数传进去</li>
<li>要注意的是，可能执行函数过程中会遇到错误，需要捕获错误并且执行 reject 函数</li>
</ul>
<p>最后我们来实现较为复杂的 then 函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> that = <span class="keyword">this</span></span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">v</span> =&gt;</span> v</span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> r</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="keyword">if</span> (that.state === PENDING) &#123;</span><br><span class="line">    that.resolvedCallbacks.push(onFulfilled)</span><br><span class="line">    that.rejectedCallbacks.push(onRejected)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (that.state === RESOLVED) &#123;</span><br><span class="line">    onFulfilled(that.value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (that.state === REJECTED) &#123;</span><br><span class="line">    onRejected(that.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>首先判断两个参数是否为函数类型，因为这两个参数是可选参数</p>
</li>
<li><p>当参数不是函数类型时，需要创建一个函数赋值给对应的参数，同时也实现了透传，比如如下代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该代码目前在简单版中会报错</span></span><br><span class="line"><span class="comment">// 只是作为一个透传的例子</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">4</span>).then().then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(value))</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来就是一系列判断状态的逻辑，当状态不是等待态时，就去执行相对应的函数。如果状态是等待态的话，就往回调函数中 push 函数，比如如下代码就会进入等待态的逻辑</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="实现防抖-amp-节流"><a href="#实现防抖-amp-节流" class="headerlink" title="实现防抖 &amp; 节流"></a>实现防抖 &amp; 节流</h3><hr>
<h3 id="实现深拷贝"><a href="#实现深拷贝" class="headerlink" title="实现深拷贝"></a>实现深拷贝</h3><hr>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"Dad"</span></span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">## Child.prototype = new Parent();</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(child.getName())</span><br></pre></td></tr></table></figure>
<p>问题：<br>1.引用类型的属性被所有实例共享，如果在实例1中修改了属性的值，实例2也会被修改<br>2.在创建Child的实例时，不能向Parent传参</p>
<h4 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = [<span class="string">'kevin'</span>,<span class="string">'daisy'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  ## Parent.call(this)</span><br><span class="line">&#125;</span><br><span class="line">## var child1 = new Child();</span><br><span class="line">child1.name.push(<span class="string">'yayu'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1.names);<span class="comment">//['kevin','daisy','yayu']</span></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(child2.names);<span class="comment">//['kevin','daisy']</span></span><br></pre></td></tr></table></figure>
<p>缺点：方法都在构造函数中定义，每次创建实例都会创建一遍方法</p>
<h4 id="组合继承-经典继承-最常用"><a href="#组合继承-经典继承-最常用" class="headerlink" title="组合继承|经典继承(最常用)"></a>组合继承|经典继承(最常用)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  ## Parent.call(this,name)</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">## Child.prototype = new Parent();</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>,<span class="string">'18'</span>)</span><br><span class="line">child1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1.name);<span class="comment">//kevin</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.age);<span class="comment">//18</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.colors);<span class="comment">//['red','blue','green','black']</span></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">'daisy'</span>,<span class="string">'20'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child2.name)<span class="comment">//daisy</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.age)<span class="comment">//20</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.colors)<span class="comment">//['red','blue','green']</span></span><br></pre></td></tr></table></figure>
<p>缺点是会调用两次构造函数<br>1.设置子类型实例的原型的时候<br>  Child.prototype = new Parent();<br>2.一次是在创建子类型实例的时候<br>  var child1 = new Child(‘kevin’,’18’);</p>
<h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name:<span class="string">'kevin'</span>,</span><br><span class="line">  friends:[<span class="string">'daisy'</span>,<span class="string">'kelly'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = createObj(person);</span><br><span class="line"><span class="keyword">var</span> person2 = createObj(person);</span><br><span class="line">person1.name = <span class="string">'person'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// kevin</span></span><br><span class="line">person1.firends.push(<span class="string">'taylor'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person2.friends); <span class="comment">// ["daisy", "kelly", "taylor"]</span></span><br></pre></td></tr></table></figure>
<p>缺点：包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样</p>
<h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.color = [<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>,name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关键的三步</span></span><br><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">F.prototype = Parent.prototype;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> F();</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>,<span class="string">'18'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1);</span><br></pre></td></tr></table></figure>
<h4 id="class继承"><a href="#class继承" class="headerlink" title="class继承"></a>class继承</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value)&#123;</span><br><span class="line">    <span class="keyword">this</span>.val = value</span><br><span class="line">  &#125;</span><br><span class="line">  getValue()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="title">extend</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value)&#123;</span><br><span class="line">    <span class="keyword">super</span>(value)</span><br><span class="line">    <span class="keyword">this</span>.val = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>)</span><br><span class="line">child.getValue()<span class="comment">//1</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>说明：<br>class 实现继承的核心在于使用 extends 表明继承自哪个父类，<br>并且在子类构造函数中必须调用 super，<br>因为这段代码可以看成 Parent.call(this, value)。</p>
<hr>
<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise-all"></a>Promise-all</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> results = [];</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = promises.length; i &lt; len; i++)&#123;</span><br><span class="line">        promises[i].then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">          results[i] = res;</span><br><span class="line">          count++;</span><br><span class="line">          <span class="keyword">if</span>(count === len)&#123;</span><br><span class="line">            resolve(results);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,(err) =&gt; &#123;</span><br><span class="line">          <span class="keyword">return</span> reject(err);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise-race"></a>Promise-race</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++)&#123;</span><br><span class="line">      promises[i].then(resolve,reject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/09/手写代码/" data-id="cjypwvdya001hpwtujx7yeyae" class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/coding/">coding</a></li></ul>

    </footer>

  </div>

  
    
  <nav class="article-nav">
    
      <a href="/2019/05/09/数据结构/" class="article-nav-link">
        <strong class="article-nav-caption">上篇</strong>
        <div class="article-nav-title">
          
            数据结构
          
        </div>
      </a>
    
    
      <a href="/2019/04/17/vue组件通信/" class="article-nav-link">
        <strong class="article-nav-caption">下篇</strong>
        <div class="article-nav-title">vue组件通信</div>
      </a>
    
  </nav>


  

  
    
  

</article>



</section>
  <footer class="footer">
  
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <!-- <ul class="list-inline">
      <li>&copy; 2019 Now you can see me</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul> -->
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>

<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/cat.svg" alt="Now you can see me"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">首页</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">归档</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">相册</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">关于</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>

<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>

<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>
<script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>



  <script src="/js/search.js"></script>


<script src="/js/ocean.js"></script>

</body>
</html>