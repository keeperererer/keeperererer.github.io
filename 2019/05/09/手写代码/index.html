<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    手写代码 |
    
    Now you can see me</title>
  
    <link rel="shortcut icon" href="/cat.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="outer">
  <article id="post-手写代码" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      手写代码
    </h1>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/05/09/手写代码/" class="article-date">
  <time datetime="2019-05-09T10:32:53.000Z" itemprop="datePublished">2019-05-09</time>
</a>
        
        <!-- <span class="article-time">读完需要大约 -->
        <!-- 10</span> -->
        <!-- <span>分钟</span> -->
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <h3 id="实现new操作符"><a href="#实现new操作符" class="headerlink" title="实现new操作符"></a>实现new操作符</h3><a id="more"></a>
<h4 id="new操作符做了什么？"><a href="#new操作符做了什么？" class="headerlink" title="new操作符做了什么？"></a>new操作符做了什么？</h4><ul>
<li>它创建了一个全新的对象。</li>
<li>它会被执行[[Prototype]]（也就是<strong>proto</strong>）链接。</li>
<li>它使this指向新创建的对象。</li>
<li>通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。</li>
<li>如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用。</li>
</ul>
<p>实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function myNew(func)&#123;</span><br><span class="line"> 	let res = &#123;&#125;</span><br><span class="line"> 	res.__proto__ = func.prototype</span><br><span class="line"> 	let ret = func.apply(res,Array.prototype.slice.call(arguments,1));</span><br><span class="line"> 	return ret instanceof Object ? ret : res</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">slice(start,end) ==&gt; 返回一个从[start（从0开始） ,end)的新数组</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="实现一个instanceof"><a href="#实现一个instanceof" class="headerlink" title="实现一个instanceof"></a>实现一个instanceof</h3><h4 id="instanceof的原理？"><a href="#instanceof的原理？" class="headerlink" title="instanceof的原理？"></a>instanceof的原理？</h4><p>instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。</p>
<p>实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line">  let prototype = right.prototype</span><br><span class="line">  left = left.__proto__</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (left === null || left === undefined)</span><br><span class="line">      return false</span><br><span class="line">    if (prototype === left)</span><br><span class="line">      return true</span><br><span class="line">    left = left.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分析：</p>
<ul>
<li>首先获取类型的原型</li>
<li>然后获得对象的原型</li>
<li>然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null</li>
</ul>
<hr>
<h3 id="实现一个call-amp-apply"><a href="#实现一个call-amp-apply" class="headerlink" title="实现一个call &amp; apply"></a>实现一个call &amp; apply</h3><h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">实现：</span><br><span class="line">Function.prototype.myCall = function(context)&#123;</span><br><span class="line"> if(typeof this !== &apos;function&apos;)&#123;</span><br><span class="line">    throw new TypeError(&apos;Error&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">context = context || window</span><br><span class="line">context.fn = this</span><br><span class="line">const args = [...arguments].slice(1)</span><br><span class="line">const result = context.fn(...args)</span><br><span class="line">delete context.fn</span><br><span class="line">return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是对实现的分析：</p>
<p>首先 context 为可选参数，如果不传的话默认上下文为 window<br>接下来给 context 创建一个 fn 属性，并将值设置为需要调用的函数<br>因为 call 可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来<br>然后调用函数并将对象上的函数删除</p>
<h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myApply = function(context) &#123;</span><br><span class="line">if (typeof this !== &apos;function&apos;) &#123;</span><br><span class="line">throw new TypeError(&apos;Error&apos;)</span><br><span class="line">&#125;</span><br><span class="line">context = context || window</span><br><span class="line">context.fn = this</span><br><span class="line">let result</span><br><span class="line">// 处理参数和 call 有区别</span><br><span class="line">if (arguments[1]) &#123;</span><br><span class="line">result = context.fn(...arguments[1])</span><br><span class="line">&#125; else &#123;</span><br><span class="line">result = context.fn()</span><br><span class="line">&#125;</span><br><span class="line">delete context.fn</span><br><span class="line">return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="实现一个bind"><a href="#实现一个bind" class="headerlink" title="实现一个bind"></a>实现一个bind</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind = function (context) &#123;</span><br><span class="line">if (typeof this !== &apos;function&apos;) &#123;</span><br><span class="line">throw new TypeError(&apos;Error&apos;)</span><br><span class="line">&#125;</span><br><span class="line">const _this = this</span><br><span class="line">const args = [...arguments].slice(1)</span><br><span class="line">// 返回一个函数</span><br><span class="line">return function F() &#123;</span><br><span class="line">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span><br><span class="line">if (this instanceof F) &#123;</span><br><span class="line">return new _this(...args, ...arguments)</span><br><span class="line">&#125;</span><br><span class="line">return _this.apply(context, args.concat(...arguments))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是对实现的分析：</p>
<p>前几步和之前的实现差不多，就不赘述了<br>bind 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 new 的方式，我们先来说直接调用的方式<br>对于直接调用来说，这里选择了 apply 的方式实现，但是对于参数需要注意以下情况：因为 bind 可以实现类似这样的代码 f.bind(obj, 1)(2)，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 args.concat(…arguments)<br>最后来说通过 new 的方式，在之前的章节中我们学习过如何判断 this，对于 new 的情况来说，不会被任何方式改变 this，所以对于这种情况我们需要忽略传入的 this</p>
<hr>
<h3 id="实现一个简易版的promise"><a href="#实现一个简易版的promise" class="headerlink" title="实现一个简易版的promise"></a>实现一个简易版的promise</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const PENDING = &apos;pending&apos;</span><br><span class="line">const RESOLVED = &apos;resolved&apos;</span><br><span class="line">const REJECTED = &apos;rejected&apos;</span><br><span class="line"></span><br><span class="line">function MyPromise(fn) &#123;</span><br><span class="line">  const that = this</span><br><span class="line">  that.state = PENDING</span><br><span class="line">  that.value = null</span><br><span class="line">  that.resolvedCallbacks = []</span><br><span class="line">  that.rejectedCallbacks = []</span><br><span class="line">  // 待完善 resolve 和 reject 函数</span><br><span class="line">  // 待完善执行 fn 函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先我们创建了三个常量用于表示状态，对于经常使用的一些值都应该通过常量来管理，便于开发及后期维护</li>
<li>在函数体内部首先创建了常量 that，因为代码可能会异步执行，用于获取正确的 this 对象</li>
<li>一开始 Promise 的状态应该是 pending<br>value 变量用于保存 resolve 或者 reject 中传入的值</li>
<li>resolvedCallbacks 和 rejectedCallbacks 用于保存 then 中的回调，因为当执行完 Promise 时状态可能还是等待中，这时候应该把 then 中的回调保存起来用于状态改变时使用</li>
</ul>
<p>接下来我们来完善 resolve 和 reject 函数，添加在 MyPromise 函数体内部<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function resolve(value) &#123;</span><br><span class="line">  if (that.state === PENDING) &#123;</span><br><span class="line">    that.state = RESOLVED</span><br><span class="line">    that.value = value</span><br><span class="line">    that.resolvedCallbacks.map(cb =&gt; cb(that.value))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function reject(value) &#123;</span><br><span class="line">  if (that.state === PENDING) &#123;</span><br><span class="line">    that.state = REJECTED</span><br><span class="line">    that.value = value</span><br><span class="line">    that.rejectedCallbacks.map(cb =&gt; cb(that.value))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两个函数代码类似，就一起解析了</p>
<ul>
<li>首先两个函数都得判断当前状态是否为等待中，因为规范规定只有等待态才可以改变状态</li>
<li>将当前状态更改为对应状态，并且将传入的值赋值给 value</li>
<li>遍历回调数组并执行</li>
</ul>
<p>完成以上两个函数以后，我们就该实现如何执行 Promise 中传入的函数了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  fn(resolve, reject)</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  reject(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>实现很简单，执行传入的参数并且将之前两个函数当做参数传进去</li>
<li>要注意的是，可能执行函数过程中会遇到错误，需要捕获错误并且执行 reject 函数</li>
</ul>
<p>最后我们来实现较为复杂的 then 函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.then = function(onFulfilled, onRejected) &#123;</span><br><span class="line">  const that = this</span><br><span class="line">  onFulfilled = typeof onFulfilled === &apos;function&apos; ? onFulfilled : v =&gt; v</span><br><span class="line">  onRejected =</span><br><span class="line">    typeof onRejected === &apos;function&apos;</span><br><span class="line">      ? onRejected</span><br><span class="line">      : r =&gt; &#123;</span><br><span class="line">          throw r</span><br><span class="line">        &#125;</span><br><span class="line">  if (that.state === PENDING) &#123;</span><br><span class="line">    that.resolvedCallbacks.push(onFulfilled)</span><br><span class="line">    that.rejectedCallbacks.push(onRejected)</span><br><span class="line">  &#125;</span><br><span class="line">  if (that.state === RESOLVED) &#123;</span><br><span class="line">    onFulfilled(that.value)</span><br><span class="line">  &#125;</span><br><span class="line">  if (that.state === REJECTED) &#123;</span><br><span class="line">    onRejected(that.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>首先判断两个参数是否为函数类型，因为这两个参数是可选参数</p>
</li>
<li><p>当参数不是函数类型时，需要创建一个函数赋值给对应的参数，同时也实现了透传，比如如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 该代码目前在简单版中会报错</span><br><span class="line">// 只是作为一个透传的例子</span><br><span class="line">Promise.resolve(4).then().then((value) =&gt; console.log(value))</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来就是一系列判断状态的逻辑，当状态不是等待态时，就去执行相对应的函数。如果状态是等待态的话，就往回调函数中 push 函数，比如如下代码就会进入等待态的逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(1)</span><br><span class="line">  &#125;, 0)</span><br><span class="line">&#125;).then(value =&gt; &#123;</span><br><span class="line">  console.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="实现防抖-amp-节流"><a href="#实现防抖-amp-节流" class="headerlink" title="实现防抖 &amp; 节流"></a>实现防抖 &amp; 节流</h3><hr>
<h3 id="实现深拷贝"><a href="#实现深拷贝" class="headerlink" title="实现深拷贝"></a>实现深拷贝</h3><hr>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Parent()&#123;</span><br><span class="line">  this.name = &quot;Dad&quot;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = function()&#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">function Child()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">## Child.prototype = new Parent();</span><br><span class="line">var child1 = new Child();</span><br><span class="line">console.log(child.getName())</span><br></pre></td></tr></table></figure>
<p>问题：<br>1.引用类型的属性被所有实例共享，如果在实例1中修改了属性的值，实例2也会被修改<br>2.在创建Child的实例时，不能向Parent传参</p>
<h4 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Parent()&#123;</span><br><span class="line">  this.name = [&apos;kevin&apos;,&apos;daisy&apos;];</span><br><span class="line">&#125;</span><br><span class="line">function Child()&#123;</span><br><span class="line">  ## Parent.call(this)</span><br><span class="line">&#125;</span><br><span class="line">## var child1 = new Child();</span><br><span class="line">child1.name.push(&apos;yayu&apos;);</span><br><span class="line">console.log(child1.names);//[&apos;kevin&apos;,&apos;daisy&apos;,&apos;yayu&apos;]</span><br><span class="line">var child2 = new Child();</span><br><span class="line">console.log(child2.names);//[&apos;kevin&apos;,&apos;daisy&apos;]</span><br></pre></td></tr></table></figure>
<p>缺点：方法都在构造函数中定义，每次创建实例都会创建一遍方法</p>
<h4 id="组合继承-经典继承-最常用"><a href="#组合继承-经典继承-最常用" class="headerlink" title="组合继承|经典继承(最常用)"></a>组合继承|经典继承(最常用)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Parent(name)&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.colors = [&apos;red&apos;,&apos;blue&apos;,&apos;green&apos;];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = function()&#123;</span><br><span class="line">  console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line">function Child(name,age)&#123;</span><br><span class="line">  ## Parent.call(this,name)</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">## Child.prototype = new Parent();</span><br><span class="line">var child1 = new Child(&apos;kevin&apos;,&apos;18&apos;)</span><br><span class="line">child1.colors.push(&apos;black&apos;);</span><br><span class="line">console.log(child1.name);//kevin</span><br><span class="line">console.log(child1.age);//18</span><br><span class="line">console.log(child1.colors);//[&apos;red&apos;,&apos;blue&apos;,&apos;green&apos;,&apos;black&apos;]</span><br><span class="line">var child2 = new Child(&apos;daisy&apos;,&apos;20&apos;);</span><br><span class="line">console.log(child2.name)//daisy</span><br><span class="line">console.log(child2.age)//20</span><br><span class="line">console.log(child2.colors)//[&apos;red&apos;,&apos;blue&apos;,&apos;green&apos;]</span><br></pre></td></tr></table></figure>
<p>缺点是会调用两次构造函数<br>1.设置子类型实例的原型的时候<br>  Child.prototype = new Parent();<br>2.一次是在创建子类型实例的时候<br>  var child1 = new Child(‘kevin’,’18’);</p>
<h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function createObj(o)&#123;</span><br><span class="line">  function F()&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  return new F();</span><br><span class="line">&#125;</span><br><span class="line">var person = &#123;</span><br><span class="line">  name:&apos;kevin&apos;,</span><br><span class="line">  friends:[&apos;daisy&apos;,&apos;kelly&apos;]</span><br><span class="line">&#125;</span><br><span class="line">var person1 = createObj(person);</span><br><span class="line">var person2 = createObj(person);</span><br><span class="line">person1.name = &apos;person&apos;;</span><br><span class="line">console.log(person2.name); // kevin</span><br><span class="line">person1.firends.push(&apos;taylor&apos;);</span><br><span class="line">console.log(person2.friends); // [&quot;daisy&quot;, &quot;kelly&quot;, &quot;taylor&quot;]</span><br></pre></td></tr></table></figure>
<p>缺点：包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样</p>
<h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Parent(name)&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.color = [&apos;red&apos;,&apos;blue&apos;,&apos;green&apos;];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = function()&#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">function Child(name,age)&#123;</span><br><span class="line">  Parent.call(this,name);</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">//关键的三步</span><br><span class="line">var F = function()&#123;&#125;;</span><br><span class="line">F.prototype = Parent.prototype;</span><br><span class="line">Child.prototype = new F();</span><br><span class="line">var child1 = new Child(&apos;kevin&apos;,&apos;18&apos;);</span><br><span class="line">console.log(child1);</span><br></pre></td></tr></table></figure>
<h4 id="class继承"><a href="#class继承" class="headerlink" title="class继承"></a>class继承</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Parent&#123;</span><br><span class="line">  constructor(value)&#123;</span><br><span class="line">    this.val = value</span><br><span class="line">  &#125;</span><br><span class="line">  getValue()&#123;</span><br><span class="line">    console.log(this.val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child extend Parent&#123;</span><br><span class="line">  constructor(value)&#123;</span><br><span class="line">    super(value)</span><br><span class="line">    this.val = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let child = new Child(1)</span><br><span class="line">child.getValue()//1</span><br><span class="line">child instanceof Parent //true</span><br></pre></td></tr></table></figure>
<p>说明：<br>class 实现继承的核心在于使用 extends 表明继承自哪个父类，<br>并且在子类构造函数中必须调用 super，<br>因为这段代码可以看成 Parent.call(this, value)。</p>
<hr>
<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise-all"></a>Promise-all</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Promise.all = function(promises)&#123;</span><br><span class="line">  return new Promise((resolve,reject) =&gt; &#123;</span><br><span class="line">    let results = [];</span><br><span class="line">    let count = 0;</span><br><span class="line">    for(let i = 0, len = promises.length; i &lt; len; i++)&#123;</span><br><span class="line">        promises[i].then((res) =&gt; &#123;</span><br><span class="line">          results[i] = res;</span><br><span class="line">          count++;</span><br><span class="line">          if(count === len)&#123;</span><br><span class="line">            resolve(results);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,(err) =&gt; &#123;</span><br><span class="line">          return reject(err);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise-race"></a>Promise-race</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Promise.race = function(promises)&#123;</span><br><span class="line">  return new Promise((resolve,reject) =&gt; &#123;</span><br><span class="line">    for(let i = 0; i &lt; promises.length; i++)&#123;</span><br><span class="line">      promises[i].then(resolve,reject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/09/手写代码/" data-id="cjyprkn59001fa8tua98rqrzb" class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/coding/">coding</a></li></ul>

    </footer>

  </div>

  
    
  <nav class="article-nav">
    
      <a href="/2019/05/09/数据结构/" class="article-nav-link">
        <strong class="article-nav-caption">上篇</strong>
        <div class="article-nav-title">
          
            数据结构
          
        </div>
      </a>
    
    
      <a href="/2019/04/17/vue组件通信/" class="article-nav-link">
        <strong class="article-nav-caption">下篇</strong>
        <div class="article-nav-title">vue组件通信</div>
      </a>
    
  </nav>


  

  
    
  

</article>



</section>
  <footer class="footer">
  
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <!-- <ul class="list-inline">
      <li>&copy; 2019 Now you can see me</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul> -->
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>

<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/cat.svg" alt="Now you can see me"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">首页</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">归档</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">相册</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">关于</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>

<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>

<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>
<script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>



  <script src="/js/search.js"></script>


<script src="/js/ocean.js"></script>

</body>
</html>